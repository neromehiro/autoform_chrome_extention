/.git/COMMIT_EDITMSG:
--------------------------------------------------------------------------------
  1 | aa
--------------------------------------------------------------------------------

/.git/FETCH_HEAD:
--------------------------------------------------------------------------------
  1 | 72d1a9aa21705c959c769fc65fe9f988e4da33e8		branch 'main' of https://github.com/neromehiro/autoform_chrome_extention
--------------------------------------------------------------------------------

/.git/HEAD:
--------------------------------------------------------------------------------
  1 | ref: refs/heads/main
--------------------------------------------------------------------------------

/.git/config:
--------------------------------------------------------------------------------
  1 | [core]
  2 | 	repositoryformatversion = 0
  3 | 	filemode = true
  4 | 	bare = false
  5 | 	logallrefupdates = true
  6 | 	ignorecase = true
  7 | 	precomposeunicode = true
  8 | [remote "origin"]
  9 | 	url = https://github.com/neromehiro/autoform_chrome_extention
 10 | 	fetch = +refs/heads/*:refs/remotes/origin/*
 11 | [branch "main"]
 12 | 	remote = origin
 13 | 	merge = refs/heads/main
--------------------------------------------------------------------------------

/.git/description:
--------------------------------------------------------------------------------
  1 | Unnamed repository; edit this file 'description' to name the repository.
--------------------------------------------------------------------------------

/.git/hooks/applypatch-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to check the commit log message taken by
  4 | # applypatch from an e-mail message.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an
  7 | # appropriate message if it wants to stop the commit.  The hook is
  8 | # allowed to edit the commit message file.
  9 | #
 10 | # To enable this hook, rename this file to "applypatch-msg".
 11 | 
 12 | . git-sh-setup
 13 | commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
 14 | test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
 15 | :
--------------------------------------------------------------------------------

/.git/hooks/commit-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to check the commit log message.
  4 | # Called by "git commit" with one argument, the name of the file
  5 | # that has the commit message.  The hook should exit with non-zero
  6 | # status after issuing an appropriate message if it wants to stop the
  7 | # commit.  The hook is allowed to edit the commit message file.
  8 | #
  9 | # To enable this hook, rename this file to "commit-msg".
 10 | 
 11 | # Uncomment the below to add a Signed-off-by line to the message.
 12 | # Doing this in a hook is a bad idea in general, but the prepare-commit-msg
 13 | # hook is more suited to it.
 14 | #
 15 | # SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
 16 | # grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
 17 | 
 18 | # This example catches duplicate Signed-off-by lines.
 19 | 
 20 | test "" = "$(grep '^Signed-off-by: ' "$1" |
 21 | 	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
 22 | 	echo >&2 Duplicate Signed-off-by lines.
 23 | 	exit 1
 24 | }
--------------------------------------------------------------------------------

/.git/hooks/fsmonitor-watchman.sample:
--------------------------------------------------------------------------------
  1 | #!/usr/bin/perl
  2 | 
  3 | use strict;
  4 | use warnings;
  5 | use IPC::Open2;
  6 | 
  7 | # An example hook script to integrate Watchman
  8 | # (https://facebook.github.io/watchman/) with git to speed up detecting
  9 | # new and modified files.
 10 | #
 11 | # The hook is passed a version (currently 2) and last update token
 12 | # formatted as a string and outputs to stdout a new update token and
 13 | # all files that have been modified since the update token. Paths must
 14 | # be relative to the root of the working tree and separated by a single NUL.
 15 | #
 16 | # To enable this hook, rename this file to "query-watchman" and set
 17 | # 'git config core.fsmonitor .git/hooks/query-watchman'
 18 | #
 19 | my ($version, $last_update_token) = @ARGV;
 20 | 
 21 | # Uncomment for debugging
 22 | # print STDERR "$0 $version $last_update_token\n";
 23 | 
 24 | # Check the hook interface version
 25 | if ($version ne 2) {
 26 | 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 27 | 	    "Falling back to scanning...\n";
 28 | }
 29 | 
 30 | my $git_work_tree = get_working_dir();
 31 | 
 32 | my $retry = 1;
 33 | 
 34 | my $json_pkg;
 35 | eval {
 36 | 	require JSON::XS;
 37 | 	$json_pkg = "JSON::XS";
 38 | 	1;
 39 | } or do {
 40 | 	require JSON::PP;
 41 | 	$json_pkg = "JSON::PP";
 42 | };
 43 | 
 44 | launch_watchman();
 45 | 
 46 | sub launch_watchman {
 47 | 	my $o = watchman_query();
 48 | 	if (is_work_tree_watched($o)) {
 49 | 		output_result($o->{clock}, @{$o->{files}});
 50 | 	}
 51 | }
 52 | 
 53 | sub output_result {
 54 | 	my ($clockid, @files) = @_;
 55 | 
 56 | 	# Uncomment for debugging watchman output
 57 | 	# open (my $fh, ">", ".git/watchman-output.out");
 58 | 	# binmode $fh, ":utf8";
 59 | 	# print $fh "$clockid\n@files\n";
 60 | 	# close $fh;
 61 | 
 62 | 	binmode STDOUT, ":utf8";
 63 | 	print $clockid;
 64 | 	print "\0";
 65 | 	local $, = "\0";
 66 | 	print @files;
 67 | }
 68 | 
 69 | sub watchman_clock {
 70 | 	my $response = qx/watchman clock "$git_work_tree"/;
 71 | 	die "Failed to get clock id on '$git_work_tree'.\n" .
 72 | 		"Falling back to scanning...\n" if $? != 0;
 73 | 
 74 | 	return $json_pkg->new->utf8->decode($response);
 75 | }
 76 | 
 77 | sub watchman_query {
 78 | 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
 79 | 	or die "open2() failed: $!\n" .
 80 | 	"Falling back to scanning...\n";
 81 | 
 82 | 	# In the query expression below we're asking for names of files that
 83 | 	# changed since $last_update_token but not from the .git folder.
 84 | 	#
 85 | 	# To accomplish this, we're using the "since" generator to use the
 86 | 	# recency index to select candidate nodes and "fields" to limit the
 87 | 	# output to file names only. Then we're using the "expression" term to
 88 | 	# further constrain the results.
 89 | 	my $last_update_line = "";
 90 | 	if (substr($last_update_token, 0, 1) eq "c") {
 91 | 		$last_update_token = "\"$last_update_token\"";
 92 | 		$last_update_line = qq[\n"since": $last_update_token,];
 93 | 	}
 94 | 	my $query = <<"	END";
 95 | 		["query", "$git_work_tree", {$last_update_line
 96 | 			"fields": ["name"],
 97 | 			"expression": ["not", ["dirname", ".git"]]
 98 | 		}]
 99 | 	END
100 | 
101 | 	# Uncomment for debugging the watchman query
102 | 	# open (my $fh, ">", ".git/watchman-query.json");
103 | 	# print $fh $query;
104 | 	# close $fh;
105 | 
106 | 	print CHLD_IN $query;
107 | 	close CHLD_IN;
108 | 	my $response = do {local $/; <CHLD_OUT>};
109 | 
110 | 	# Uncomment for debugging the watch response
111 | 	# open ($fh, ">", ".git/watchman-response.json");
112 | 	# print $fh $response;
113 | 	# close $fh;
114 | 
115 | 	die "Watchman: command returned no output.\n" .
116 | 	"Falling back to scanning...\n" if $response eq "";
117 | 	die "Watchman: command returned invalid output: $response\n" .
118 | 	"Falling back to scanning...\n" unless $response =~ /^\{/;
119 | 
120 | 	return $json_pkg->new->utf8->decode($response);
121 | }
122 | 
123 | sub is_work_tree_watched {
124 | 	my ($output) = @_;
125 | 	my $error = $output->{error};
126 | 	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
127 | 		$retry--;
128 | 		my $response = qx/watchman watch "$git_work_tree"/;
129 | 		die "Failed to make watchman watch '$git_work_tree'.\n" .
130 | 		    "Falling back to scanning...\n" if $? != 0;
131 | 		$output = $json_pkg->new->utf8->decode($response);
132 | 		$error = $output->{error};
133 | 		die "Watchman: $error.\n" .
134 | 		"Falling back to scanning...\n" if $error;
135 | 
136 | 		# Uncomment for debugging watchman output
137 | 		# open (my $fh, ">", ".git/watchman-output.out");
138 | 		# close $fh;
139 | 
140 | 		# Watchman will always return all files on the first query so
141 | 		# return the fast "everything is dirty" flag to git and do the
142 | 		# Watchman query just to get it over with now so we won't pay
143 | 		# the cost in git to look up each individual file.
144 | 		my $o = watchman_clock();
145 | 		$error = $output->{error};
146 | 
147 | 		die "Watchman: $error.\n" .
148 | 		"Falling back to scanning...\n" if $error;
149 | 
150 | 		output_result($o->{clock}, ("/"));
151 | 		$last_update_token = $o->{clock};
152 | 
153 | 		eval { launch_watchman() };
154 | 		return 0;
155 | 	}
156 | 
157 | 	die "Watchman: $error.\n" .
158 | 	"Falling back to scanning...\n" if $error;
159 | 
160 | 	return 1;
161 | }
162 | 
163 | sub get_working_dir {
164 | 	my $working_dir;
165 | 	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
166 | 		$working_dir = Win32::GetCwd();
167 | 		$working_dir =~ tr/\\/\//;
168 | 	} else {
169 | 		require Cwd;
170 | 		$working_dir = Cwd::cwd();
171 | 	}
172 | 
173 | 	return $working_dir;
174 | }
--------------------------------------------------------------------------------

/.git/hooks/post-update.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to prepare a packed repository for use over
  4 | # dumb transports.
  5 | #
  6 | # To enable this hook, rename this file to "post-update".
  7 | 
  8 | exec git update-server-info
--------------------------------------------------------------------------------

/.git/hooks/pre-applypatch.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed
  4 | # by applypatch from an e-mail message.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an
  7 | # appropriate message if it wants to stop the commit.
  8 | #
  9 | # To enable this hook, rename this file to "pre-applypatch".
 10 | 
 11 | . git-sh-setup
 12 | precommit="$(git rev-parse --git-path hooks/pre-commit)"
 13 | test -x "$precommit" && exec "$precommit" ${1+"$@"}
 14 | :
--------------------------------------------------------------------------------

/.git/hooks/pre-commit.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed.
  4 | # Called by "git commit" with no arguments.  The hook should
  5 | # exit with non-zero status after issuing an appropriate message if
  6 | # it wants to stop the commit.
  7 | #
  8 | # To enable this hook, rename this file to "pre-commit".
  9 | 
 10 | if git rev-parse --verify HEAD >/dev/null 2>&1
 11 | then
 12 | 	against=HEAD
 13 | else
 14 | 	# Initial commit: diff against an empty tree object
 15 | 	against=$(git hash-object -t tree /dev/null)
 16 | fi
 17 | 
 18 | # If you want to allow non-ASCII filenames set this variable to true.
 19 | allownonascii=$(git config --type=bool hooks.allownonascii)
 20 | 
 21 | # Redirect output to stderr.
 22 | exec 1>&2
 23 | 
 24 | # Cross platform projects tend to avoid non-ASCII filenames; prevent
 25 | # them from being added to the repository. We exploit the fact that the
 26 | # printable range starts at the space character and ends with tilde.
 27 | if [ "$allownonascii" != "true" ] &&
 28 | 	# Note that the use of brackets around a tr range is ok here, (it's
 29 | 	# even required, for portability to Solaris 10's /usr/bin/tr), since
 30 | 	# the square bracket bytes happen to fall in the designated range.
 31 | 	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
 32 | 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
 33 | then
 34 | 	cat <<\EOF
 35 | Error: Attempt to add a non-ASCII file name.
 36 | 
 37 | This can cause problems if you want to work with people on other platforms.
 38 | 
 39 | To be portable it is advisable to rename the file.
 40 | 
 41 | If you know what you are doing you can disable this check using:
 42 | 
 43 |   git config hooks.allownonascii true
 44 | EOF
 45 | 	exit 1
 46 | fi
 47 | 
 48 | # If there are whitespace errors, print the offending file names and fail.
 49 | exec git diff-index --check --cached $against --
--------------------------------------------------------------------------------

/.git/hooks/pre-merge-commit.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed.
  4 | # Called by "git merge" with no arguments.  The hook should
  5 | # exit with non-zero status after issuing an appropriate message to
  6 | # stderr if it wants to stop the merge commit.
  7 | #
  8 | # To enable this hook, rename this file to "pre-merge-commit".
  9 | 
 10 | . git-sh-setup
 11 | test -x "$GIT_DIR/hooks/pre-commit" &&
 12 |         exec "$GIT_DIR/hooks/pre-commit"
 13 | :
--------------------------------------------------------------------------------

/.git/hooks/pre-push.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to verify what is about to be pushed.  Called by "git
  4 | # push" after it has checked the remote status, but before anything has been
  5 | # pushed.  If this script exits with a non-zero status nothing will be pushed.
  6 | #
  7 | # This hook is called with the following parameters:
  8 | #
  9 | # $1 -- Name of the remote to which the push is being done
 10 | # $2 -- URL to which the push is being done
 11 | #
 12 | # If pushing without using a named remote those arguments will be equal.
 13 | #
 14 | # Information about the commits which are being pushed is supplied as lines to
 15 | # the standard input in the form:
 16 | #
 17 | #   <local ref> <local oid> <remote ref> <remote oid>
 18 | #
 19 | # This sample shows how to prevent push of commits where the log message starts
 20 | # with "WIP" (work in progress).
 21 | 
 22 | remote="$1"
 23 | url="$2"
 24 | 
 25 | zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 26 | 
 27 | while read local_ref local_oid remote_ref remote_oid
 28 | do
 29 | 	if test "$local_oid" = "$zero"
 30 | 	then
 31 | 		# Handle delete
 32 | 		:
 33 | 	else
 34 | 		if test "$remote_oid" = "$zero"
 35 | 		then
 36 | 			# New branch, examine all commits
 37 | 			range="$local_oid"
 38 | 		else
 39 | 			# Update to existing branch, examine new commits
 40 | 			range="$remote_oid..$local_oid"
 41 | 		fi
 42 | 
 43 | 		# Check for WIP commit
 44 | 		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
 45 | 		if test -n "$commit"
 46 | 		then
 47 | 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 48 | 			exit 1
 49 | 		fi
 50 | 	fi
 51 | done
 52 | 
 53 | exit 0
--------------------------------------------------------------------------------

/.git/hooks/pre-rebase.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # Copyright (c) 2006, 2008 Junio C Hamano
  4 | #
  5 | # The "pre-rebase" hook is run just before "git rebase" starts doing
  6 | # its job, and can prevent the command from running by exiting with
  7 | # non-zero status.
  8 | #
  9 | # The hook is called with the following parameters:
 10 | #
 11 | # $1 -- the upstream the series was forked from.
 12 | # $2 -- the branch being rebased (or empty when rebasing the current branch).
 13 | #
 14 | # This sample shows how to prevent topic branches that are already
 15 | # merged to 'next' branch from getting rebased, because allowing it
 16 | # would result in rebasing already published history.
 17 | 
 18 | publish=next
 19 | basebranch="$1"
 20 | if test "$#" = 2
 21 | then
 22 | 	topic="refs/heads/$2"
 23 | else
 24 | 	topic=`git symbolic-ref HEAD` ||
 25 | 	exit 0 ;# we do not interrupt rebasing detached HEAD
 26 | fi
 27 | 
 28 | case "$topic" in
 29 | refs/heads/??/*)
 30 | 	;;
 31 | *)
 32 | 	exit 0 ;# we do not interrupt others.
 33 | 	;;
 34 | esac
 35 | 
 36 | # Now we are dealing with a topic branch being rebased
 37 | # on top of master.  Is it OK to rebase it?
 38 | 
 39 | # Does the topic really exist?
 40 | git show-ref -q "$topic" || {
 41 | 	echo >&2 "No such branch $topic"
 42 | 	exit 1
 43 | }
 44 | 
 45 | # Is topic fully merged to master?
 46 | not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
 47 | if test -z "$not_in_master"
 48 | then
 49 | 	echo >&2 "$topic is fully merged to master; better remove it."
 50 | 	exit 1 ;# we could allow it, but there is no point.
 51 | fi
 52 | 
 53 | # Is topic ever merged to next?  If so you should not be rebasing it.
 54 | only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
 55 | only_next_2=`git rev-list ^master           ${publish} | sort`
 56 | if test "$only_next_1" = "$only_next_2"
 57 | then
 58 | 	not_in_topic=`git rev-list "^$topic" master`
 59 | 	if test -z "$not_in_topic"
 60 | 	then
 61 | 		echo >&2 "$topic is already up to date with master"
 62 | 		exit 1 ;# we could allow it, but there is no point.
 63 | 	else
 64 | 		exit 0
 65 | 	fi
 66 | else
 67 | 	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
 68 | 	/usr/bin/perl -e '
 69 | 		my $topic = $ARGV[0];
 70 | 		my $msg = "* $topic has commits already merged to public branch:\n";
 71 | 		my (%not_in_next) = map {
 72 | 			/^([0-9a-f]+) /;
 73 | 			($1 => 1);
 74 | 		} split(/\n/, $ARGV[1]);
 75 | 		for my $elem (map {
 76 | 				/^([0-9a-f]+) (.*)$/;
 77 | 				[$1 => $2];
 78 | 			} split(/\n/, $ARGV[2])) {
 79 | 			if (!exists $not_in_next{$elem->[0]}) {
 80 | 				if ($msg) {
 81 | 					print STDERR $msg;
 82 | 					undef $msg;
 83 | 				}
 84 | 				print STDERR " $elem->[1]\n";
 85 | 			}
 86 | 		}
 87 | 	' "$topic" "$not_in_next" "$not_in_master"
 88 | 	exit 1
 89 | fi
 90 | 
 91 | <<\DOC_END
 92 | 
 93 | This sample hook safeguards topic branches that have been
 94 | published from being rewound.
 95 | 
 96 | The workflow assumed here is:
 97 | 
 98 |  * Once a topic branch forks from "master", "master" is never
 99 |    merged into it again (either directly or indirectly).
100 | 
101 |  * Once a topic branch is fully cooked and merged into "master",
102 |    it is deleted.  If you need to build on top of it to correct
103 |    earlier mistakes, a new topic branch is created by forking at
104 |    the tip of the "master".  This is not strictly necessary, but
105 |    it makes it easier to keep your history simple.
106 | 
107 |  * Whenever you need to test or publish your changes to topic
108 |    branches, merge them into "next" branch.
109 | 
110 | The script, being an example, hardcodes the publish branch name
111 | to be "next", but it is trivial to make it configurable via
112 | $GIT_DIR/config mechanism.
113 | 
114 | With this workflow, you would want to know:
115 | 
116 | (1) ... if a topic branch has ever been merged to "next".  Young
117 |     topic branches can have stupid mistakes you would rather
118 |     clean up before publishing, and things that have not been
119 |     merged into other branches can be easily rebased without
120 |     affecting other people.  But once it is published, you would
121 |     not want to rewind it.
122 | 
123 | (2) ... if a topic branch has been fully merged to "master".
124 |     Then you can delete it.  More importantly, you should not
125 |     build on top of it -- other people may already want to
126 |     change things related to the topic as patches against your
127 |     "master", so if you need further changes, it is better to
128 |     fork the topic (perhaps with the same name) afresh from the
129 |     tip of "master".
130 | 
131 | Let's look at this example:
132 | 
133 | 		   o---o---o---o---o---o---o---o---o---o "next"
134 | 		  /       /           /           /
135 | 		 /   a---a---b A     /           /
136 | 		/   /               /           /
137 | 	       /   /   c---c---c---c B         /
138 | 	      /   /   /             \         /
139 | 	     /   /   /   b---b C     \       /
140 | 	    /   /   /   /             \     /
141 |     ---o---o---o---o---o---o---o---o---o---o---o "master"
142 | 
143 | 
144 | A, B and C are topic branches.
145 | 
146 |  * A has one fix since it was merged up to "next".
147 | 
148 |  * B has finished.  It has been fully merged up to "master" and "next",
149 |    and is ready to be deleted.
150 | 
151 |  * C has not merged to "next" at all.
152 | 
153 | We would want to allow C to be rebased, refuse A, and encourage
154 | B to be deleted.
155 | 
156 | To compute (1):
157 | 
158 | 	git rev-list ^master ^topic next
159 | 	git rev-list ^master        next
160 | 
161 | 	if these match, topic has not merged in next at all.
162 | 
163 | To compute (2):
164 | 
165 | 	git rev-list master..topic
166 | 
167 | 	if this is empty, it is fully merged to "master".
168 | 
169 | DOC_END
--------------------------------------------------------------------------------

/.git/hooks/pre-receive.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to make use of push options.
  4 | # The example simply echoes all push options that start with 'echoback='
  5 | # and rejects all pushes when the "reject" push option is used.
  6 | #
  7 | # To enable this hook, rename this file to "pre-receive".
  8 | 
  9 | if test -n "$GIT_PUSH_OPTION_COUNT"
 10 | then
 11 | 	i=0
 12 | 	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
 13 | 	do
 14 | 		eval "value=\$GIT_PUSH_OPTION_$i"
 15 | 		case "$value" in
 16 | 		echoback=*)
 17 | 			echo "echo from the pre-receive-hook: ${value#*=}" >&2
 18 | 			;;
 19 | 		reject)
 20 | 			exit 1
 21 | 		esac
 22 | 		i=$((i + 1))
 23 | 	done
 24 | fi
--------------------------------------------------------------------------------

/.git/hooks/prepare-commit-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to prepare the commit log message.
  4 | # Called by "git commit" with the name of the file that has the
  5 | # commit message, followed by the description of the commit
  6 | # message's source.  The hook's purpose is to edit the commit
  7 | # message file.  If the hook fails with a non-zero status,
  8 | # the commit is aborted.
  9 | #
 10 | # To enable this hook, rename this file to "prepare-commit-msg".
 11 | 
 12 | # This hook includes three examples. The first one removes the
 13 | # "# Please enter the commit message..." help message.
 14 | #
 15 | # The second includes the output of "git diff --name-status -r"
 16 | # into the message, just before the "git status" output.  It is
 17 | # commented because it doesn't cope with --amend or with squashed
 18 | # commits.
 19 | #
 20 | # The third example adds a Signed-off-by line to the message, that can
 21 | # still be edited.  This is rarely a good idea.
 22 | 
 23 | COMMIT_MSG_FILE=$1
 24 | COMMIT_SOURCE=$2
 25 | SHA1=$3
 26 | 
 27 | /usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
 28 | 
 29 | # case "$COMMIT_SOURCE,$SHA1" in
 30 | #  ,|template,)
 31 | #    /usr/bin/perl -i.bak -pe '
 32 | #       print "\n" . `git diff --cached --name-status -r`
 33 | # 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
 34 | #  *) ;;
 35 | # esac
 36 | 
 37 | # SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
 38 | # git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
 39 | # if test -z "$COMMIT_SOURCE"
 40 | # then
 41 | #   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
 42 | # fi
--------------------------------------------------------------------------------

/.git/hooks/push-to-checkout.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to update a checked-out tree on a git push.
  4 | #
  5 | # This hook is invoked by git-receive-pack(1) when it reacts to git
  6 | # push and updates reference(s) in its repository, and when the push
  7 | # tries to update the branch that is currently checked out and the
  8 | # receive.denyCurrentBranch configuration variable is set to
  9 | # updateInstead.
 10 | #
 11 | # By default, such a push is refused if the working tree and the index
 12 | # of the remote repository has any difference from the currently
 13 | # checked out commit; when both the working tree and the index match
 14 | # the current commit, they are updated to match the newly pushed tip
 15 | # of the branch. This hook is to be used to override the default
 16 | # behaviour; however the code below reimplements the default behaviour
 17 | # as a starting point for convenient modification.
 18 | #
 19 | # The hook receives the commit with which the tip of the current
 20 | # branch is going to be updated:
 21 | commit=$1
 22 | 
 23 | # It can exit with a non-zero status to refuse the push (when it does
 24 | # so, it must not modify the index or the working tree).
 25 | die () {
 26 | 	echo >&2 "$*"
 27 | 	exit 1
 28 | }
 29 | 
 30 | # Or it can make any necessary changes to the working tree and to the
 31 | # index to bring them to the desired state when the tip of the current
 32 | # branch is updated to the new commit, and exit with a zero status.
 33 | #
 34 | # For example, the hook can simply run git read-tree -u -m HEAD "$1"
 35 | # in order to emulate git fetch that is run in the reverse direction
 36 | # with git push, as the two-tree form of git read-tree -u -m is
 37 | # essentially the same as git switch or git checkout that switches
 38 | # branches while keeping the local changes in the working tree that do
 39 | # not interfere with the difference between the branches.
 40 | 
 41 | # The below is a more-or-less exact translation to shell of the C code
 42 | # for the default behaviour for git's push-to-checkout hook defined in
 43 | # the push_to_deploy() function in builtin/receive-pack.c.
 44 | #
 45 | # Note that the hook will be executed from the repository directory,
 46 | # not from the working tree, so if you want to perform operations on
 47 | # the working tree, you will have to adapt your code accordingly, e.g.
 48 | # by adding "cd .." or using relative paths.
 49 | 
 50 | if ! git update-index -q --ignore-submodules --refresh
 51 | then
 52 | 	die "Up-to-date check failed"
 53 | fi
 54 | 
 55 | if ! git diff-files --quiet --ignore-submodules --
 56 | then
 57 | 	die "Working directory has unstaged changes"
 58 | fi
 59 | 
 60 | # This is a rough translation of:
 61 | #
 62 | #   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
 63 | if git cat-file -e HEAD 2>/dev/null
 64 | then
 65 | 	head=HEAD
 66 | else
 67 | 	head=$(git hash-object -t tree --stdin </dev/null)
 68 | fi
 69 | 
 70 | if ! git diff-index --quiet --cached --ignore-submodules $head --
 71 | then
 72 | 	die "Working directory has staged changes"
 73 | fi
 74 | 
 75 | if ! git read-tree -u -m "$commit"
 76 | then
 77 | 	die "Could not update working tree to new HEAD"
 78 | fi
--------------------------------------------------------------------------------

/.git/hooks/sendemail-validate.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to validate a patch (and/or patch series) before
  4 | # sending it via email.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an appropriate
  7 | # message if it wants to prevent the email(s) from being sent.
  8 | #
  9 | # To enable this hook, rename this file to "sendemail-validate".
 10 | #
 11 | # By default, it will only check that the patch(es) can be applied on top of
 12 | # the default upstream branch without conflicts in a secondary worktree. After
 13 | # validation (successful or not) of the last patch of a series, the worktree
 14 | # will be deleted.
 15 | #
 16 | # The following config variables can be set to change the default remote and
 17 | # remote ref that are used to apply the patches against:
 18 | #
 19 | #   sendemail.validateRemote (default: origin)
 20 | #   sendemail.validateRemoteRef (default: HEAD)
 21 | #
 22 | # Replace the TODO placeholders with appropriate checks according to your
 23 | # needs.
 24 | 
 25 | validate_cover_letter () {
 26 | 	file="$1"
 27 | 	# TODO: Replace with appropriate checks (e.g. spell checking).
 28 | 	true
 29 | }
 30 | 
 31 | validate_patch () {
 32 | 	file="$1"
 33 | 	# Ensure that the patch applies without conflicts.
 34 | 	git am -3 "$file" || return
 35 | 	# TODO: Replace with appropriate checks for this patch
 36 | 	# (e.g. checkpatch.pl).
 37 | 	true
 38 | }
 39 | 
 40 | validate_series () {
 41 | 	# TODO: Replace with appropriate checks for the whole series
 42 | 	# (e.g. quick build, coding style checks, etc.).
 43 | 	true
 44 | }
 45 | 
 46 | # main -------------------------------------------------------------------------
 47 | 
 48 | if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
 49 | then
 50 | 	remote=$(git config --default origin --get sendemail.validateRemote) &&
 51 | 	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
 52 | 	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
 53 | 	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
 54 | 	git config --replace-all sendemail.validateWorktree "$worktree"
 55 | else
 56 | 	worktree=$(git config --get sendemail.validateWorktree)
 57 | fi || {
 58 | 	echo "sendemail-validate: error: failed to prepare worktree" >&2
 59 | 	exit 1
 60 | }
 61 | 
 62 | unset GIT_DIR GIT_WORK_TREE
 63 | cd "$worktree" &&
 64 | 
 65 | if grep -q "^diff --git " "$1"
 66 | then
 67 | 	validate_patch "$1"
 68 | else
 69 | 	validate_cover_letter "$1"
 70 | fi &&
 71 | 
 72 | if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
 73 | then
 74 | 	git config --unset-all sendemail.validateWorktree &&
 75 | 	trap 'git worktree remove -ff "$worktree"' EXIT &&
 76 | 	validate_series
 77 | fi
--------------------------------------------------------------------------------

/.git/hooks/update.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to block unannotated tags from entering.
  4 | # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
  5 | #
  6 | # To enable this hook, rename this file to "update".
  7 | #
  8 | # Config
  9 | # ------
 10 | # hooks.allowunannotated
 11 | #   This boolean sets whether unannotated tags will be allowed into the
 12 | #   repository.  By default they won't be.
 13 | # hooks.allowdeletetag
 14 | #   This boolean sets whether deleting tags will be allowed in the
 15 | #   repository.  By default they won't be.
 16 | # hooks.allowmodifytag
 17 | #   This boolean sets whether a tag may be modified after creation. By default
 18 | #   it won't be.
 19 | # hooks.allowdeletebranch
 20 | #   This boolean sets whether deleting branches will be allowed in the
 21 | #   repository.  By default they won't be.
 22 | # hooks.denycreatebranch
 23 | #   This boolean sets whether remotely creating branches will be denied
 24 | #   in the repository.  By default this is allowed.
 25 | #
 26 | 
 27 | # --- Command line
 28 | refname="$1"
 29 | oldrev="$2"
 30 | newrev="$3"
 31 | 
 32 | # --- Safety check
 33 | if [ -z "$GIT_DIR" ]; then
 34 | 	echo "Don't run this script from the command line." >&2
 35 | 	echo " (if you want, you could supply GIT_DIR then run" >&2
 36 | 	echo "  $0 <ref> <oldrev> <newrev>)" >&2
 37 | 	exit 1
 38 | fi
 39 | 
 40 | if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
 41 | 	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
 42 | 	exit 1
 43 | fi
 44 | 
 45 | # --- Config
 46 | allowunannotated=$(git config --type=bool hooks.allowunannotated)
 47 | allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
 48 | denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
 49 | allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
 50 | allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
 51 | 
 52 | # check for no description
 53 | projectdesc=$(sed -e '1q' "$GIT_DIR/description")
 54 | case "$projectdesc" in
 55 | "Unnamed repository"* | "")
 56 | 	echo "*** Project description file hasn't been set" >&2
 57 | 	exit 1
 58 | 	;;
 59 | esac
 60 | 
 61 | # --- Check types
 62 | # if $newrev is 0000...0000, it's a commit to delete a ref.
 63 | zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 64 | if [ "$newrev" = "$zero" ]; then
 65 | 	newrev_type=delete
 66 | else
 67 | 	newrev_type=$(git cat-file -t $newrev)
 68 | fi
 69 | 
 70 | case "$refname","$newrev_type" in
 71 | 	refs/tags/*,commit)
 72 | 		# un-annotated tag
 73 | 		short_refname=${refname##refs/tags/}
 74 | 		if [ "$allowunannotated" != "true" ]; then
 75 | 			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
 76 | 			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
 77 | 			exit 1
 78 | 		fi
 79 | 		;;
 80 | 	refs/tags/*,delete)
 81 | 		# delete tag
 82 | 		if [ "$allowdeletetag" != "true" ]; then
 83 | 			echo "*** Deleting a tag is not allowed in this repository" >&2
 84 | 			exit 1
 85 | 		fi
 86 | 		;;
 87 | 	refs/tags/*,tag)
 88 | 		# annotated tag
 89 | 		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
 90 | 		then
 91 | 			echo "*** Tag '$refname' already exists." >&2
 92 | 			echo "*** Modifying a tag is not allowed in this repository." >&2
 93 | 			exit 1
 94 | 		fi
 95 | 		;;
 96 | 	refs/heads/*,commit)
 97 | 		# branch
 98 | 		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
 99 | 			echo "*** Creating a branch is not allowed in this repository" >&2
100 | 			exit 1
101 | 		fi
102 | 		;;
103 | 	refs/heads/*,delete)
104 | 		# delete branch
105 | 		if [ "$allowdeletebranch" != "true" ]; then
106 | 			echo "*** Deleting a branch is not allowed in this repository" >&2
107 | 			exit 1
108 | 		fi
109 | 		;;
110 | 	refs/remotes/*,commit)
111 | 		# tracking branch
112 | 		;;
113 | 	refs/remotes/*,delete)
114 | 		# delete tracking branch
115 | 		if [ "$allowdeletebranch" != "true" ]; then
116 | 			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
117 | 			exit 1
118 | 		fi
119 | 		;;
120 | 	*)
121 | 		# Anything else (is there anything else?)
122 | 		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
123 | 		exit 1
124 | 		;;
125 | esac
126 | 
127 | # --- Finished
128 | exit 0
--------------------------------------------------------------------------------

/.git/index:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x88 in position 15: invalid start byte
--------------------------------------------------------------------------------

/.git/info/exclude:
--------------------------------------------------------------------------------
  1 | # git ls-files --others --exclude-from=.git/info/exclude
  2 | # Lines that start with '#' are comments.
  3 | # For a project mostly in C, the following would be a good set of
  4 | # exclude patterns (uncomment them if you want to use them):
  5 | # *.[oa]
  6 | # *~
--------------------------------------------------------------------------------

/.git/logs/HEAD:
--------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000 bcf33e52fb9c60ad7ae47525953f8c6992a23177 neromehiro <neromehiro1014@gmail.com> 1762695952 +0900	commit (initial): fix1
  2 | bcf33e52fb9c60ad7ae47525953f8c6992a23177 fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f neromehiro <neromehiro1014@gmail.com> 1762695979 +0900	commit: aaa
  3 | fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f 72d1a9aa21705c959c769fc65fe9f988e4da33e8 neromehiro <neromehiro1014@gmail.com> 1762749159 +0900	commit: aa
--------------------------------------------------------------------------------

/.git/logs/refs/heads/main:
--------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000 bcf33e52fb9c60ad7ae47525953f8c6992a23177 neromehiro <neromehiro1014@gmail.com> 1762695952 +0900	commit (initial): fix1
  2 | bcf33e52fb9c60ad7ae47525953f8c6992a23177 fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f neromehiro <neromehiro1014@gmail.com> 1762695979 +0900	commit: aaa
  3 | fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f 72d1a9aa21705c959c769fc65fe9f988e4da33e8 neromehiro <neromehiro1014@gmail.com> 1762749159 +0900	commit: aa
--------------------------------------------------------------------------------

/.git/logs/refs/remotes/origin/HEAD:
--------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000 fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f neromehiro <neromehiro1014@gmail.com> 1762696073 +0900	fetch
--------------------------------------------------------------------------------

/.git/logs/refs/remotes/origin/main:
--------------------------------------------------------------------------------
  1 | 0000000000000000000000000000000000000000 bcf33e52fb9c60ad7ae47525953f8c6992a23177 neromehiro <neromehiro1014@gmail.com> 1762695953 +0900	update by push
  2 | bcf33e52fb9c60ad7ae47525953f8c6992a23177 fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f neromehiro <neromehiro1014@gmail.com> 1762695981 +0900	update by push
  3 | fc57ae68afe3d2cb1d6f16533bd9572004d3ad3f 72d1a9aa21705c959c769fc65fe9f988e4da33e8 neromehiro <neromehiro1014@gmail.com> 1762749160 +0900	update by push
--------------------------------------------------------------------------------

/.git/objects/01/5837d0ff3d18ed177f9d5df39dab59572ca415:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/03/e6cbd2406e2d22b04e7978fb2fd2d343088901:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x95 in position 3: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/05/d0bdc4f75ca967a3cc187ff189aadc421c7e52:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/11/c5fac6e3ce968601bb5dd10ec288c47b592bd0:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xdd in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/1c/67622415ca970174756d073dec2c32388d08ef:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xba in position 3: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/1e/a3c8aedcd85d30269796c73674d5d475d78d1b:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/20/e5a0441c1c791e02bdc619e5806f3d9726c26f:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xfe in position 9: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/26/0aba78d99b7e2dbf8b00162cb4e8f3010a9593:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/2d/fa1c912b8267384fa355ad1cf0706b13afaa83:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/36/675741f3c7aab767f1ac5032910c7ee8e10969:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x8f in position 5: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/42/ee0d8f358818329978cfc044ea12ac90855fe8:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xee in position 9: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/45/7c8da82df47325e9863e101739c02b9100af78:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/4a/6fbd674f4f0b158cdfb275c3a982d4ae5ca17e:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xce in position 20: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/4b/8f40a60d4e4e3b4a719519eb479b362f7f0b5e:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/5a/dce0110c00f110d36fa5a0205b16037dee86fb:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/66/64bb5da5239771ca92c8b6d6750e4534be098d:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/72/d1a9aa21705c959c769fc65fe9f988e4da33e8:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/77/49e7eb686d7b8955accba7ec9f2bfbcdb85d60:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb5 in position 8: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/79/4cf2c89c0bb2df1a260a29b5fe4d0dbbf15ac3:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/7d/560eb18afa3b6bb6bbf168d7770e9d88d11ea3:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/87/c28a5b2ac7de7e98f08592c39f786ac13a0681:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/8b/f586fb3806ac8a37e5f6d4c2d465742e50b5f2:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb0 in position 9: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/8f/f1a0e14f2e63d49243b139f7d71345349ff90f:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/95/9fd2d375c79fa98eb68f0d2792ebc6e5ac828d:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd4 in position 6: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/96/b8a8dd25009c9e316f2f8498ff5acd85d81a20:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/a4/da20efc5fc6fbe7027b294fa01f773fb82a36a:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/a6/d68c0e4103d391e32713639d8e501a888128c7:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/a8/98e37c09880cf003b3fd2bbbeeccdae1e3e299:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xcd in position 19: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/ac/2ef6f21be55b4e17b48957666b71d234f21d57:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/b9/27dd3af83cd39cb1f064eded21cf5516b19467:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/bc/f33e52fb9c60ad7ae47525953f8c6992a23177:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/cf/ce8c056bf03ebefb49f0837040d85c612a7c82:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xd5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/d0/460fa7c47fc8900cc5fbbb1c403e28022e9c00:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/d2/af0588a68874cc574efc39de8c0eb0521e5800:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb7 in position 8: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/de/1054dc96b2e3cf36944c66ef4384481e2ce7ab:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/ed/b2f90917b261d30d64db467c3fda99c0d7f5e3:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/f1/fb0a3024b914afae97744ab02b921d33f120a1:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xb6 in position 8: invalid start byte
--------------------------------------------------------------------------------

/.git/objects/f4/b06d428bd01775d7b7d0a17e3dfc15387bd3fb:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/fb/5decda8deb4d800e24a5afc99b4827c2c91fa6:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/fc/23e86284e9d2e9673e091c9106829a75b3d891:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0xc7 in position 7: invalid continuation byte
--------------------------------------------------------------------------------

/.git/objects/fc/57ae68afe3d2cb1d6f16533bd9572004d3ad3f:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte
--------------------------------------------------------------------------------

/.git/refs/heads/main:
--------------------------------------------------------------------------------
  1 | 72d1a9aa21705c959c769fc65fe9f988e4da33e8
--------------------------------------------------------------------------------

/.git/refs/remotes/origin/HEAD:
--------------------------------------------------------------------------------
  1 | ref: refs/remotes/origin/main
--------------------------------------------------------------------------------

/.git/refs/remotes/origin/main:
--------------------------------------------------------------------------------
  1 | 72d1a9aa21705c959c769fc65fe9f988e4da33e8
--------------------------------------------------------------------------------

/README.md:
--------------------------------------------------------------------------------
  1 | # AutoForm (test autofill)
  2 | 
  3 |  `test`Chrome
  4 | 
  5 | ## 
  6 | 1. `manifest.json`  `content.js` 
  7 | 2. Chrome  `chrome://extensions` 
  8 | 3.  ON
  9 | 4.  
 10 | 5. 
 11 | 6. text/textarea/email/tel/url
 12 | 
 13 | ### 
 14 | -  ****
 15 | - cURL 
 16 | - 
 17 | - SPA 3
 18 | - 
 19 | - 
 20 | 
 21 | ##  JSON 
 22 | `sample_code/sample_data/apodori_ai.json`  XPath 
 23 | 
 24 | 1.  AutoForm 
 25 | 2. JSON  `.json` 
 26 | 3.  JSON  XPath/
 27 |    - `match_condition`  `click` 
 28 |    - input/textarea/select/contentEditable `input/change` 
 29 | 4. /
 30 | 
 31 | JSON 
 32 | 
 33 | iframe  JSON 
--------------------------------------------------------------------------------

/aimsales_logo.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/background.js:
--------------------------------------------------------------------------------
  1 | const FORM_ITEMS_ENDPOINT =
  2 |   "https://autoform-chrome-extention-server-csasaeerewb7b9ga.japaneast-01.azurewebsites.net/chrome_extension/form_items";
  3 | const RECORDS_ENDPOINT =
  4 |   "https://autoform-chrome-extention-server-csasaeerewb7b9ga.japaneast-01.azurewebsites.net/chrome_extension/records";
  5 | const ENV_UPLOAD_ENDPOINT =
  6 |   "https://autoform-chrome-extention-server-csasaeerewb7b9ga.japaneast-01.azurewebsites.net/chrome_extension/env";
  7 | const SEND_STORAGE_KEY = "autoformSendContent";
  8 | const STORAGE_SYNC_KEYS = [
  9 |   "autoformEnabled",
 10 |   "autoformAutoRunOnOpen",
 11 |   "autoformShowFloatingButton",
 12 |   "autoformShowAutoButton"
 13 | ];
 14 | const STORAGE_LOCAL_KEYS = null;
 15 | const INSTALL_ID_STORAGE_KEY = "autoformInstallId";
 16 | const MAX_CURL_LOGS = 20;
 17 | const ANALYSIS_TTL_MS = 2 * 60 * 1000;
 18 | const PENDING_TTL_MS = 2 * 60 * 1000;
 19 | const TEMPLATE_ENV_TTL_MS = 5 * 60 * 1000;
 20 | const BADGE_BG_COLOR = "#2563eb";
 21 | const BADGE_TEXT_COLOR = "#ffffff";
 22 | 
 23 | let lastApiLog = null;
 24 | let lastUserInfoSnapshot = null;
 25 | let trackedEmail = null;
 26 | 
 27 | const detectedCurlLogs = [];
 28 | const pendingCurlRequests = new Map();
 29 | const seenCurlSignatures = new Set();
 30 | const lastHtmlByTab = new Map();
 31 | const tabLastCommittedUrls = new Map();
 32 | const tabInputCounts = new Map();
 33 | const frameInputCounts = new Map();
 34 | const templateBrowserEnvByTab = new Map();
 35 | 
 36 | bootstrapTabUrls();
 37 | setBadgeBackgroundDefaults();
 38 | refreshTrackedEmail();
 39 | 
 40 | function resolveTrackedEmailCandidate(value) {
 41 |   if (typeof value !== "string") return null;
 42 |   const trimmed = value.trim();
 43 |   if (!trimmed || !trimmed.includes("@")) {
 44 |     return null;
 45 |   }
 46 |   return trimmed;
 47 | }
 48 | 
 49 | function recordTabUrl(tabId, url) {
 50 |   if (typeof tabId !== "number") return;
 51 |   if (typeof url === "string" && url.trim()) {
 52 |     tabLastCommittedUrls.set(tabId, url);
 53 |   } else {
 54 |     tabLastCommittedUrls.delete(tabId);
 55 |   }
 56 | }
 57 | 
 58 | function isChromeExtensionUrl(url) {
 59 |   return typeof url === "string" && url.startsWith("chrome-extension://");
 60 | }
 61 | 
 62 | function bootstrapTabUrls() {
 63 |   if (!chrome?.tabs?.query) return;
 64 |   chrome.tabs.query({}, (tabs) => {
 65 |     if (!Array.isArray(tabs)) return;
 66 |     tabs.forEach((tab) => {
 67 |       if (typeof tab?.id === "number" && typeof tab?.url === "string") {
 68 |         recordTabUrl(tab.id, tab.url);
 69 |       }
 70 |     });
 71 |   });
 72 | }
 73 | 
 74 | function setBadgeBackgroundDefaults() {
 75 |   if (chrome?.action?.setBadgeBackgroundColor) {
 76 |     chrome.action.setBadgeBackgroundColor({ color: BADGE_BG_COLOR });
 77 |   }
 78 |   if (chrome?.action?.setBadgeTextColor) {
 79 |     chrome.action.setBadgeTextColor({ color: BADGE_TEXT_COLOR });
 80 |   }
 81 | }
 82 | 
 83 | function applyBadgeText(tabId, count) {
 84 |   if (!chrome?.action?.setBadgeText || typeof tabId !== "number") return;
 85 |   let text = "";
 86 |   if (typeof count === "number" && count > 0) {
 87 |     const raw = count > 999 ? "999+" : String(count);
 88 |     text = raw.length === 1 ? ` ${raw}` : raw;
 89 |   }
 90 |   chrome.action.setBadgeText({ tabId, text });
 91 | }
 92 | 
 93 | function updateBadgeCount(tabId, count) {
 94 |   if (typeof tabId !== "number" || tabId < 0) return;
 95 |   if (typeof count === "number" && count > 0) {
 96 |     tabInputCounts.set(tabId, count);
 97 |   } else {
 98 |     tabInputCounts.delete(tabId);
 99 |   }
100 |   applyBadgeText(tabId, count);
101 | }
102 | 
103 | function recordFrameInputCount(tabId, frameId, count) {
104 |   if (typeof tabId !== "number" || tabId < 0 || typeof frameId !== "number") return;
105 |   const normalized = Number.isFinite(count) ? Math.max(0, Math.floor(count)) : 0;
106 |   let frames = frameInputCounts.get(tabId);
107 |   if (!frames) {
108 |     frames = new Map();
109 |     frameInputCounts.set(tabId, frames);
110 |   }
111 |   if (normalized === 0) {
112 |     frames.delete(frameId);
113 |     if (frames.size === 0) {
114 |       frameInputCounts.delete(tabId);
115 |     }
116 |   } else {
117 |     frames.set(frameId, normalized);
118 |   }
119 |   let total = 0;
120 |   frameInputCounts.get(tabId)?.forEach((value) => {
121 |     total += value;
122 |   });
123 |   updateBadgeCount(tabId, total);
124 | }
125 | 
126 | function collectBrowserEnvFromTab(tabId) {
127 |   return new Promise((resolve) => {
128 |     if (!chrome?.tabs?.sendMessage || typeof tabId !== "number") {
129 |       resolve(null);
130 |       return;
131 |     }
132 |     let settled = false;
133 |     const timer = setTimeout(() => {
134 |       if (!settled) {
135 |         settled = true;
136 |         resolve(null);
137 |       }
138 |     }, 400);
139 |     try {
140 |       chrome.tabs.sendMessage(tabId, { type: "autoform_collect_browser_env" }, (response) => {
141 |         if (settled) {
142 |           return;
143 |         }
144 |         settled = true;
145 |         clearTimeout(timer);
146 |         if (chrome.runtime?.lastError) {
147 |           resolve(null);
148 |           return;
149 |         }
150 |         resolve(response?.env || null);
151 |       });
152 |     } catch (_) {
153 |       if (!settled) {
154 |         settled = true;
155 |         clearTimeout(timer);
156 |         resolve(null);
157 |       }
158 |     }
159 |   });
160 | }
161 | 
162 | function getTemplateBrowserEnv(tabId) {
163 |   if (typeof tabId !== "number") return null;
164 |   const entry = templateBrowserEnvByTab.get(tabId);
165 |   if (!entry) return null;
166 |   if (Date.now() - entry.timestamp > TEMPLATE_ENV_TTL_MS) {
167 |     templateBrowserEnvByTab.delete(tabId);
168 |     return null;
169 |   }
170 |   return entry.data || null;
171 | }
172 | 
173 | async function resolveBrowserEnvForTab(tabId) {
174 |   if (typeof tabId !== "number") return null;
175 |   const templateEnv = getTemplateBrowserEnv(tabId);
176 |   if (templateEnv) {
177 |     return templateEnv;
178 |   }
179 |   return collectBrowserEnvFromTab(tabId);
180 | }
181 | 
182 | function nowMs() {
183 |   const hasPerformance = typeof performance !== "undefined" && typeof performance.now === "function";
184 |   return hasPerformance ? performance.now() : Date.now();
185 | }
186 | 
187 | function escapeSingleQuotes(str) {
188 |   return String(str ?? "").replace(/'/g, "'\"'\"'");
189 | }
190 | 
191 | function extractRequestBody(details) {
192 |   const requestBody = details?.requestBody;
193 |   if (!requestBody) return "";
194 |   if (requestBody.formData) {
195 |     const params = new URLSearchParams();
196 |     for (const [key, value] of Object.entries(requestBody.formData)) {
197 |       if (Array.isArray(value)) {
198 |         value.forEach((v) => params.append(key, v));
199 |       } else if (value != null) {
200 |         params.append(key, value);
201 |       }
202 |     }
203 |     return params.toString();
204 |   }
205 |   if (Array.isArray(requestBody.raw) && requestBody.raw.length) {
206 |     try {
207 |       const decoder = new TextDecoder("utf-8");
208 |       return requestBody.raw
209 |         .filter((part) => part?.bytes)
210 |         .map((part) => decoder.decode(part.bytes))
211 |         .join("");
212 |     } catch (_) {
213 |       return "";
214 |     }
215 |   }
216 |   return "";
217 | }
218 | 
219 | function buildCurlCommand(entry) {
220 |   const method = (entry.method || "GET").toUpperCase();
221 |   const headerLines = (entry.headers || [])
222 |     .filter((h) => h && typeof h.name === "string" && typeof h.value === "string")
223 |     .map((h) => `  -H '${h.name}: ${escapeSingleQuotes(h.value)}'`)
224 |     .join(" \\\n");
225 | 
226 |   let cmd = `curl '${entry.url}'`;
227 |   if (method !== "GET") {
228 |     cmd += ` \\\n  -X ${method}`;
229 |   }
230 |   if (headerLines) {
231 |     cmd += ` \\\n${headerLines}`;
232 |   }
233 |   if (entry.body) {
234 |     cmd += ` \\\n  --data-raw '${escapeSingleQuotes(entry.body)}'`;
235 |   }
236 |   return cmd;
237 | }
238 | 
239 | function buildLogSignature(entry) {
240 |   const unique = entry.requestId || `${Date.now()}-${Math.random()}`;
241 |   return `${(entry.method || "GET").toUpperCase()}::${entry.url}::${entry.body || ""}::${unique}`;
242 | }
243 | 
244 | function bodyContainsEmail(body, preferredEmail) {
245 |   if (typeof body !== "string" || !body) {
246 |     return false;
247 |   }
248 |   const normalizedBody = body.toLowerCase();
249 |   if (preferredEmail) {
250 |     const email = preferredEmail.toLowerCase();
251 |     if (normalizedBody.includes(email)) {
252 |       return true;
253 |     }
254 |     const encoded = encodeURIComponent(preferredEmail).toLowerCase();
255 |     if (normalizedBody.includes(encoded)) {
256 |       return true;
257 |     }
258 |   }
259 |   return /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i.test(body);
260 | }
261 | 
262 | async function sha256Hex(input) {
263 |   try {
264 |     if (!globalThis.crypto?.subtle) {
265 |       throw new Error("subtle_unavailable");
266 |     }
267 |     const data = new TextEncoder().encode(String(input));
268 |     const hashBuffer = await crypto.subtle.digest("SHA-256", data);
269 |     return Array.from(new Uint8Array(hashBuffer))
270 |       .map((b) => b.toString(16).padStart(2, "0"))
271 |       .join("");
272 |   } catch (_) {
273 |     let hash = 0;
274 |     const str = String(input || "");
275 |     for (let i = 0; i < str.length; i += 1) {
276 |       hash = (hash << 5) - hash + str.charCodeAt(i);
277 |       hash |= 0;
278 |     }
279 |     return Math.abs(hash).toString(16);
280 |   }
281 | }
282 | 
283 | function createHtmlPreview(html) {
284 |   if (typeof html !== "string") {
285 |     return { preview: "", length: 0, truncated: false };
286 |   }
287 |   const limit = 2000;
288 |   if (html.length <= limit) {
289 |     return { preview: html, length: html.length, truncated: false };
290 |   }
291 |   return {
292 |     preview: `${html.slice(0, limit)}...`,
293 |     length: html.length,
294 |     truncated: true
295 |   };
296 | }
297 | 
298 | async function getStorageSnapshot(areaName, keys = null) {
299 |   const storageArea = chrome?.storage?.[areaName];
300 |   if (!storageArea) {
301 |     return { available: false, data: null, keys: [], bytesInUse: null, error: "unavailable" };
302 |   }
303 |   const { value, error } = await new Promise((resolve) => {
304 |     try {
305 |       storageArea.get(keys, (items) => {
306 |         if (chrome.runtime?.lastError) {
307 |           resolve({ value: {}, error: chrome.runtime.lastError.message });
308 |           return;
309 |         }
310 |         resolve({ value: items || {}, error: null });
311 |       });
312 |     } catch (err) {
313 |       resolve({ value: {}, error: err?.message || "unknown_error" });
314 |     }
315 |   });
316 |   const bytesInUse =
317 |     typeof storageArea.getBytesInUse === "function"
318 |       ? await new Promise((resolve) => {
319 |           try {
320 |             storageArea.getBytesInUse(keys, (bytes) => {
321 |               if (chrome.runtime?.lastError) {
322 |                 resolve(null);
323 |                 return;
324 |               }
325 |               resolve(typeof bytes === "number" ? bytes : null);
326 |             });
327 |           } catch (_) {
328 |             resolve(null);
329 |           }
330 |         })
331 |       : null;
332 |   const dataObject = value && typeof value === "object" ? value : {};
333 |   return {
334 |     available: true,
335 |     data: dataObject,
336 |     keys: Object.keys(dataObject),
337 |     bytesInUse,
338 |     error
339 |   };
340 | }
341 | 
342 | function getPlatformInfoSafe() {
343 |   return new Promise((resolve) => {
344 |     if (!chrome?.runtime?.getPlatformInfo) {
345 |       resolve(null);
346 |       return;
347 |     }
348 |     try {
349 |       chrome.runtime.getPlatformInfo((info) => {
350 |         if (chrome.runtime?.lastError) {
351 |           resolve({ error: chrome.runtime.lastError.message });
352 |           return;
353 |         }
354 |         resolve(info || null);
355 |       });
356 |     } catch (err) {
357 |       resolve({ error: err?.message || "platform_info_failed" });
358 |     }
359 |   });
360 | }
361 | 
362 | function getBrowserInfoSafe() {
363 |   return new Promise((resolve) => {
364 |     if (!chrome?.runtime?.getBrowserInfo) {
365 |       resolve(null);
366 |       return;
367 |     }
368 |     try {
369 |       chrome.runtime.getBrowserInfo((info) => {
370 |         if (chrome.runtime?.lastError) {
371 |           resolve({ error: chrome.runtime.lastError.message });
372 |           return;
373 |         }
374 |         resolve(info || null);
375 |       });
376 |     } catch (err) {
377 |       resolve({ error: err?.message || "browser_info_failed" });
378 |     }
379 |   });
380 | }
381 | 
382 | function getPermissionsInfoSafe() {
383 |   return new Promise((resolve) => {
384 |     if (!chrome?.permissions?.getAll) {
385 |       resolve(null);
386 |       return;
387 |     }
388 |     try {
389 |       chrome.permissions.getAll((info) => {
390 |         if (chrome.runtime?.lastError) {
391 |           resolve({ error: chrome.runtime.lastError.message });
392 |           return;
393 |         }
394 |         resolve(info || null);
395 |       });
396 |     } catch (err) {
397 |       resolve({ error: err?.message || "permissions_failed" });
398 |     }
399 |   });
400 | }
401 | 
402 | function getProfileInfoSafe() {
403 |   return new Promise((resolve) => {
404 |     if (!chrome?.identity?.getProfileUserInfo) {
405 |       resolve(null);
406 |       return;
407 |     }
408 |     try {
409 |       chrome.identity.getProfileUserInfo({ accountStatus: "ANY" }, (info) => {
410 |         if (chrome.runtime?.lastError) {
411 |           resolve({ error: chrome.runtime.lastError.message });
412 |           return;
413 |         }
414 |         resolve(info || null);
415 |       });
416 |     } catch (err) {
417 |       resolve({ error: err?.message || "profile_failed" });
418 |     }
419 |   });
420 | }
421 | 
422 | function sanitizeManifest(manifest) {
423 |   if (!manifest || typeof manifest !== "object") return null;
424 |   const {
425 |     name,
426 |     short_name: shortName,
427 |     description,
428 |     version,
429 |     version_name: versionName,
430 |     manifest_version: manifestVersion,
431 |     permissions,
432 |     host_permissions: hostPermissions,
433 |     optional_host_permissions: optionalHostPermissions
434 |   } = manifest;
435 |   return {
436 |     name,
437 |     shortName,
438 |     description,
439 |     version,
440 |     versionName,
441 |     manifestVersion,
442 |     permissions,
443 |     hostPermissions,
444 |     optionalHostPermissions
445 |   };
446 | }
447 | 
448 | async function gatherUserInfoSnapshot(reason = null) {
449 |   const manifest = chrome?.runtime?.getManifest ? chrome.runtime.getManifest() : null;
450 |   const platformPromise = getPlatformInfoSafe();
451 |   const [platformInfo, browserInfo, permissions, storageLocal, storageSync, profile] = await Promise.all([
452 |     platformPromise,
453 |     getBrowserInfoSafe(),
454 |     getPermissionsInfoSafe(),
455 |     getStorageSnapshot("local", STORAGE_LOCAL_KEYS),
456 |     getStorageSnapshot("sync", STORAGE_SYNC_KEYS),
457 |     getProfileInfoSafe()
458 |   ]);
459 |   let systemSignals = null;
460 |   try {
461 |     systemSignals = await gatherSystemSignals({ nonce: reason || "user_info_snapshot", platformInfo });
462 |   } catch (_) {
463 |     systemSignals = null;
464 |   }
465 |   return {
466 |     timestamp: Date.now(),
467 |     reason,
468 |     runtime: {
469 |       id: chrome?.runtime?.id || null,
470 |       manifest: sanitizeManifest(manifest)
471 |     },
472 |     platformInfo,
473 |     browserInfo,
474 |     permissions,
475 |     storage: {
476 |       local: storageLocal,
477 |       sync: storageSync
478 |     },
479 |     profile,
480 |     systemSignals
481 |   };
482 | }
483 | 
484 | function getSystemCpuInfo() {
485 |   return new Promise((resolve) => {
486 |     if (!chrome?.system?.cpu?.getInfo) {
487 |       resolve(null);
488 |       return;
489 |     }
490 |     try {
491 |       chrome.system.cpu.getInfo((info) => {
492 |         if (chrome.runtime?.lastError) {
493 |           resolve(null);
494 |           return;
495 |         }
496 |         resolve(info || null);
497 |       });
498 |     } catch (_) {
499 |       resolve(null);
500 |     }
501 |   });
502 | }
503 | 
504 | function getSystemMemoryInfo() {
505 |   return new Promise((resolve) => {
506 |     if (!chrome?.system?.memory?.getInfo) {
507 |       resolve(null);
508 |       return;
509 |     }
510 |     try {
511 |       chrome.system.memory.getInfo((info) => {
512 |         if (chrome.runtime?.lastError) {
513 |           resolve(null);
514 |           return;
515 |         }
516 |         resolve(info || null);
517 |       });
518 |     } catch (_) {
519 |       resolve(null);
520 |     }
521 |   });
522 | }
523 | 
524 | function getSystemDisplayInfo() {
525 |   return new Promise((resolve) => {
526 |     if (!chrome?.system?.display?.getInfo) {
527 |       resolve(null);
528 |       return;
529 |     }
530 |     try {
531 |       chrome.system.display.getInfo((info) => {
532 |         if (chrome.runtime?.lastError) {
533 |           resolve(null);
534 |           return;
535 |         }
536 |         resolve(Array.isArray(info) ? info : null);
537 |       });
538 |     } catch (_) {
539 |       resolve(null);
540 |     }
541 |   });
542 | }
543 | 
544 | function getSystemStorageInfo() {
545 |   return new Promise((resolve) => {
546 |     if (!chrome?.system?.storage?.getInfo) {
547 |       resolve(null);
548 |       return;
549 |     }
550 |     try {
551 |       chrome.system.storage.getInfo((info) => {
552 |         if (chrome.runtime?.lastError) {
553 |           resolve(null);
554 |           return;
555 |         }
556 |         resolve(Array.isArray(info) ? info : null);
557 |       });
558 |     } catch (_) {
559 |       resolve(null);
560 |     }
561 |   });
562 | }
563 | 
564 | function hasEnterpriseHardwareInfo() {
565 |   return new Promise((resolve) => {
566 |     const api = chrome?.enterprise?.hardwarePlatform?.getHardwareInfo;
567 |     if (!api) {
568 |       resolve(false);
569 |       return;
570 |     }
571 |     try {
572 |       api.call(chrome.enterprise.hardwarePlatform, () => {
573 |         if (chrome.runtime?.lastError) {
574 |           resolve(false);
575 |           return;
576 |         }
577 |         resolve(true);
578 |       });
579 |     } catch (_) {
580 |       resolve(false);
581 |     }
582 |   });
583 | }
584 | 
585 | function hasEnterpriseDeviceAttributes() {
586 |   return new Promise((resolve) => {
587 |     const api = chrome?.enterprise?.deviceAttributes?.getDeviceSerialNumber;
588 |     if (!api) {
589 |       resolve(false);
590 |       return;
591 |     }
592 |     try {
593 |       api.call(chrome.enterprise.deviceAttributes, () => {
594 |         if (chrome.runtime?.lastError) {
595 |           resolve(false);
596 |           return;
597 |         }
598 |         resolve(true);
599 |       });
600 |     } catch (_) {
601 |       resolve(false);
602 |     }
603 |   });
604 | }
605 | 
606 | async function getOrCreateInstallId() {
607 |   if (!chrome?.storage?.local) {
608 |     return null;
609 |   }
610 |   return new Promise((resolve) => {
611 |     try {
612 |       chrome.storage.local.get(INSTALL_ID_STORAGE_KEY, (res) => {
613 |         if (chrome.runtime?.lastError) {
614 |           resolve(null);
615 |           return;
616 |         }
617 |         let existing = res?.[INSTALL_ID_STORAGE_KEY];
618 |         if (typeof existing === "string" && existing.trim()) {
619 |           resolve(existing.trim());
620 |           return;
621 |         }
622 |         const generated =
623 |           (typeof crypto?.randomUUID === "function" && crypto.randomUUID()) ||
624 |           `${Date.now()}-${Math.random().toString(16).slice(2)}`;
625 |         chrome.storage.local.set({ [INSTALL_ID_STORAGE_KEY]: generated }, () => {
626 |           resolve(generated);
627 |         });
628 |       });
629 |     } catch (_) {
630 |       resolve(null);
631 |     }
632 |   });
633 | }
634 | 
635 | async function gatherSystemSignals({ nonce = "", platformInfo: presetPlatform = null } = {}) {
636 |   const platformPromise = presetPlatform ? Promise.resolve(presetPlatform) : getPlatformInfoSafe();
637 |   const [platformInfo, cpu, memory, displays, storageDevices, enterpriseHardware, enterpriseDeviceAttr] = await Promise.all([
638 |     platformPromise,
639 |     getSystemCpuInfo(),
640 |     getSystemMemoryInfo(),
641 |     getSystemDisplayInfo(),
642 |     getSystemStorageInfo(),
643 |     hasEnterpriseHardwareInfo(),
644 |     hasEnterpriseDeviceAttributes()
645 |   ]);
646 |   const manifest = chrome?.runtime?.getManifest ? chrome.runtime.getManifest() : null;
647 |   const extVersion = manifest?.version || null;
648 |   const installId = await getOrCreateInstallId();
649 |   const today = new Date().toISOString().slice(0, 10);
650 |   const baseString = `${installId || "anonymous"}|${nonce || ""}|${today}`;
651 |   const installEphemeral = await sha256Hex(baseString);
652 |   return {
653 |     extVersion,
654 |     platform: platformInfo,
655 |     cpu,
656 |     memory,
657 |     displays,
658 |     storage: storageDevices,
659 |     enterprise: {
660 |       hasHardwareInfo: !!enterpriseHardware,
661 |       hasDeviceAttr: !!enterpriseDeviceAttr
662 |     },
663 |     installEphemeral
664 |   };
665 | }
666 | 
667 | function refreshTrackedEmail() {
668 |   if (!chrome?.storage?.local) {
669 |     trackedEmail = null;
670 |     return;
671 |   }
672 |   chrome.storage.local.get(SEND_STORAGE_KEY, (res) => {
673 |     if (chrome.runtime?.lastError) {
674 |       return;
675 |     }
676 |     const storedEmail = res?.[SEND_STORAGE_KEY]?.email;
677 |     trackedEmail = resolveTrackedEmailCandidate(storedEmail);
678 |   });
679 | }
680 | 
681 | if (chrome?.storage?.onChanged) {
682 |   chrome.storage.onChanged.addListener((changes, area) => {
683 |     if (area === "local" && changes[SEND_STORAGE_KEY]) {
684 |       const newValue = changes[SEND_STORAGE_KEY]?.newValue;
685 |       trackedEmail = resolveTrackedEmailCandidate(newValue?.email);
686 |     }
687 |   });
688 | }
689 | 
690 | async function fetchFormItems(payload, originTabId) {
691 |   const { html, sendRecord, pageUrl } = payload || {};
692 |   if (!html || !sendRecord) {
693 |     throw new Error("html  send_record ");
694 |   }
695 | 
696 |   let userInfoDetails = null;
697 |   try {
698 |     userInfoDetails = await gatherUserInfoSnapshot("api_request");
699 |     lastUserInfoSnapshot = userInfoDetails;
700 |   } catch (err) {
701 |     userInfoDetails = lastUserInfoSnapshot || null;
702 |   }
703 |   if (typeof originTabId === "number") {
704 |     try {
705 |       const browserEnv = await resolveBrowserEnvForTab(originTabId);
706 |       if (browserEnv) {
707 |         userInfoDetails = userInfoDetails || {};
708 |         userInfoDetails.browser_env = browserEnv;
709 |       }
710 |     } catch (_) {
711 |       // ignore env collection errors
712 |     }
713 |   }
714 | 
715 |   const analysisId =
716 |     (globalThis.crypto?.randomUUID && crypto.randomUUID()) ||
717 |     `${Date.now()}-${Math.random().toString(16).slice(2)}`;
718 |   const htmlSha256 = await sha256Hex(html).catch(() => null);
719 |   const htmlPreview = createHtmlPreview(html);
720 | 
721 |   const startedAt = nowMs();
722 |   let response;
723 |   let data = null;
724 |   const requestPayload = {
725 |     analysis_id: analysisId || undefined,
726 |     html_sha256: htmlSha256 || undefined,
727 |     send_record: sendRecord,
728 |     html,
729 |     page_url: pageUrl || undefined,
730 |     user_info: userInfoDetails || {}
731 |   };
732 |   try {
733 |     response = await fetch(FORM_ITEMS_ENDPOINT, {
734 |       method: "POST",
735 |       headers: {
736 |         accept: "application/json",
737 |         "Content-Type": "application/json"
738 |       },
739 |       body: JSON.stringify(requestPayload)
740 |     });
741 |   } catch (err) {
742 |     throw new Error(`API: ${err?.message || err}`);
743 |   }
744 | 
745 |   const text = await response.text().catch(() => "");
746 |   try {
747 |     data = text ? JSON.parse(text) : {};
748 |   } catch (_) {
749 |     throw new Error("API");
750 |   }
751 | 
752 |   const items = Array.isArray(data?.form_items)
753 |     ? data.form_items
754 |     : Array.isArray(data)
755 |       ? data
756 |       : [];
757 |   const durationMs = nowMs() - startedAt;
758 | 
759 |   lastApiLog = {
760 |     timestamp: Date.now(),
761 |     request: {
762 |       analysis_id: analysisId,
763 |       html_sha256: htmlSha256,
764 |       send_record: sendRecord,
765 |       html_preview: htmlPreview.preview,
766 |       html_length: htmlPreview.length,
767 |       html_truncated: htmlPreview.truncated,
768 |       page_url: pageUrl || undefined,
769 |       user_info: requestPayload.user_info
770 |     },
771 |     response: {
772 |       status: response.status,
773 |       ok: response.ok,
774 |       body: data,
775 |       duration_ms: durationMs
776 |     },
777 |     items_count: items.length
778 |   };
779 | 
780 |   const htmlLogId = typeof data?.html_log_id === "string" && data.html_log_id.trim() ? data.html_log_id.trim() : null;
781 | 
782 |   if (typeof originTabId === "number") {
783 |     lastHtmlByTab.set(originTabId, {
784 |       analysisId,
785 |       pageUrl: pageUrl || undefined,
786 |       htmlSha256,
787 |       htmlLength: html.length || 0,
788 |       requestedAt: Date.now(),
789 |       htmlLogId
790 |     });
791 |   }
792 | 
793 |   if (data?.env_token && originTabId != null) {
794 |     try {
795 |       const envToken = data.env_token;
796 |       const analysisFromServer = data?.analysis_id || analysisId;
797 |       const runtimeInfo = userInfoDetails || (await gatherUserInfoSnapshot("env_upload"));
798 |       const browserEnv = await collectBrowserEnvFromTab(originTabId);
799 |       const mergedInfo = Object.assign({}, runtimeInfo || {}, browserEnv ? { browser_env: browserEnv } : {});
800 |       await fetch(ENV_UPLOAD_ENDPOINT, {
801 |         method: "POST",
802 |         headers: {
803 |           "Content-Type": "application/json"
804 |         },
805 |         body: JSON.stringify({
806 |           analysis_id: analysisFromServer,
807 |           token: envToken,
808 |           page_url: pageUrl || null,
809 |           html_sha256: htmlSha256 || null,
810 |           user_info: mergedInfo || {}
811 |         })
812 |       }).catch(() => {});
813 |     } catch (err) {
814 |       console.warn("[AutoForm] env upload failed", err);
815 |     }
816 |   }
817 | 
818 |   return { items, durationMs };
819 | }
820 | 
821 | function handleBeforeRequest(details) {
822 |   if (!details || !details.requestId || typeof details.tabId !== "number") {
823 |     return;
824 |   }
825 |   const method = (details.method || "GET").toUpperCase();
826 |   if (method !== "POST") {
827 |     return;
828 |   }
829 |   const body = extractRequestBody(details);
830 |   const sourceUrl =
831 |     tabLastCommittedUrls.get(details.tabId) || details.documentUrl || details.initiator || null;
832 |   pendingCurlRequests.set(details.requestId, {
833 |     requestId: details.requestId,
834 |     method,
835 |     url: details.url,
836 |     body,
837 |     headers: [],
838 |     tabId: details.tabId,
839 |     sourceUrl,
840 |     startedAt: Date.now()
841 |   });
842 | }
843 | 
844 | function handleBeforeSendHeaders(details) {
845 |   if (!details?.requestId) return;
846 |   const entry = pendingCurlRequests.get(details.requestId);
847 |   if (!entry) return;
848 |   entry.headers = details.requestHeaders || [];
849 | }
850 | 
851 | async function sendRecordForCurl(entry, curl) {
852 |   const analysis = lastHtmlByTab.get(entry.tabId);
853 |   if (!analysis?.htmlLogId) {
854 |     return;
855 |   }
856 |   let userInfo = null;
857 |   try {
858 |     userInfo = await gatherUserInfoSnapshot("curl_record");
859 |     lastUserInfoSnapshot = userInfo;
860 |   } catch (_) {
861 |     userInfo = lastUserInfoSnapshot || null;
862 |   }
863 |   if (typeof entry.tabId === "number") {
864 |     try {
865 |       const browserEnv = await resolveBrowserEnvForTab(entry.tabId);
866 |       if (browserEnv) {
867 |         userInfo = userInfo || {};
868 |         userInfo.browser_env = browserEnv;
869 |       }
870 |     } catch (_) {
871 |       // ignore env collection errors
872 |     }
873 |   }
874 |   const payload = {
875 |     analysis_id: analysis?.analysisId || undefined,
876 |     html_log_id: analysis?.htmlLogId || undefined,
877 |     site_url:
878 |       tabLastCommittedUrls.get(entry.tabId) || analysis?.pageUrl || entry.sourceUrl || undefined,
879 |     curl: {
880 |       raw: curl,
881 |       method: entry.method,
882 |       url: entry.url,
883 |       status_code: typeof entry.statusCode === "number" ? entry.statusCode : undefined
884 |     },
885 |     html_request: analysis
886 |       ? {
887 |           analysis_id: analysis.analysisId,
888 |           page_url: analysis.pageUrl,
889 |           html_sha256: analysis.htmlSha256,
890 |           html_length: analysis.htmlLength,
891 |           requested_at: analysis.requestedAt
892 |         }
893 |       : undefined,
894 |     user_info: userInfo || {}
895 |   };
896 |   try {
897 |     await fetch(RECORDS_ENDPOINT, {
898 |       method: "POST",
899 |       headers: {
900 |         accept: "application/json",
901 |         "Content-Type": "application/json"
902 |       },
903 |       body: JSON.stringify(payload),
904 |       keepalive: true
905 |     });
906 |   } catch (_) {
907 |     // network errors are ignored for now
908 |   }
909 | }
910 | 
911 | function finalizeCurlLog(requestId, extra = {}) {
912 |   const entry = pendingCurlRequests.get(requestId);
913 |   if (!entry) return;
914 |   pendingCurlRequests.delete(requestId);
915 |   entry.statusCode = typeof extra.statusCode === "number" ? extra.statusCode : null;
916 |   entry.error = extra.error || null;
917 | 
918 |   if (isChromeExtensionUrl(entry.sourceUrl)) {
919 |     return;
920 |   }
921 | 
922 |   if (!bodyContainsEmail(entry.body, trackedEmail)) {
923 |     return;
924 |   }
925 | 
926 |   const curl = buildCurlCommand(entry);
927 |   const signature = buildLogSignature(entry);
928 |   if (seenCurlSignatures.has(signature)) {
929 |     return;
930 |   }
931 |   seenCurlSignatures.add(signature);
932 | 
933 |   sendRecordForCurl(entry, curl);
934 | 
935 |   detectedCurlLogs.unshift({
936 |     timestamp: Date.now(),
937 |     url: entry.url,
938 |     method: entry.method,
939 |     statusCode: entry.statusCode,
940 |     sourceUrl: entry.sourceUrl || null,
941 |     curl,
942 |     analysisId: lastHtmlByTab.get(entry.tabId)?.analysisId || null,
943 |     tabId: entry.tabId
944 |   });
945 |   if (detectedCurlLogs.length > MAX_CURL_LOGS) {
946 |     detectedCurlLogs.length = MAX_CURL_LOGS;
947 |   }
948 | }
949 | 
950 | if (chrome?.webRequest) {
951 |   const filter = { urls: ["<all_urls>"] };
952 |   chrome.webRequest.onBeforeRequest.addListener(handleBeforeRequest, filter, ["requestBody"]);
953 |   chrome.webRequest.onBeforeSendHeaders.addListener(handleBeforeSendHeaders, filter, ["requestHeaders", "extraHeaders"]);
954 |   chrome.webRequest.onCompleted.addListener((details) => {
955 |     finalizeCurlLog(details.requestId, { statusCode: details.statusCode });
956 |   }, filter);
957 |   chrome.webRequest.onErrorOccurred.addListener((details) => {
958 |     finalizeCurlLog(details.requestId, { error: details.error || "request_error" });
959 |   }, filter);
960 | }
961 | 
962 | if (chrome?.webNavigation?.onCommitted) {
963 |   chrome.webNavigation.onCommitted.addListener((details) => {
964 |     if (details.frameId === 0) {
965 |       recordTabUrl(details.tabId, details.url);
966 |       frameInputCounts.delete(details.tabId);
967 |       updateBadgeCount(details.tabId, 0);
968 |       templateBrowserEnvByTab.delete(details.tabId);
969 |     }
970 |   });
971 | }
972 | 
973 | if (chrome?.tabs?.onRemoved) {
974 |   chrome.tabs.onRemoved.addListener((tabId) => {
975 |     recordTabUrl(tabId, null);
976 |     lastHtmlByTab.delete(tabId);
977 |     frameInputCounts.delete(tabId);
978 |     updateBadgeCount(tabId, 0);
979 |     templateBrowserEnvByTab.delete(tabId);
980 |   });
981 | }
982 | 
983 | chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
984 |   if (!message?.type) {
985 |     return;
986 |   }
987 | 
988 |   if (message.type === "autoform_fetch_form_items") {
989 |     const originTabId = sender?.tab?.id;
990 |     fetchFormItems(message.payload, originTabId)
991 |       .then((result) => sendResponse({ items: result.items, durationMs: result.durationMs }))
992 |       .catch((err) => sendResponse({ error: err?.message || "API" }));
993 |     return true;
994 |   }
995 | 
996 |   if (message.type === "autoform_get_last_api_log") {
997 |     sendResponse({ log: lastApiLog });
998 |     return;
999 |   }
1000 | 
1001 |   if (message.type === "autoform_get_detected_curl_logs") {
1002 |     const requestedTabId = typeof message.tabId === "number" ? message.tabId : null;
1003 |     const logs =
1004 |       requestedTabId == null
1005 |         ? detectedCurlLogs.slice()
1006 |         : detectedCurlLogs.filter((log) => log?.tabId === requestedTabId);
1007 |     sendResponse({ logs });
1008 |     return;
1009 |   }
1010 | 
1011 |   if (message.type === "autoform_report_input_count") {
1012 |     const tabId = sender?.tab?.id;
1013 |     const frameId = typeof sender?.frameId === "number" ? sender.frameId : 0;
1014 |     if (typeof tabId === "number") {
1015 |       const count = Number(message?.payload?.count);
1016 |       recordFrameInputCount(tabId, frameId, count);
1017 |     }
1018 |     sendResponse?.({ ok: true });
1019 |     return;
1020 |   }
1021 | 
1022 |   if (message.type === "autoform_page_env_report") {
1023 |     const tabId = sender?.tab?.id;
1024 |     if (typeof tabId === "number" && message?.payload) {
1025 |       templateBrowserEnvByTab.set(tabId, {
1026 |         data: message.payload,
1027 |         pageUrl: typeof message.pageUrl === "string" ? message.pageUrl : null,
1028 |         timestamp: Date.now()
1029 |       });
1030 |     }
1031 |     sendResponse?.({ ok: true });
1032 |     return;
1033 |   }
1034 | 
1035 |   if (message.type === "autoform_get_user_info_details") {
1036 |     const forceRefresh = message?.refresh === true || !lastUserInfoSnapshot;
1037 |     if (!forceRefresh && lastUserInfoSnapshot) {
1038 |       sendResponse({ userInfo: lastUserInfoSnapshot });
1039 |       return;
1040 |     }
1041 |     gatherUserInfoSnapshot(message?.reason || null)
1042 |       .then((snapshot) => {
1043 |         lastUserInfoSnapshot = snapshot;
1044 |         sendResponse({ userInfo: snapshot });
1045 |       })
1046 |       .catch((err) => {
1047 |         sendResponse({ error: err?.message || "", userInfo: lastUserInfoSnapshot || null });
1048 |       });
1049 |     return true;
1050 |   }
1051 | 
1052 |   if (message.type === "get_system_signals") {
1053 |     const nonce = typeof message.nonce === "string" ? message.nonce : "";
1054 |     gatherSystemSignals({ nonce })
1055 |       .then((signals) => sendResponse(signals || null))
1056 |       .catch((err) => sendResponse({ error: err?.message || "system_signals_failed" }));
1057 |     return true;
1058 |   }
1059 | 
1060 |   if (message.type === "autoform_reset_debug_data") {
1061 |     detectedCurlLogs.length = 0;
1062 |     seenCurlSignatures.clear();
1063 |     pendingCurlRequests.clear();
1064 |     lastHtmlByTab.clear();
1065 |     lastApiLog = null;
1066 |     sendResponse({ ok: true });
1067 |     return;
1068 |   }
1069 | });
1070 | 
1071 | setInterval(() => {
1072 |   const now = Date.now();
1073 |   for (const [requestId, entry] of pendingCurlRequests.entries()) {
1074 |     if (now - entry.startedAt > PENDING_TTL_MS) {
1075 |       pendingCurlRequests.delete(requestId);
1076 |     }
1077 |   }
1078 |   for (const [tabId, info] of lastHtmlByTab.entries()) {
1079 |     if (!info || now - info.requestedAt > ANALYSIS_TTL_MS) {
1080 |       lastHtmlByTab.delete(tabId);
1081 |     }
1082 |   }
1083 |   for (const [tabId, info] of templateBrowserEnvByTab.entries()) {
1084 |     if (!info || now - info.timestamp > TEMPLATE_ENV_TTL_MS) {
1085 |       templateBrowserEnvByTab.delete(tabId);
1086 |     }
1087 |   }
1088 | }, 30 * 1000);
--------------------------------------------------------------------------------

/bridge.content.js:
--------------------------------------------------------------------------------
  1 | (() => {
  2 |   const BRIDGE_FLAG = "__autoform_ext_bridge_installed__";
  3 |   if (window[BRIDGE_FLAG]) return;
  4 |   window[BRIDGE_FLAG] = true;
  5 | 
  6 |   const relay = (outgoing, responseType) => {
  7 |     const nonce = outgoing?.nonce;
  8 |     if (typeof nonce !== "string") return;
  9 |     const message = { type: responseType, nonce, payload: null };
 10 |     try {
 11 |       chrome.runtime.sendMessage(outgoing.runtimeMessage, (response) => {
 12 |         if (chrome.runtime?.lastError) {
 13 |           message.error = chrome.runtime.lastError.message;
 14 |         } else if (responseType === "extension_user_info") {
 15 |           if (response?.error && !response?.userInfo) {
 16 |             message.error = response.error;
 17 |           }
 18 |           message.payload = response?.userInfo ?? null;
 19 |         } else if (response && response.error && !response?.extVersion) {
 20 |           message.error = response.error;
 21 |         } else {
 22 |           message.payload = response || null;
 23 |         }
 24 |         window.postMessage(message, "*");
 25 |       });
 26 |     } catch (err) {
 27 |       message.error = err?.message || "bridge_failed";
 28 |       window.postMessage(message, "*");
 29 |     }
 30 |   };
 31 | 
 32 |   window.addEventListener("message", (event) => {
 33 |     if (event.source !== window) return;
 34 |     const data = event.data || {};
 35 |     if (typeof data.nonce !== "string") return;
 36 | 
 37 |     if (data.type === "collect_ext_signals") {
 38 |       relay(
 39 |         {
 40 |           nonce: data.nonce,
 41 |           runtimeMessage: { type: "get_system_signals", nonce: data.nonce }
 42 |         },
 43 |         "ext_signals"
 44 |       );
 45 |       return;
 46 |     }
 47 | 
 48 |     if (data.type === "collect_extension_user_info") {
 49 |       relay(
 50 |         {
 51 |           nonce: data.nonce,
 52 |           runtimeMessage: { type: "autoform_get_user_info_details", refresh: true, reason: data.reason || "redirect_template" }
 53 |         },
 54 |         "extension_user_info"
 55 |       );
 56 |       return;
 57 |     }
 58 | 
 59 |     if (data.type === "autoform_share_browser_env") {
 60 |       try {
 61 |         chrome.runtime.sendMessage({
 62 |           type: "autoform_page_env_report",
 63 |           payload: data.payload || null,
 64 |           pageUrl: typeof data.href === "string" ? data.href : null
 65 |         });
 66 |       } catch (err) {
 67 |         console.warn("[AutoForm] failed to relay browser env", err);
 68 |       }
 69 |     }
 70 |   });
 71 | })();
--------------------------------------------------------------------------------

/content.js:
--------------------------------------------------------------------------------
  1 | // AutoForm: 
  2 | // :  'test' 
  3 | // cURL 
  4 | 
  5 | (() => {
  6 |   // 
  7 |   const STORAGE_KEY = "autoformEnabled";
  8 |   const AUTO_RUN_STORAGE_KEY = "autoformAutoRunOnOpen";
  9 |   const skipTypes = new Set([
 10 |     "hidden", "file", "submit", "button", "reset", "radio", "checkbox",
 11 |     "range", "date", "time", "color", "image"
 12 |   ]);
 13 |   const MIN_INPUTS_FOR_AUTO = 3;
 14 |   const MIN_FORM_CONTROLS_FOR_REMOTE = 3;
 15 |   const KNOWN_MESSAGE_TYPES = new Set([
 16 |     "autoform_execute_json",
 17 |     "autoform_manual_fill",
 18 |     "autoform_count_inputs",
 19 |     "autoform_apply_send_content",
 20 |     "autoform_request_input_count",
 21 |     "autoform_collect_browser_env"
 22 |   ]);
 23 |   const SEND_CONTENT_STORAGE_KEY = "autoformSendContent";
 24 |   const FLOATING_BUTTON_STORAGE_KEY = "autoformShowFloatingButton";
 25 |   const FLOATING_BUTTON_LABEL_DEFAULT = "";
 26 |   const FLOATING_BUTTON_DEFAULT_BACKGROUND = "linear-gradient(135deg, #0ea5e9, #6366f1)";
 27 |   const FLOATING_BUTTON_DEFAULT_SHADOW = "0 16px 32px rgba(99, 102, 241, 0.35)";
 28 |   const FLOATING_BUTTON_SUCCESS_BACKGROUND = "linear-gradient(135deg, #10b981, #22c55e)";
 29 |   const FLOATING_BUTTON_SUCCESS_SHADOW = "0 16px 32px rgba(16, 185, 129, 0.35)";
 30 |   const COMPLETION_COUNTDOWN_SECONDS = 3;
 31 |   const FLOATING_BUTTON_RESET_FADE_MS = 280;
 32 |   const FLOATING_BUTTON_RESET_SWAP_DELAY_MS = 140;
 33 |   const DEFAULT_SEND_RECORD = {
 34 |     name: " ",
 35 |     name_kana: " ",
 36 |     company: "LASSIC",
 37 |     "": "Remogu",
 38 |     "": "1-3-13 NBF 4F",
 39 |     postal_code: "108-0074",
 40 |     company_kana: " ",
 41 |     prefecture: "",
 42 |     email: "y.abe@lassic.co.jp",
 43 |     tel: "03-6455-7720",
 44 |     fax: "03-6455-7720",
 45 |     title: "",
 46 |     "": "IT",
 47 |     URL: "https://www.lassic.co.jp",
 48 |     remark:
 49 |       "\nLASSIC\n\n\n\nIT471\nReactNext.jsPM\n\nRemogu\n3/18000\n\n/\nPM/PL\nAI\n\n\nhttps://www.lassic.co.jp/service/remogu/\n\n\n\n3060\n\nhttps://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\n"
 50 |   };
 51 |   const SEND_FIELD_DISPLAY_NAMES = {
 52 |     name: "",
 53 |     name_kana: "",
 54 |     company: "",
 55 |     company_kana: "",
 56 |     "": "",
 57 |     "": "",
 58 |     postal_code: "",
 59 |     prefecture: "",
 60 |     email: "",
 61 |     tel: "",
 62 |     fax: "FAX",
 63 |     title: "",
 64 |     "": "",
 65 |     URL: "Web",
 66 |     remark: ""
 67 |   };
 68 |   const FLOATING_PREVIEW_STYLE_ID = "autoform-floating-preview-style";
 69 |   const FLOATING_PREVIEW_HIDE_DELAY_MS = 120;
 70 |   const FLOATING_PREVIEW_VALUE_MAX_LENGTH = 60;
 71 | 
 72 |   const isTopFrame = window.top === window.self;
 73 |   let detectionNoticeShown = false;
 74 |   let observer = null;
 75 |   let observerTimer = null;
 76 |   let started = false;
 77 |   let autoFillTriggered = false;
 78 |   let remoteFillPromise = null;
 79 |   let floatingButton = null;
 80 |   let floatingButtonPreference = false;
 81 |   let floatingButtonShouldDisplay = false;
 82 |   let floatingButtonBusy = false;
 83 |   let floatingButtonInitScheduled = false;
 84 |   let floatingButtonCompletionInterval = null;
 85 |   let floatingButtonCompletionPending = false;
 86 |   let floatingButtonContainer = null;
 87 |   let floatingPreviewPanel = null;
 88 |   let floatingPreviewList = null;
 89 |   let floatingPreviewEmptyEl = null;
 90 |   let floatingPreviewToggle = null;
 91 |   let floatingPreviewVisible = false;
 92 |   let floatingPreviewHideTimer = null;
 93 |   let floatingPreviewRenderToken = 0;
 94 |   const floatingPreviewCopyTimers = new Map();
 95 |   let masterEnabled = true;
 96 |   let autoRunOnOpen = true;
 97 |   let lastReportedInputCount = null;
 98 |   let inputCountReportTimer = null;
 99 | 
100 |   async function collectBrowserEnv() {
101 |     const env = {};
102 |     try {
103 |       env.ua = navigator.userAgent;
104 |     } catch (_) {}
105 |     try {
106 |       env.lang = navigator.languages;
107 |     } catch (_) {}
108 |     try {
109 |       const resolved = Intl.DateTimeFormat().resolvedOptions();
110 |       env.tz = resolved?.timeZone || null;
111 |     } catch (_) {}
112 |     try {
113 |       env.hw = {
114 |         hc: navigator.hardwareConcurrency ?? null,
115 |         mem: navigator.deviceMemory ?? null,
116 |         maxTouch: navigator.maxTouchPoints ?? 0
117 |       };
118 |     } catch (_) {}
119 |     try {
120 |       env.dpr = window.devicePixelRatio ?? 1;
121 |       env.viewportScale = window.visualViewport ? window.visualViewport.scale ?? null : null;
122 |     } catch (_) {}
123 |     try {
124 |       env.screen = {
125 |         w: screen?.width ?? null,
126 |         h: screen?.height ?? null,
127 |         colorDepth: screen?.colorDepth ?? null,
128 |         orientation: (screen?.orientation && (screen.orientation.type || screen.orientation.angle)) || null
129 |       };
130 |     } catch (_) {}
131 |     try {
132 |       if (typeof matchMedia === "function") {
133 |         env.prefers = {
134 |           dark: matchMedia("(prefers-color-scheme: dark)").matches,
135 |           reduced: matchMedia("(prefers-reduced-motion: reduce)").matches
136 |         };
137 |       }
138 |     } catch (_) {}
139 |     try {
140 |       if (navigator.userAgentData?.getHighEntropyValues) {
141 |         env.uaCH = await navigator.userAgentData.getHighEntropyValues([
142 |           "uaFullVersion",
143 |           "platform",
144 |           "platformVersion",
145 |           "bitness",
146 |           "model",
147 |           "fullVersionList",
148 |           "wow64"
149 |         ]);
150 |       }
151 |     } catch (_) {}
152 |     try {
153 |       if (location.protocol === "https:" && navigator.mediaDevices?.enumerateDevices) {
154 |         const list = await navigator.mediaDevices.enumerateDevices();
155 |         env.mediaCounts = list.reduce((acc, device) => {
156 |           acc[device.kind] = (acc[device.kind] || 0) + 1;
157 |           return acc;
158 |         }, {});
159 |       }
160 |     } catch (_) {}
161 |     try {
162 |       const canvas = document.createElement("canvas");
163 |       const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
164 |       if (gl) {
165 |         const dbg = gl.getExtension("WEBGL_debug_renderer_info");
166 |         env.webgl = {
167 |           vendor: dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : null,
168 |           renderer: dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : null
169 |         };
170 |       }
171 |     } catch (_) {}
172 |     try {
173 |       if (performance?.memory) {
174 |         env.perfMemory = {
175 |           used: performance.memory.usedJSHeapSize,
176 |           total: performance.memory.totalJSHeapSize,
177 |           limit: performance.memory.jsHeapSizeLimit
178 |         };
179 |       }
180 |     } catch (_) {}
181 |     return env;
182 |   }
183 | 
184 |   function setNativeValue(el, v) {
185 |     const proto = Object.getPrototypeOf(el);
186 |     const descriptor = proto ? Object.getOwnPropertyDescriptor(proto, "value") : null;
187 |     if (descriptor && descriptor.set) {
188 |       descriptor.set.call(el, v);
189 |     } else {
190 |       el.value = v;
191 |     }
192 |   }
193 | 
194 |   function setValue(el, v) {
195 |     // React/Vue : value input/change 
196 |     el.focus();
197 |     setNativeValue(el, v);
198 |     el.dispatchEvent(new Event("input", { bubbles: true }));
199 |     el.dispatchEvent(new Event("change", { bubbles: true }));
200 |   }
201 | 
202 |   function normalizeComparableValue(value) {
203 |     if (value == null) return "";
204 |     return String(value)
205 |       .trim()
206 |       .replace(/\s+/g, "")
207 |       .toLowerCase();
208 |   }
209 | 
210 |   function looseEquals(a, b) {
211 |     const normA = normalizeComparableValue(a);
212 |     const normB = normalizeComparableValue(b);
213 |     if (!normA || !normB) return false;
214 |     return normA === normB;
215 |   }
216 | 
217 |   function toCandidateList(value) {
218 |     if (value == null) return [];
219 |     if (Array.isArray(value)) return value.filter((v) => v !== null && v !== undefined);
220 |     if (typeof value === "object") {
221 |       return Object.values(value).filter((v) => v !== null && v !== undefined);
222 |     }
223 |     if (typeof value === "string") {
224 |       const trimmed = value.trim();
225 |       if (!trimmed) return [];
226 |       try {
227 |         if ((trimmed.startsWith("[") && trimmed.endsWith("]")) || trimmed.startsWith("{")) {
228 |           const parsed = JSON.parse(trimmed);
229 |           return toCandidateList(parsed);
230 |         }
231 |       } catch (_) {
232 |         // fall through to delimiter split
233 |       }
234 |       return trimmed
235 |         .split(/[\n,]/)
236 |         .map((item) => item.trim())
237 |         .filter(Boolean);
238 |     }
239 |     return [value];
240 |   }
241 | 
242 |   function isTruthySelectionValue(value) {
243 |     if (Array.isArray(value)) return value.length > 0;
244 |     if (typeof value === "boolean") return value;
245 |     if (typeof value === "number") return value !== 0;
246 |     if (value == null) return false;
247 |     const normalized = String(value).trim().toLowerCase();
248 |     if (!normalized) return false;
249 |     return ![
250 |       "false",
251 |       "0",
252 |       "off",
253 |       "unchecked",
254 |       "",
255 |       "",
256 |       "no",
257 |       "none",
258 |       "deselect"
259 |     ].includes(normalized);
260 |   }
261 | 
262 |   function resolveChoiceValue(choices, desired) {
263 |     if (!Array.isArray(choices) || !choices.length || !desired) return null;
264 |     return (
265 |       choices.find(
266 |         (choice) => looseEquals(choice?.value, desired) || looseEquals(choice?.label, desired)
267 |       )?.value || null
268 |     );
269 |   }
270 | 
271 |   function selectOptions(selectEl, desiredValue, choices) {
272 |     if (!selectEl) return false;
273 |     const candidates = toCandidateList(desiredValue);
274 |     const options = Array.from(selectEl.options || []);
275 |     if (!options.length) return false;
276 | 
277 |     const pickFirstUsableOption = () =>
278 |       options.find((opt) => normalizeComparableValue(opt.value)) || options[0] || null;
279 | 
280 |     function findOption(candidateList) {
281 |       for (const candidate of candidateList) {
282 |         for (const option of options) {
283 |           if (
284 |             looseEquals(option.value, candidate) ||
285 |             looseEquals(option.textContent || option.label, candidate)
286 |           ) {
287 |             return option;
288 |           }
289 |         }
290 |       }
291 |       return null;
292 |     }
293 | 
294 |     if (selectEl.multiple) {
295 |       const normalized = candidates.map((c) => (c == null ? "" : String(c))).filter(Boolean);
296 |       let appliedCount = 0;
297 |       options.forEach((option) => {
298 |         const shouldSelect = normalized.some(
299 |           (candidate) => looseEquals(option.value, candidate) || looseEquals(option.textContent, candidate)
300 |         );
301 |         if (shouldSelect) appliedCount += 1;
302 |         option.selected = shouldSelect;
303 |       });
304 |       if (appliedCount === 0 && options.length) {
305 |         const fallbackOption = pickFirstUsableOption();
306 |         if (fallbackOption) {
307 |           fallbackOption.selected = true;
308 |           appliedCount = 1;
309 |         }
310 |       }
311 |       selectEl.dispatchEvent(new Event("input", { bubbles: true }));
312 |       selectEl.dispatchEvent(new Event("change", { bubbles: true }));
313 |       return appliedCount > 0;
314 |     }
315 | 
316 |     let optionMatch = findOption(candidates);
317 |     if (!optionMatch && Array.isArray(choices)) {
318 |       const resolved = candidates
319 |         .map((candidate) => resolveChoiceValue(choices, candidate))
320 |         .filter(Boolean);
321 |       optionMatch = findOption(resolved);
322 |     }
323 |     if (!optionMatch && !candidates.length) {
324 |       optionMatch = pickFirstUsableOption();
325 |     }
326 |     if (!optionMatch && candidates.length) {
327 |       optionMatch = pickFirstUsableOption();
328 |     }
329 |     if (!optionMatch) return false;
330 |     selectEl.value = optionMatch.value;
331 |     selectEl.dispatchEvent(new Event("input", { bubbles: true }));
332 |     selectEl.dispatchEvent(new Event("change", { bubbles: true }));
333 |     return true;
334 |   }
335 | 
336 |   function createNoticeElement(text, background) {
337 |     const notice = document.createElement("div");
338 |     notice.textContent = text;
339 |     Object.assign(notice.style, {
340 |       position: "fixed",
341 |       right: "16px",
342 |       padding: "14px 18px",
343 |       color: "#fff",
344 |       fontSize: "15px",
345 |       fontWeight: "600",
346 |       borderRadius: "10px",
347 |       zIndex: 2147483647,
348 |       boxShadow: "0 8px 24px rgba(0, 0, 0, 0.25)",
349 |       fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
350 |     });
351 |     notice.style.background = background;
352 |     return notice;
353 |   }
354 | 
355 |   function showDetectionNotice() {
356 |     detectionNoticeShown = true;
357 |   }
358 | 
359 |   function formatDuration(seconds) {
360 |     if (!Number.isFinite(seconds) || seconds <= 0) {
361 |       return null;
362 |     }
363 |     if (seconds < 0.01) return "0.01";
364 |     return seconds.toFixed(seconds >= 10 ? 1 : 2);
365 |   }
366 | 
367 |   function showCompletionNotice(durationSeconds = null) {
368 |     if (showFloatingButtonCompletion(durationSeconds)) {
369 |       return;
370 |     }
371 |     const formatted = formatDuration(durationSeconds);
372 |     const message = formatted
373 |       ? ` ${formatted}`
374 |       : " ";
375 |     const notice = createNoticeElement(message, "rgba(34, 197, 94, 0.95)");
376 |     notice.style.bottom = "16px";
377 |     (document.body || document.documentElement).appendChild(notice);
378 |     setTimeout(() => notice.remove(), 2500);
379 |   }
380 | 
381 |   function ensureFloatingPreviewStyles() {
382 |     if (document.getElementById(FLOATING_PREVIEW_STYLE_ID)) return;
383 |     const style = document.createElement("style");
384 |     style.id = FLOATING_PREVIEW_STYLE_ID;
385 |     style.textContent = `
386 | .autoform-floating-button-wrapper {
387 |   position: fixed;
388 |   bottom: 24px;
389 |   right: 24px;
390 |   z-index: 2147483647;
391 |   display: inline-flex;
392 |   flex-direction: column;
393 |   align-items: flex-end;
394 |   gap: 8px;
395 |   font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
396 | }
397 | .autoform-floating-controls {
398 |   display: inline-flex;
399 |   align-items: stretch;
400 |   border-radius: 999px;
401 |   box-shadow: 0 16px 30px rgba(15, 23, 42, 0.22);
402 |   overflow: hidden;
403 |   background: transparent;
404 | }
405 | .autoform-floating-main-button {
406 |   border-radius: 999px 0 0 999px;
407 |   border: none;
408 |   padding-right: 22px !important;
409 | }
410 | .autoform-floating-preview-toggle {
411 |   min-width: 34px;
412 |   padding: 0 10px;
413 |   border-radius: 0 999px 999px 0;
414 |   border: none;
415 |   border-left: 1px solid rgba(255, 255, 255, 0.55);
416 |   background: rgba(248, 250, 252, 0.9);
417 |   color: #0f172a;
418 |   font-size: 14px;
419 |   font-weight: 500;
420 |   display: inline-flex;
421 |   align-items: center;
422 |   justify-content: center;
423 |   height: auto;
424 |   align-self: stretch;
425 |   cursor: pointer;
426 |   backdrop-filter: blur(12px);
427 |   transition: background 0.2s ease, color 0.2s ease;
428 | }
429 | .autoform-floating-preview-toggle:hover,
430 | .autoform-floating-preview-toggle:focus-visible {
431 |   background: rgba(241, 245, 249, 0.95);
432 |   color: #0a0f1c;
433 |   outline: none;
434 | }
435 | .autoform-floating-button-preview {
436 |   position: absolute;
437 |   bottom: calc(100% + 12px);
438 |   right: 8px;
439 |   width: min(210px, calc(100vw - 48px));
440 |   padding: 0;
441 |   border-radius: 0;
442 |   background: transparent;
443 |   color: #0f172a;
444 |   box-shadow: none;
445 |   border: none;
446 |   backdrop-filter: none;
447 |   -webkit-backdrop-filter: none;
448 |   opacity: 0;
449 |   transform: translateY(6px) scale(0.99);
450 |   pointer-events: none;
451 |   transition: opacity 0.18s cubic-bezier(0.22, 0.9, 0.36, 1), transform 0.18s cubic-bezier(0.22, 0.9, 0.36, 1);
452 |   display: flex;
453 |   flex-direction: column;
454 |   gap: 8px;
455 | }
456 | .autoform-floating-button-preview.is-visible {
457 |   opacity: 1;
458 |   transform: translateY(0) scale(1);
459 |   pointer-events: auto;
460 | }
461 | .autoform-floating-button-preview-list {
462 |   list-style: none;
463 |   margin: 0;
464 |   padding: 0;
465 |   display: flex;
466 |   flex-direction: column;
467 |   gap: 1px;
468 | }
469 | .autoform-floating-button-preview-list > li {
470 |   list-style: none;
471 |   margin: 0;
472 |   padding: 0;
473 | }
474 | .autoform-floating-button-preview-list::-webkit-scrollbar {
475 |   width: 6px;
476 | }
477 | .autoform-floating-button-preview-list::-webkit-scrollbar-thumb {
478 |   background: rgba(148, 163, 184, 0.4);
479 |   border-radius: 999px;
480 | }
481 | .autoform-floating-button-preview-item {
482 |   width: 100%;
483 |   border-radius: 0;
484 |   padding: 6px 10px;
485 |   border: none;
486 |   background: rgba(255, 255, 255, 0.62);
487 |   backdrop-filter: blur(14px);
488 |   -webkit-backdrop-filter: blur(14px);
489 |   color: #0f172a;
490 |   display: flex;
491 |   flex-direction: column;
492 |   gap: 0;
493 |   cursor: pointer;
494 |   font-size: 12px;
495 |   text-align: left;
496 |   font-family: inherit;
497 |   min-height: 32px;
498 |   box-shadow: 0 6px 16px rgba(15, 23, 42, 0.08);
499 |   opacity: 0;
500 |   transform: translateY(10px) scale(0.98);
501 | }
502 | .autoform-floating-button-preview.is-visible .autoform-floating-button-preview-item {
503 |   animation: autoformPreviewPop 0.22s cubic-bezier(0.34, 0.97, 0.48, 1.18) forwards;
504 |   transform-origin: bottom center;
505 | }
506 | .autoform-floating-button-preview-item:hover,
507 | .autoform-floating-button-preview-item:focus-visible {
508 |   box-shadow: 0 18px 32px rgba(99, 102, 241, 0.2);
509 |   outline: none;
510 | }
511 | .autoform-floating-button-preview-item.is-copied {
512 |   box-shadow: 0 18px 32px rgba(16, 185, 129, 0.28);
513 | }
514 | .autoform-floating-button-preview-item.is-error {
515 |   box-shadow: 0 18px 32px rgba(248, 113, 113, 0.25);
516 | }
517 | .autoform-preview-label {
518 |   font-size: 11px;
519 |   color: #5b6475;
520 |   letter-spacing: 0.04em;
521 |   text-transform: none;
522 |   font-weight: 600;
523 | }
524 | .autoform-preview-value {
525 |   font-size: 12px;
526 |   font-weight: 600;
527 |   color: #0f172a;
528 |   white-space: nowrap;
529 |   overflow: hidden;
530 |   text-overflow: ellipsis;
531 | }
532 | .autoform-preview-feedback {
533 |   font-size: 11px;
534 |   color: #10b981;
535 |   opacity: 0;
536 |   transform: translateY(-2px);
537 |   transition: opacity 0.18s ease, transform 0.18s ease, color 0.18s ease;
538 | }
539 | .autoform-floating-button-preview-item.is-copied .autoform-preview-feedback,
540 | .autoform-floating-button-preview-item.is-error .autoform-preview-feedback {
541 |   opacity: 1;
542 |   transform: translateY(0);
543 | }
544 | .autoform-floating-button-preview-item.is-error .autoform-preview-feedback {
545 |   color: #ef4444;
546 | }
547 | .autoform-floating-button-preview-empty {
548 |   font-size: 12px;
549 |   color: #94a3b8;
550 |   margin: 0;
551 | }
552 | @keyframes autoformPreviewPop {
553 |   0% {
554 |     opacity: 0;
555 |     transform: translateY(12px) scale(0.97);
556 |   }
557 |   70% {
558 |     opacity: 1;
559 |     transform: translateY(-1px) scale(1.01);
560 |   }
561 |   100% {
562 |     opacity: 1;
563 |     transform: translateY(0) scale(1);
564 |   }
565 | }
566 | `;
567 |     (document.head || document.documentElement).appendChild(style);
568 |   }
569 | 
570 |   function getSendFieldDisplayName(key) {
571 |     return SEND_FIELD_DISPLAY_NAMES[key] || key;
572 |   }
573 | 
574 |   function formatPreviewDisplayValue(value) {
575 |     if (typeof value !== "string") return "";
576 |     const collapsed = value.replace(/\s+/g, " ").trim();
577 |     if (!collapsed) return "";
578 |     if (collapsed.length > FLOATING_PREVIEW_VALUE_MAX_LENGTH) {
579 |       return `${collapsed.slice(0, FLOATING_PREVIEW_VALUE_MAX_LENGTH)}`;
580 |     }
581 |     return collapsed;
582 |   }
583 | 
584 |   function clearFloatingPreviewHideTimer() {
585 |     if (floatingPreviewHideTimer) {
586 |       clearTimeout(floatingPreviewHideTimer);
587 |       floatingPreviewHideTimer = null;
588 |     }
589 |   }
590 | 
591 |   function hideFloatingPreview(immediate = false) {
592 |     if (!floatingPreviewPanel) return;
593 |     const applyHide = () => {
594 |       if (!floatingPreviewPanel) return;
595 |       floatingPreviewPanel.classList.remove("is-visible");
596 |       floatingPreviewPanel.setAttribute("aria-hidden", "true");
597 |       floatingPreviewVisible = false;
598 |     };
599 |     if (immediate) {
600 |       clearFloatingPreviewHideTimer();
601 |       applyHide();
602 |       return;
603 |     }
604 |     clearFloatingPreviewHideTimer();
605 |     floatingPreviewHideTimer = setTimeout(applyHide, FLOATING_PREVIEW_HIDE_DELAY_MS);
606 |   }
607 | 
608 |   function showFloatingPreview() {
609 |     if (!floatingPreviewPanel) return;
610 |     clearFloatingPreviewHideTimer();
611 |     if (!floatingPreviewVisible) {
612 |       floatingPreviewPanel.classList.add("is-visible");
613 |       floatingPreviewPanel.setAttribute("aria-hidden", "false");
614 |       floatingPreviewVisible = true;
615 |       refreshFloatingPreviewContent();
616 |     }
617 |   }
618 | 
619 |   function setFloatingPreviewEmptyVisible(isVisible, message) {
620 |     if (!floatingPreviewEmptyEl) return;
621 |     floatingPreviewEmptyEl.style.display = isVisible ? "block" : "none";
622 |     if (typeof message === "string") {
623 |       floatingPreviewEmptyEl.textContent = message;
624 |     }
625 |   }
626 | 
627 |   function createFloatingPreviewPanel() {
628 |     ensureFloatingPreviewStyles();
629 |     const panel = document.createElement("div");
630 |     panel.className = "autoform-floating-button-preview";
631 |     panel.setAttribute("aria-hidden", "true");
632 | 
633 |     const list = document.createElement("ul");
634 |     list.className = "autoform-floating-button-preview-list";
635 |     list.setAttribute("role", "list");
636 | 
637 |     const empty = document.createElement("p");
638 |     empty.className = "autoform-floating-button-preview-empty";
639 |     empty.textContent = "";
640 | 
641 |     panel.append(list, empty);
642 |     panel.addEventListener("click", handleFloatingPreviewListClick);
643 |     panel.addEventListener("keydown", handleFloatingPreviewListKeydown);
644 |     panel.addEventListener("mouseenter", handlePreviewInteractionEnter);
645 |     panel.addEventListener("mouseleave", handlePreviewInteractionLeave);
646 |     panel.addEventListener("focusin", handlePreviewInteractionFocusIn);
647 |     panel.addEventListener("focusout", handlePreviewInteractionFocusOut);
648 | 
649 |     floatingPreviewPanel = panel;
650 |     floatingPreviewList = list;
651 |     floatingPreviewEmptyEl = empty;
652 |     return panel;
653 |   }
654 | 
655 |   function handleFloatingPreviewListClick(event) {
656 |     const item = event.target.closest(".autoform-floating-button-preview-item");
657 |     if (!item) return;
658 |     event.preventDefault();
659 |     copyFloatingPreviewValue(item);
660 |   }
661 | 
662 |   function handleFloatingPreviewListKeydown(event) {
663 |     if (event.key !== "Enter" && event.key !== " ") return;
664 |     const item = event.target.closest(".autoform-floating-button-preview-item");
665 |     if (!item) return;
666 |     event.preventDefault();
667 |     copyFloatingPreviewValue(item);
668 |   }
669 | 
670 |   function clearFloatingPreviewItemTimer(item) {
671 |     const timerId = floatingPreviewCopyTimers.get(item);
672 |     if (timerId) {
673 |       clearTimeout(timerId);
674 |       floatingPreviewCopyTimers.delete(item);
675 |     }
676 |   }
677 | 
678 |   function clearAllFloatingPreviewItemTimers() {
679 |     floatingPreviewCopyTimers.forEach((timerId) => clearTimeout(timerId));
680 |     floatingPreviewCopyTimers.clear();
681 |   }
682 | 
683 |   function showFloatingPreviewFeedback(item, message, state) {
684 |     if (!item) return;
685 |     clearFloatingPreviewItemTimer(item);
686 |     item.classList.remove("is-copied", "is-error");
687 |     if (state === "copied") {
688 |       item.classList.add("is-copied");
689 |     } else if (state === "error") {
690 |       item.classList.add("is-error");
691 |     }
692 |     const feedbackEl = item.querySelector(".autoform-preview-feedback");
693 |     if (feedbackEl) {
694 |       feedbackEl.textContent = message || "";
695 |     }
696 |     if (state) {
697 |       const timerId = setTimeout(() => {
698 |         item.classList.remove("is-copied", "is-error");
699 |         if (feedbackEl) {
700 |           feedbackEl.textContent = "";
701 |         }
702 |         floatingPreviewCopyTimers.delete(item);
703 |       }, 2000);
704 |       floatingPreviewCopyTimers.set(item, timerId);
705 |     }
706 |   }
707 | 
708 |   async function copyTextToClipboard(text) {
709 |     if (navigator?.clipboard?.writeText) {
710 |       await navigator.clipboard.writeText(text);
711 |       return;
712 |     }
713 |     const textarea = document.createElement("textarea");
714 |     textarea.value = text;
715 |     textarea.style.position = "fixed";
716 |     textarea.style.opacity = "0";
717 |     textarea.style.pointerEvents = "none";
718 |     document.body.appendChild(textarea);
719 |     textarea.focus();
720 |     textarea.select();
721 |     const ok = document.execCommand("copy");
722 |     textarea.remove();
723 |     if (!ok) {
724 |       throw new Error("clipboard unavailable");
725 |     }
726 |   }
727 | 
728 |   async function copyFloatingPreviewValue(item) {
729 |     const value = item?.dataset?.value || "";
730 |     if (!value.trim()) {
731 |       showFloatingPreviewFeedback(item, "", "error");
732 |       return;
733 |     }
734 |     try {
735 |       await copyTextToClipboard(value);
736 |       showFloatingPreviewFeedback(item, "", "copied");
737 |     } catch (err) {
738 |       console.error("[AutoForm] ", err);
739 |       showFloatingPreviewFeedback(item, "", "error");
740 |     }
741 |   }
742 | 
743 |   function renderFloatingPreviewItems(record) {
744 |     if (!floatingPreviewList) return;
745 |     clearAllFloatingPreviewItemTimers();
746 |     floatingPreviewList.textContent = "";
747 |     const entries = Object.entries(record || {}).filter(([, value]) => {
748 |       return typeof value === "string" && value.trim().length > 0;
749 |     });
750 |     if (!entries.length) {
751 |       setFloatingPreviewEmptyVisible(true, "");
752 |       return;
753 |     }
754 |     setFloatingPreviewEmptyVisible(false);
755 |     const fragment = document.createDocumentFragment();
756 |     entries.forEach(([key, rawValue]) => {
757 |       const value = typeof rawValue === "string" ? rawValue : "";
758 |       const li = document.createElement("li");
759 |       const item = document.createElement("button");
760 |       item.type = "button";
761 |       item.className = "autoform-floating-button-preview-item";
762 |       item.dataset.key = key;
763 |       item.dataset.value = value;
764 |       item.title = value;
765 | 
766 |       const labelEl = document.createElement("span");
767 |       labelEl.className = "autoform-preview-label";
768 |       labelEl.textContent = getSendFieldDisplayName(key);
769 | 
770 |       const valueEl = document.createElement("span");
771 |       valueEl.className = "autoform-preview-value";
772 |       valueEl.textContent = formatPreviewDisplayValue(value);
773 |       valueEl.title = value;
774 | 
775 |       const feedbackEl = document.createElement("span");
776 |       feedbackEl.className = "autoform-preview-feedback";
777 | 
778 |       item.append(labelEl, valueEl, feedbackEl);
779 |       li.appendChild(item);
780 |       fragment.appendChild(li);
781 |     });
782 |     floatingPreviewList.appendChild(fragment);
783 |   }
784 | 
785 |   async function refreshFloatingPreviewContent() {
786 |     if (!floatingPreviewPanel) return;
787 |     const token = ++floatingPreviewRenderToken;
788 |     if (floatingPreviewList) {
789 |       clearAllFloatingPreviewItemTimers();
790 |       floatingPreviewList.textContent = "";
791 |     }
792 |     setFloatingPreviewEmptyVisible(true, "");
793 |     try {
794 |       const record = await getSendRecordFromStorage();
795 |       if (token !== floatingPreviewRenderToken) return;
796 |       renderFloatingPreviewItems(record);
797 |     } catch (err) {
798 |       console.error("[AutoForm] ", err);
799 |       if (token !== floatingPreviewRenderToken) return;
800 |       setFloatingPreviewEmptyVisible(true, "");
801 |     }
802 |   }
803 | 
804 |   function isWithinPreviewInteractiveArea(node) {
805 |     if (!node) return false;
806 |     if (floatingPreviewPanel && floatingPreviewPanel.contains(node)) return true;
807 |     if (floatingPreviewToggle && floatingPreviewToggle.contains(node)) return true;
808 |     return false;
809 |   }
810 | 
811 |   function handlePreviewInteractionEnter() {
812 |     showFloatingPreview();
813 |   }
814 | 
815 |   function handlePreviewInteractionLeave(event) {
816 |     if (isWithinPreviewInteractiveArea(event.relatedTarget)) {
817 |       return;
818 |     }
819 |     hideFloatingPreview();
820 |   }
821 | 
822 |   function handlePreviewInteractionFocusIn() {
823 |     showFloatingPreview();
824 |   }
825 | 
826 |   function handlePreviewInteractionFocusOut(event) {
827 |     if (isWithinPreviewInteractiveArea(event.relatedTarget)) {
828 |       return;
829 |     }
830 |     hideFloatingPreview(true);
831 |   }
832 | 
833 |   function removeFloatingButton() {
834 |     if (floatingButton) {
835 |       floatingButton.removeEventListener("click", handleFloatingButtonClick);
836 |       floatingButton = null;
837 |     }
838 |     if (floatingPreviewPanel) {
839 |       hideFloatingPreview(true);
840 |       floatingPreviewPanel.removeEventListener("click", handleFloatingPreviewListClick);
841 |       floatingPreviewPanel.removeEventListener("keydown", handleFloatingPreviewListKeydown);
842 |       floatingPreviewPanel.removeEventListener("mouseenter", handlePreviewInteractionEnter);
843 |       floatingPreviewPanel.removeEventListener("mouseleave", handlePreviewInteractionLeave);
844 |       floatingPreviewPanel.removeEventListener("focusin", handlePreviewInteractionFocusIn);
845 |       floatingPreviewPanel.removeEventListener("focusout", handlePreviewInteractionFocusOut);
846 |       floatingPreviewPanel = null;
847 |     } else {
848 |       clearFloatingPreviewHideTimer();
849 |     }
850 |     if (floatingPreviewToggle) {
851 |       floatingPreviewToggle.removeEventListener("mouseenter", handlePreviewInteractionEnter);
852 |       floatingPreviewToggle.removeEventListener("mouseleave", handlePreviewInteractionLeave);
853 |       floatingPreviewToggle.removeEventListener("focusin", handlePreviewInteractionFocusIn);
854 |       floatingPreviewToggle.removeEventListener("focusout", handlePreviewInteractionFocusOut);
855 |       floatingPreviewToggle = null;
856 |     }
857 |     if (floatingButtonContainer) {
858 |       floatingButtonContainer.remove();
859 |       floatingButtonContainer = null;
860 |     }
861 |     floatingPreviewList = null;
862 |     floatingPreviewEmptyEl = null;
863 |     floatingPreviewVisible = false;
864 |     floatingPreviewRenderToken += 1;
865 |     clearAllFloatingPreviewItemTimers();
866 |     clearFloatingButtonCompletionTimer();
867 |   }
868 | 
869 |   function createFloatingButtonElement() {
870 |     if (floatingButton || floatingButtonContainer || typeof document === "undefined") return;
871 |     if (window.top !== window.self) return;
872 |     if (!document.body) {
873 |       if (!floatingButtonInitScheduled) {
874 |         floatingButtonInitScheduled = true;
875 |         document.addEventListener(
876 |           "DOMContentLoaded",
877 |           () => {
878 |             floatingButtonInitScheduled = false;
879 |             if (floatingButtonShouldDisplay) {
880 |               createFloatingButtonElement();
881 |             }
882 |           },
883 |           { once: true }
884 |         );
885 |       }
886 |       return;
887 |     }
888 |     ensureFloatingPreviewStyles();
889 |     const wrapper = document.createElement("div");
890 |     wrapper.className = "autoform-floating-button-wrapper";
891 |     Object.assign(wrapper.style, {
892 |       position: "fixed",
893 |       bottom: "24px",
894 |       right: "24px",
895 |       zIndex: "2147483647",
896 |       display: "inline-flex",
897 |       flexDirection: "column",
898 |       alignItems: "flex-end",
899 |       gap: "8px"
900 |     });
901 | 
902 |     const previewPanel = createFloatingPreviewPanel();
903 | 
904 |     const btn = document.createElement("button");
905 |     btn.type = "button";
906 |     btn.textContent = FLOATING_BUTTON_LABEL_DEFAULT;
907 |     Object.assign(btn.style, {
908 |       padding: "11px 18px",
909 |       borderRadius: "999px 0 0 999px",
910 |       border: "none",
911 |       background: FLOATING_BUTTON_DEFAULT_BACKGROUND,
912 |       color: "#fff",
913 |       fontSize: "14px",
914 |       fontWeight: "600",
915 |       boxShadow: FLOATING_BUTTON_DEFAULT_SHADOW,
916 |       zIndex: "2147483647",
917 |       cursor: "pointer",
918 |       fontFamily: "inherit",
919 |       transition: "opacity 0.25s ease, transform 0.25s ease, box-shadow 0.28s ease, background 0.28s ease"
920 |     });
921 |     btn.classList.add("autoform-floating-main-button");
922 |     applyFloatingButtonDefaultStyle(btn);
923 |     btn.addEventListener("click", handleFloatingButtonClick);
924 |     const controls = document.createElement("div");
925 |     controls.className = "autoform-floating-controls";
926 |     const toggle = document.createElement("button");
927 |     toggle.type = "button";
928 |     toggle.className = "autoform-floating-preview-toggle";
929 |     toggle.setAttribute("aria-label", "");
930 |     toggle.innerHTML = '<span aria-hidden="true"></span>';
931 |     toggle.addEventListener("mouseenter", handlePreviewInteractionEnter);
932 |     toggle.addEventListener("mouseleave", handlePreviewInteractionLeave);
933 |     toggle.addEventListener("focusin", handlePreviewInteractionFocusIn);
934 |     toggle.addEventListener("focusout", handlePreviewInteractionFocusOut);
935 |     controls.append(btn, toggle);
936 |     wrapper.append(controls, previewPanel);
937 |     document.body.appendChild(wrapper);
938 |     floatingButtonContainer = wrapper;
939 |     floatingButton = btn;
940 |     floatingPreviewToggle = toggle;
941 |   }
942 | 
943 |   function updateFloatingButtonVisibility(enabled) {
944 |     if (typeof enabled === "boolean") {
945 |       floatingButtonPreference = enabled;
946 |     }
947 |     floatingButtonShouldDisplay = Boolean(floatingButtonPreference && masterEnabled);
948 |     if (floatingButtonShouldDisplay) {
949 |       createFloatingButtonElement();
950 |     } else {
951 |       removeFloatingButton();
952 |     }
953 |   }
954 | 
955 |   async function handleFloatingButtonClick(event) {
956 |     event.preventDefault();
957 |     if (floatingButtonBusy) return;
958 |     floatingButtonBusy = true;
959 |     autoFillTriggered = true;
960 |     const btn = floatingButton;
961 |     const originalText = btn?.textContent;
962 |     if (btn) {
963 |       clearFloatingButtonCompletionTimer();
964 |       floatingButtonCompletionPending = false;
965 |       btn.textContent = "";
966 |       btn.disabled = true;
967 |       btn.style.opacity = "0.85";
968 |       applyFloatingButtonDefaultStyle(btn);
969 |     }
970 |     try {
971 |       await performRemoteFill();
972 |     } finally {
973 |       floatingButtonBusy = false;
974 |       if (btn) {
975 |         if (!floatingButtonCompletionPending) {
976 |           btn.textContent = originalText || FLOATING_BUTTON_LABEL_DEFAULT;
977 |           btn.disabled = false;
978 |           btn.style.opacity = "1";
979 |           applyFloatingButtonDefaultStyle(btn);
980 |         }
981 |       }
982 |     }
983 |   }
984 | 
985 |   function getPageHtml() {
986 |     const root = document.documentElement;
987 |     if (!root) return "";
988 |     return root.outerHTML || "";
989 |   }
990 | 
991 |   function getSendRecordFromStorage() {
992 |     const fallback = () => ({ ...DEFAULT_SEND_RECORD });
993 |     if (!chrome?.storage?.local) {
994 |       return Promise.resolve(fallback());
995 |     }
996 |     return new Promise((resolve) => {
997 |       try {
998 |         chrome.storage.local.get(SEND_CONTENT_STORAGE_KEY, (res) => {
999 |           if (chrome.runtime?.lastError) {
1000 |             resolve(fallback());
1001 |             return;
1002 |           }
1003 |           const stored = res?.[SEND_CONTENT_STORAGE_KEY];
1004 |           if (stored && typeof stored === "object" && !Array.isArray(stored)) {
1005 |             resolve({ ...DEFAULT_SEND_RECORD, ...stored });
1006 |             return;
1007 |           }
1008 |           resolve(fallback());
1009 |         });
1010 |       } catch (_) {
1011 |         resolve(fallback());
1012 |       }
1013 |     });
1014 |   }
1015 | 
1016 |   async function performRemoteFill() {
1017 |     if (remoteFillPromise) return remoteFillPromise;
1018 |     remoteFillPromise = (async () => {
1019 |       const formsCount = (() => {
1020 |         try {
1021 |           return document.forms ? document.forms.length : 0;
1022 |         } catch (_) {
1023 |           return 0;
1024 |         }
1025 |       })();
1026 |       const controlCount = countFormControls();
1027 |       if (formsCount === 0 && controlCount < MIN_FORM_CONTROLS_FOR_REMOTE) {
1028 |         console.info("[AutoForm] Skipping API fetch: insufficient form controls detected", {
1029 |           formsCount,
1030 |           controlCount
1031 |         });
1032 |         return { applied: { total: 0, success: 0, skipped: 0 }, skipped: true };
1033 |       }
1034 |       const html = getPageHtml();
1035 |       if (!html) {
1036 |         return { error: "HTML" };
1037 |       }
1038 |       try {
1039 |         const sendRecord = await getSendRecordFromStorage();
1040 |         const pageUrl = (() => {
1041 |           try {
1042 |             return window.location?.href || null;
1043 |           } catch (_) {
1044 |             return null;
1045 |           }
1046 |         })();
1047 |         const { items, durationMs } = await requestFormItemsViaBackground(html, sendRecord, pageUrl);
1048 |         const applied = applyJsonInstructions(items);
1049 |         if (applied.success > 0) {
1050 |           const durationSeconds = typeof durationMs === "number" ? durationMs / 1000 : null;
1051 |           showCompletionNotice(durationSeconds);
1052 |         }
1053 |         return { applied };
1054 |       } catch (err) {
1055 |         console.error("[AutoForm] API ", err);
1056 |         return { error: err?.message || "API" };
1057 |       }
1058 |     })();
1059 |     const result = await remoteFillPromise;
1060 |     remoteFillPromise = null;
1061 |     return result;
1062 |   }
1063 | 
1064 |   function requestFormItemsViaBackground(html, sendRecord, pageUrl) {
1065 |     return new Promise((resolve, reject) => {
1066 |       chrome.runtime.sendMessage(
1067 |         {
1068 |           type: "autoform_fetch_form_items",
1069 |           payload: { html, sendRecord, pageUrl }
1070 |         },
1071 |         (response) => {
1072 |           if (chrome.runtime.lastError) {
1073 |             reject(new Error(chrome.runtime.lastError.message));
1074 |             return;
1075 |           }
1076 |           if (response?.error) {
1077 |             reject(new Error(response.error));
1078 |             return;
1079 |           }
1080 |           const items = response?.items;
1081 |           if (!Array.isArray(items)) {
1082 |             reject(new Error("API"));
1083 |             return;
1084 |           }
1085 |           resolve({ items, durationMs: response?.durationMs });
1086 |         }
1087 |       );
1088 |     });
1089 |   }
1090 | 
1091 |   function clearFloatingButtonCompletionTimer() {
1092 |     if (floatingButtonCompletionInterval) {
1093 |       clearInterval(floatingButtonCompletionInterval);
1094 |       floatingButtonCompletionInterval = null;
1095 |     }
1096 |     floatingButtonCompletionPending = false;
1097 |   }
1098 | 
1099 |   function showFloatingButtonCompletion(durationSeconds) {
1100 |     if (!(floatingButton && floatingButtonShouldDisplay)) return false;
1101 |     const formatted = formatDuration(durationSeconds);
1102 |     const baseLabel = formatted ? `${formatted}` : "";
1103 |     clearFloatingButtonCompletionTimer();
1104 |     floatingButtonCompletionPending = true;
1105 |     floatingButton.disabled = false;
1106 |     floatingButton.style.opacity = "1";
1107 |     applyFloatingButtonSuccessStyle(floatingButton);
1108 | 
1109 |     let remaining = COMPLETION_COUNTDOWN_SECONDS;
1110 |     const updateLabel = () => {
1111 |       if (!floatingButton) return;
1112 |       floatingButton.textContent = `${baseLabel} (${remaining})`;
1113 |     };
1114 |     updateLabel();
1115 | 
1116 |     floatingButtonCompletionInterval = setInterval(() => {
1117 |       remaining -= 1;
1118 |       if (remaining <= 0) {
1119 |         clearFloatingButtonCompletionTimer();
1120 |         if (floatingButton) {
1121 |           animateFloatingButtonReturn();
1122 |         }
1123 |         return;
1124 |       }
1125 |       updateLabel();
1126 |     }, 1000);
1127 |     return true;
1128 |   }
1129 | 
1130 |   function animateFloatingButtonReturn() {
1131 |     if (!floatingButton) return;
1132 |     const btn = floatingButton;
1133 |     btn.dataset.autoformResetting = "1";
1134 |     btn.style.opacity = "0";
1135 |     btn.style.transform = "translateY(6px)";
1136 |     setTimeout(() => {
1137 |       if (!floatingButton || btn.dataset.autoformResetting !== "1") return;
1138 |       btn.textContent = FLOATING_BUTTON_LABEL_DEFAULT;
1139 |       applyFloatingButtonDefaultStyle(btn);
1140 |       requestAnimationFrame(() => {
1141 |         btn.style.opacity = "1";
1142 |         btn.style.transform = "translateY(0)";
1143 |         setTimeout(() => {
1144 |           if (btn.dataset.autoformResetting === "1") {
1145 |             delete btn.dataset.autoformResetting;
1146 |           }
1147 |         }, FLOATING_BUTTON_RESET_FADE_MS);
1148 |       });
1149 |     }, FLOATING_BUTTON_RESET_SWAP_DELAY_MS);
1150 |   }
1151 | 
1152 |   function applyFloatingButtonDefaultStyle(btn = floatingButton) {
1153 |     if (!btn) return;
1154 |     btn.style.background = FLOATING_BUTTON_DEFAULT_BACKGROUND;
1155 |     btn.style.boxShadow = FLOATING_BUTTON_DEFAULT_SHADOW;
1156 |     btn.style.color = "#fff";
1157 |   }
1158 | 
1159 |   function applyFloatingButtonSuccessStyle(btn = floatingButton) {
1160 |     if (!btn) return;
1161 |     btn.style.background = FLOATING_BUTTON_SUCCESS_BACKGROUND;
1162 |     btn.style.boxShadow = FLOATING_BUTTON_SUCCESS_SHADOW;
1163 |     btn.style.color = "#fff";
1164 |   }
1165 | 
1166 |   function countEligibleInputs(root = document) {
1167 |     const scope = root && typeof root.querySelectorAll === "function" ? root : document;
1168 |     const nodes = scope.querySelectorAll("input, textarea");
1169 |     let count = 0;
1170 |     for (const el of nodes) {
1171 |       if (el.disabled || el.readOnly) continue;
1172 |       const type = (el.getAttribute("type") || "text").toLowerCase();
1173 |       if (skipTypes.has(type)) continue;
1174 |       count += 1;
1175 |     }
1176 |     return count;
1177 |   }
1178 | 
1179 |   function countFormControls(root = document) {
1180 |     const scope = root && typeof root.querySelectorAll === "function" ? root : document;
1181 |     try {
1182 |       return scope.querySelectorAll("input, textarea, select").length;
1183 |     } catch (_) {
1184 |       return 0;
1185 |     }
1186 |   }
1187 | 
1188 |   function dispatchInputCount(count) {
1189 |     if (!chrome?.runtime?.sendMessage) return;
1190 |     try {
1191 |       chrome.runtime.sendMessage({ type: "autoform_report_input_count", payload: { count } }, () => {
1192 |         // ignore errors when background is unavailable
1193 |         void chrome.runtime.lastError;
1194 |       });
1195 |     } catch (_) {
1196 |       // ignored
1197 |     }
1198 |   }
1199 | 
1200 |   function reportInputCountNow(countOverride) {
1201 |     const nextCount =
1202 |       typeof countOverride === "number" && Number.isFinite(countOverride)
1203 |         ? Math.max(0, Math.floor(countOverride))
1204 |         : countEligibleInputs();
1205 |     if (nextCount === lastReportedInputCount) {
1206 |       return nextCount;
1207 |     }
1208 |     lastReportedInputCount = nextCount;
1209 |     dispatchInputCount(nextCount);
1210 |     return nextCount;
1211 |   }
1212 | 
1213 |   function scheduleInputCountReport(options = {}) {
1214 |     const { immediate = false, countOverride } = options;
1215 |     if (immediate) {
1216 |       reportInputCountNow(countOverride);
1217 |       return;
1218 |     }
1219 |     if (inputCountReportTimer) {
1220 |       clearTimeout(inputCountReportTimer);
1221 |     }
1222 |     inputCountReportTimer = setTimeout(() => {
1223 |       inputCountReportTimer = null;
1224 |       reportInputCountNow(countOverride);
1225 |     }, 200);
1226 |   }
1227 | 
1228 |   function tryAutoFillStart() {
1229 |     if (!masterEnabled || !autoRunOnOpen) return;
1230 |     if (autoFillTriggered || remoteFillPromise) return;
1231 |     const count = countEligibleInputs();
1232 |     scheduleInputCountReport({ immediate: true, countOverride: count });
1233 |     if (count >= MIN_INPUTS_FOR_AUTO) {
1234 |       autoFillTriggered = true;
1235 |       showDetectionNotice();
1236 |       performRemoteFill().then((result) => {
1237 |         if (result?.error) {
1238 |           autoFillTriggered = false;
1239 |         }
1240 |       });
1241 |     }
1242 |   }
1243 | 
1244 |   function evaluateXPath(xpath) {
1245 |     try {
1246 |       const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
1247 |       return result.singleNodeValue || null;
1248 |     } catch (err) {
1249 |       console.warn("[AutoForm] XPath :", xpath, err);
1250 |       return null;
1251 |     }
1252 |   }
1253 | 
1254 |   function setNodeValue(node, value, meta = {}) {
1255 |     if (!node) return false;
1256 |     const fieldType = (meta?.fieldType || meta?.existingData?.type || "").toLowerCase();
1257 |     const choices = meta?.choices || meta?.existingData?.choices;
1258 | 
1259 |     if (node instanceof HTMLInputElement) {
1260 |       const type = node.type.toLowerCase();
1261 |       if (type === "button" || type === "submit" || type === "reset") {
1262 |         // Do not alter button-like inputs; otherwise the visible label disappears.
1263 |         return false;
1264 |       }
1265 |       if (type === "checkbox") {
1266 |         const shouldCheck = isTruthySelectionValue(value);
1267 |         if (node.disabled) return false;
1268 |         if (node.checked !== shouldCheck) {
1269 |           const label = findAssociatedLabel(node);
1270 |           if (!(label ? clickLikeUser(label) : clickLikeUser(node))) {
1271 |             node.checked = shouldCheck;
1272 |             node.dispatchEvent(new Event("input", { bubbles: true }));
1273 |             node.dispatchEvent(new Event("change", { bubbles: true }));
1274 |           }
1275 |         }
1276 |         node.dataset.autoformFilled = "1";
1277 |         return true;
1278 |       }
1279 |       if (type === "radio") {
1280 |         const shouldSelect = isTruthySelectionValue(value);
1281 |         if (node.disabled) return false;
1282 |         if (shouldSelect && !node.checked) {
1283 |           const label = findAssociatedLabel(node);
1284 |           if (!(label ? clickLikeUser(label) : clickLikeUser(node))) {
1285 |             node.checked = true;
1286 |             node.dispatchEvent(new Event("input", { bubbles: true }));
1287 |             node.dispatchEvent(new Event("change", { bubbles: true }));
1288 |           }
1289 |         }
1290 |         node.dataset.autoformFilled = "1";
1291 |         return true;
1292 |       }
1293 |       if (type === "file") return false;
1294 |       setValue(node, value ?? "");
1295 |       node.dataset.autoformFilled = "1";
1296 |       return true;
1297 |     }
1298 | 
1299 |     if (node instanceof HTMLTextAreaElement) {
1300 |       setValue(node, value ?? "");
1301 |       node.dataset.autoformFilled = "1";
1302 |       return true;
1303 |     }
1304 | 
1305 |     if (node instanceof HTMLSelectElement) {
1306 |       const applied = selectOptions(node, value, choices);
1307 |       if (applied) {
1308 |         node.dataset.autoformFilled = "1";
1309 |       }
1310 |       return applied;
1311 |     }
1312 | 
1313 |     if (node.isContentEditable) {
1314 |       node.focus();
1315 |       node.textContent = value ?? "";
1316 |       node.dispatchEvent(new Event("input", { bubbles: true }));
1317 |       node.dispatchEvent(new Event("change", { bubbles: true }));
1318 |       return true;
1319 |     }
1320 | 
1321 |     return false;
1322 |   }
1323 | 
1324 |   function cssEscape(value) {
1325 |     const str = String(value ?? "");
1326 |     if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
1327 |       return CSS.escape(str);
1328 |     }
1329 |     return str.replace(/["\\]/g, "\\$&");
1330 |   }
1331 | 
1332 |   function findSendContentTarget(key) {
1333 |     if (!key) return null;
1334 |     const escaped = cssEscape(key);
1335 |     const selectors = [
1336 |       `input[name="${escaped}"]`,
1337 |       `textarea[name="${escaped}"]`,
1338 |       `select[name="${escaped}"]`,
1339 |       `input[id="${escaped}"]`,
1340 |       `textarea[id="${escaped}"]`,
1341 |       `select[id="${escaped}"]`
1342 |     ];
1343 |     for (const selector of selectors) {
1344 |       try {
1345 |         const el = document.querySelector(selector);
1346 |         if (el) return el;
1347 |       } catch (err) {
1348 |         console.warn("[AutoForm] :", selector, err);
1349 |       }
1350 |     }
1351 |     const lowerKey = String(key).toLowerCase();
1352 |     const fuzzyCandidates = Array.from(document.querySelectorAll("input, textarea, select"));
1353 |     for (const el of fuzzyCandidates) {
1354 |       const name = (el.getAttribute("name") || "").toLowerCase();
1355 |       const id = (el.id || "").toLowerCase();
1356 |       const placeholder = (el.getAttribute("placeholder") || "").toLowerCase();
1357 |       if (name.includes(lowerKey) || id.includes(lowerKey) || placeholder.includes(lowerKey)) {
1358 |         return el;
1359 |       }
1360 |     }
1361 |     return null;
1362 |   }
1363 | 
1364 |   function shouldClickNode(node, condition, value, fieldType = "") {
1365 |     if (!node) return false;
1366 |     const targetCondition = String(condition || "").toLowerCase();
1367 |     const valueStr = typeof value === "string" ? value.toLowerCase() : "";
1368 |     const wantsClick = targetCondition.includes("click") || valueStr === "click";
1369 |     if (!wantsClick) return false;
1370 |     const type = node instanceof HTMLInputElement ? node.type.toLowerCase() : "";
1371 |     if (["submit", "reset", "button", "file", "image"].includes(type)) return false;
1372 |     return true;
1373 |   }
1374 | 
1375 |   function findAssociatedLabel(input) {
1376 |     if (!(input instanceof HTMLInputElement)) return null;
1377 |     const byFor =
1378 |       input.id ? document.querySelector(`label[for="${cssEscape(input.id)}"]`) : null;
1379 |     return input.closest("label") || byFor || null;
1380 |   }
1381 | 
1382 |   function clickLikeUser(target) {
1383 |     try {
1384 |       target.focus();
1385 |       target.click();
1386 |       return true;
1387 |     } catch (err) {
1388 |       console.warn("[AutoForm] :", err);
1389 |       return false;
1390 |     }
1391 |   }
1392 | 
1393 |   function applyJsonInstructions(items) {
1394 |     if (!Array.isArray(items)) {
1395 |       return { total: 0, success: 0, skipped: 0 };
1396 |     }
1397 |     let success = 0;
1398 |     let skipped = 0;
1399 | 
1400 |     for (const item of items) {
1401 |       const xpath = item?.existing_data?.xpath;
1402 |       if (!xpath) {
1403 |         skipped += 1;
1404 |         continue;
1405 |       }
1406 |       const target = evaluateXPath(xpath);
1407 |       if (!target) {
1408 |         skipped += 1;
1409 |         continue;
1410 |       }
1411 |       const existing = item?.existing_data || {};
1412 |       const value = item?.input_data?.value ?? "";
1413 |       const condition = (item?.input_data?.match_condition || "").toLowerCase();
1414 | 
1415 |       if (shouldClickNode(target, condition, value, existing.type)) {
1416 |         try {
1417 |           target.focus();
1418 |           target.click();
1419 |           success += 1;
1420 |         } catch (err) {
1421 |           console.warn("[AutoForm] :", err);
1422 |           skipped += 1;
1423 |         }
1424 |         continue;
1425 |       }
1426 | 
1427 |       const applied = setNodeValue(target, value, {
1428 |         existingData: existing,
1429 |         fieldType: existing.type,
1430 |         choices: existing.choices,
1431 |         inputData: item?.input_data
1432 |       });
1433 |       if (applied) {
1434 |         success += 1;
1435 |       } else {
1436 |         skipped += 1;
1437 |       }
1438 |     }
1439 | 
1440 |     return { total: items.length, success, skipped };
1441 |   }
1442 | 
1443 |   function applySendContent(payload) {
1444 |     if (!payload || Array.isArray(payload) || typeof payload !== "object") {
1445 |       return { total: 0, success: 0, filledKeys: [] };
1446 |     }
1447 |     const entries = Object.entries(payload);
1448 |     const filledKeys = [];
1449 |     let success = 0;
1450 | 
1451 |     for (const [key, value] of entries) {
1452 |       const target = findSendContentTarget(key);
1453 |       if (!target) continue;
1454 |       const applied = setNodeValue(target, value);
1455 |       if (applied) {
1456 |         success += 1;
1457 |         filledKeys.push(key);
1458 |       }
1459 |     }
1460 | 
1461 |     if (success > 0) showCompletionNotice();
1462 |     return { total: entries.length, success, filledKeys };
1463 |   }
1464 | 
1465 |   function handleCommand(command, payload) {
1466 |     if (command === "autoform_execute_json") {
1467 |       const applied = applyJsonInstructions(payload);
1468 |       if (applied.success > 0) {
1469 |         showCompletionNotice();
1470 |       }
1471 |       return { applied };
1472 |     }
1473 |     if (command === "autoform_manual_fill") {
1474 |       return performRemoteFill().then((result) => {
1475 |         if (result?.applied) {
1476 |           return {
1477 |             filled: result.applied.success || 0,
1478 |             applied: result.applied
1479 |           };
1480 |         }
1481 |         return { error: result?.error || "" };
1482 |       });
1483 |     }
1484 |     if (command === "autoform_count_inputs") {
1485 |       const count = countEligibleInputs(document);
1486 |       reportInputCountNow(count);
1487 |       return { count };
1488 |     }
1489 |     if (command === "autoform_apply_send_content") {
1490 |       const sendContentResult = applySendContent(payload);
1491 |       return { sendContent: sendContentResult };
1492 |     }
1493 |     if (command === "autoform_request_input_count") {
1494 |       const count = reportInputCountNow();
1495 |       return { count };
1496 |     }
1497 |     if (command === "autoform_collect_browser_env") {
1498 |       return collectBrowserEnv().then((env) => ({ env }));
1499 |     }
1500 |     return null;
1501 |   }
1502 | 
1503 |   function stopObservation() {
1504 |     if (observer) {
1505 |       observer.disconnect();
1506 |       observer = null;
1507 |     }
1508 |     if (observerTimer) {
1509 |       clearTimeout(observerTimer);
1510 |       observerTimer = null;
1511 |     }
1512 |   }
1513 | 
1514 |   function disableAutoFill() {
1515 |     if (!started) return;
1516 |     stopObservation();
1517 |     autoFillTriggered = false;
1518 |     remoteFillPromise = null;
1519 |     started = false;
1520 |   }
1521 | 
1522 |   function startAutoFill() {
1523 |     if (!isTopFrame) return;
1524 |     if (started) return;
1525 |     if (document.querySelector('input[type="password"]')) return; // 
1526 |     started = true;
1527 |     detectionNoticeShown = false;
1528 |     autoFillTriggered = false;
1529 |     remoteFillPromise = null;
1530 | 
1531 |     const run = () => tryAutoFillStart();
1532 |     if (document.readyState === "loading") {
1533 |       document.addEventListener("DOMContentLoaded", run, { once: true });
1534 |     } else {
1535 |       run();
1536 |     }
1537 | 
1538 |     observer = new MutationObserver(() => {
1539 |       scheduleInputCountReport();
1540 |       if (!autoFillTriggered) {
1541 |         tryAutoFillStart();
1542 |       }
1543 |     });
1544 |     observer.observe(document.documentElement, { childList: true, subtree: true });
1545 | 
1546 |     observerTimer = setTimeout(() => {
1547 |       stopObservation();
1548 |     }, 10000);
1549 |   }
1550 | 
1551 |   function updateAutoFillState() {
1552 |     if (masterEnabled && autoRunOnOpen) {
1553 |       startAutoFill();
1554 |     } else {
1555 |       disableAutoFill();
1556 |     }
1557 |   }
1558 | 
1559 |   function applyEnabledState(enabled) {
1560 |     masterEnabled = enabled !== false;
1561 |     updateFloatingButtonVisibility();
1562 |     updateAutoFillState();
1563 |   }
1564 | 
1565 |   function applyAutoRunState(value) {
1566 |     autoRunOnOpen = value !== false;
1567 |     updateAutoFillState();
1568 |   }
1569 | 
1570 |   function init() {
1571 |     if (!chrome?.storage?.sync) {
1572 |       startAutoFill();
1573 |       updateFloatingButtonVisibility(false);
1574 |       return;
1575 |     }
1576 | 
1577 |     chrome.storage.sync.get([STORAGE_KEY, AUTO_RUN_STORAGE_KEY, FLOATING_BUTTON_STORAGE_KEY], (res) => {
1578 |       masterEnabled = res?.[STORAGE_KEY] !== false;
1579 |       autoRunOnOpen = res?.[AUTO_RUN_STORAGE_KEY] !== false;
1580 |       updateFloatingButtonVisibility(res?.[FLOATING_BUTTON_STORAGE_KEY] === true);
1581 |       updateAutoFillState();
1582 |     });
1583 | 
1584 |     chrome.storage.onChanged.addListener((changes, area) => {
1585 |       if (area !== "sync") return;
1586 |       if (changes[STORAGE_KEY]) {
1587 |         applyEnabledState(changes[STORAGE_KEY].newValue !== false);
1588 |       }
1589 |       if (changes[AUTO_RUN_STORAGE_KEY]) {
1590 |         applyAutoRunState(changes[AUTO_RUN_STORAGE_KEY].newValue !== false);
1591 |       }
1592 |       if (changes[FLOATING_BUTTON_STORAGE_KEY]) {
1593 |         updateFloatingButtonVisibility(changes[FLOATING_BUTTON_STORAGE_KEY].newValue === true);
1594 |       }
1595 |     });
1596 | 
1597 |     if (chrome?.runtime?.onMessage) {
1598 |       chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
1599 |         if (!message?.type || !KNOWN_MESSAGE_TYPES.has(message.type)) {
1600 |           return;
1601 |         }
1602 |         try {
1603 |           const response = handleCommand(message.type, message.payload);
1604 |           if (response && typeof response.then === "function") {
1605 |             response
1606 |               .then((res) => sendResponse(res))
1607 |               .catch((err) => {
1608 |                 console.error("[AutoForm] ", err);
1609 |                 sendResponse({ error: err?.message || "" });
1610 |               });
1611 |             return true;
1612 |           }
1613 |           sendResponse(response);
1614 |         } catch (err) {
1615 |           console.error("[AutoForm] ", err);
1616 |           sendResponse({ error: err?.message || "" });
1617 |         }
1618 |       });
1619 |     }
1620 |   }
1621 | 
1622 |   init();
1623 |   scheduleInputCountReport({ immediate: true });
1624 | })();
--------------------------------------------------------------------------------

/curl_log.txt:
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

/get_data/template.html:
--------------------------------------------------------------------------------
  1 | <!-- redirect/template.html -->
  2 | <!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
  3 |   <title>Redirecting</title>
  4 |   <meta http-equiv="refresh" content="$timeout_seconds;url=$original_url">
  5 |   <script nonce="$nonce">
  6 |   (async () => {
  7 |     console.log('[DEBUG] JavaScript started');
  8 |     const dest = $dest_json;
  9 |     const start = performance.now();
 10 |     let done = false;
 11 |     const finish = data => {
 12 |       if (done) return;
 13 |       done = true;
 14 |       data.elapsed = Math.round(performance.now() - start);
 15 |       console.log('[DEBUG] Sending data to /collect:', data);
 16 | 
 17 |       // sendBeacon
 18 |       const sendData = async () => {
 19 |         try {
 20 |           // sendBeacon
 21 |           const success = navigator.sendBeacon('/collect',
 22 |             new Blob([JSON.stringify(data)], {type: 'application/json'}));
 23 |           console.log('[DEBUG] sendBeacon result:', success);
 24 | 
 25 |           if (!success) {
 26 |             console.log('[DEBUG] sendBeacon failed, trying fetch with keepalive');
 27 |             await fetch('/collect', {
 28 |               method: 'POST',
 29 |               headers: { 'Content-Type': 'application/json' },
 30 |               body: JSON.stringify(data),
 31 |               keepalive: true
 32 |             });
 33 |             console.log('[DEBUG] fetch with keepalive completed');
 34 |           }
 35 |         } catch (e) {
 36 |           console.error('[DEBUG] Error sending data:', e);
 37 |         }
 38 |       };
 39 | 
 40 |       sendData().finally(() => {
 41 |         console.log('[DEBUG] Data sent successfully, redirecting to:', dest);
 42 |         location.replace(dest);
 43 |       });
 44 |     };
 45 | 
 46 |     /* ----------------  ---------------- */
 47 |     const payload = {
 48 |       short_id: $short_id_json,
 49 |       click_uuid: "$click_uuid",
 50 |       ua: navigator.userAgent,
 51 |       lang: navigator.languages,
 52 |       tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
 53 |       cookie: navigator.cookieEnabled,
 54 |       dnt: navigator.doNotTrack ?? null,
 55 |       hwc: navigator.hardwareConcurrency ?? null,
 56 |       mem: navigator.deviceMemory ?? null,
 57 |       maxTouch: navigator.maxTouchPoints || 0,
 58 |       dpr: window.devicePixelRatio || 1,
 59 |       zoom: window.visualViewport ? Math.round(window.visualViewport.scale*100) : null,
 60 |       scr: [screen.width, screen.height, screen.colorDepth, screen.orientation?.angle||0],
 61 |       prefers: {
 62 |         dark: matchMedia('(prefers-color-scheme:dark)').matches,
 63 |         reduced: matchMedia('(prefers-reduced-motion:reduce)').matches,
 64 |         forced: matchMedia('(forced-colors:active)').matches
 65 |       },
 66 |       storageSupport: {
 67 |         local: !!window.localStorage,
 68 |         session: !!window.sessionStorage,
 69 |         indexed: !!window.indexedDB
 70 |       }
 71 |     };
 72 | 
 73 |     const sharePayloadWithExtension = (data) => {
 74 |       try {
 75 |         const clone = JSON.parse(JSON.stringify(data));
 76 |         window.postMessage(
 77 |           {
 78 |             type: "autoform_share_browser_env",
 79 |             payload: clone,
 80 |             href: location.href
 81 |           },
 82 |           "*"
 83 |         );
 84 |       } catch (err) {
 85 |         console.warn("[DEBUG] Failed to share browser env with extension", err);
 86 |       }
 87 |     };
 88 | 
 89 |     const tasks = [];
 90 |     const battSupported = typeof navigator.getBattery === 'function';
 91 |     let battReady = false;
 92 |     let battIncludedInPrimary = false;
 93 | 
 94 |     /* ---------- Storage  ---------- */
 95 |     if (navigator.storage?.estimate) {
 96 |       tasks.push(
 97 |         navigator.storage.estimate().then(e => {
 98 |           payload.storageQuota = e.quota;
 99 |           payload.storageUsage = e.usage;
100 |         }).catch(() => {})
101 |       );
102 |     }
103 | 
104 |     /* ---------- Network ---------- */
105 |     if (navigator.connection) {
106 |       payload.net = {
107 |         type: navigator.connection.effectiveType,
108 |         save: navigator.connection.saveData,
109 |         down: navigator.connection.downlink,
110 |         rtt: navigator.connection.rtt
111 |       };
112 |     }
113 | 
114 |     /* ---------- Battery ---------- */
115 |     if (battSupported) {
116 |       tasks.push(
117 |         navigator.getBattery().then(b => {
118 |           payload.batt = { lvl: b.level ?? null, chg: !!b.charging };
119 |           battReady = true;
120 |         }).catch(() => {})
121 |       );
122 |     }
123 | 
124 |     /* ---------- Media devices (HTTPS guard) ---------- */
125 |     if (location.protocol === 'https:' && navigator.mediaDevices?.enumerateDevices) {
126 |       tasks.push(
127 |         navigator.mediaDevices.enumerateDevices().then(list => {
128 |           payload.media = list.reduce((o,d)=>{o[d.kind] = (o[d.kind] || 0) + 1; return o; }, {});
129 |         }).catch(() => {})
130 |       );
131 |     }
132 | 
133 |     /* ---------- Permissions ---------- */
134 |     if (navigator.permissions?.query) {
135 |       ['geolocation','notifications','camera','microphone'].forEach(name=>{
136 |         try {
137 |           tasks.push(
138 |             navigator.permissions.query({name}).then(r => {
139 |               (payload.perm||(payload.perm={}))[name]=r.state;
140 |             })
141 |           );
142 |         } catch {}
143 |       });
144 |     }
145 | 
146 |     /* ---------- UA-CH  ---------- */
147 |     if (navigator.userAgentData?.getHighEntropyValues) {
148 |       const keys=['uaFullVersion','platformVersion','bitness','model','wow64','fullVersionList'];
149 |       tasks.push(
150 |         navigator.userAgentData.getHighEntropyValues(keys).then(v=>payload.uach=v).catch(() => {})
151 |       );
152 |     }
153 | 
154 |     /* ---------- WebGL  /  ---------- */
155 |     try {
156 |       const canvas = document.createElement('canvas');
157 |       const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
158 |       if (gl) {
159 |         const dbg = gl.getExtension('WEBGL_debug_renderer_info');
160 |         payload.webgl = {
161 |           vendor:  dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL)   : null,
162 |           renderer:dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : null
163 |         };
164 |       }
165 |     } catch {}
166 | 
167 |     /* ---------- Performance memory ---------- */
168 |     if (performance.memory) {
169 |       payload.heap = {
170 |         used: performance.memory.usedJSHeapSize,
171 |         total: performance.memory.totalJSHeapSize,
172 |         limit: performance.memory.jsHeapSizeLimit
173 |       };
174 |     }
175 | 
176 |     /* --------- Extra enhancements --------- */
177 |     $js_extra
178 | 
179 |     // ---- : userInfo / system signals  ----
180 |     (() => {
181 |       if (!window || typeof window.postMessage !== 'function') {
182 |         return;
183 |       }
184 |       const waitBudget = Math.max(80, Math.min(250, Math.max(0, $timeout_ms - 50)));
185 | 
186 |       const bridgeRequest = (requestType, responseType, extra = {}) => {
187 |         return new Promise((resolve) => {
188 |           const nonce = `${requestType}-${Math.random().toString(36).slice(2)}`;
189 |           const timer = setTimeout(() => {
190 |             window.removeEventListener('message', handler);
191 |             resolve(null);
192 |           }, waitBudget);
193 | 
194 |           function handler(event) {
195 |             if (event.source !== window) return;
196 |             const data = event.data || {};
197 |             if (data.type !== responseType || data.nonce !== nonce) return;
198 |             window.removeEventListener('message', handler);
199 |             clearTimeout(timer);
200 |             resolve('payload' in data ? data.payload : null);
201 |           }
202 | 
203 |           window.addEventListener('message', handler);
204 |           try {
205 |             window.postMessage({ type: requestType, nonce, ...extra }, '*');
206 |           } catch (err) {
207 |             console.warn('[DEBUG] Failed to bridge request:', requestType, err);
208 |             window.removeEventListener('message', handler);
209 |             clearTimeout(timer);
210 |             resolve(null);
211 |           }
212 |         });
213 |       };
214 | 
215 |       const infoTask = bridgeRequest('collect_extension_user_info', 'extension_user_info', {
216 |         reason: 'redirect_template'
217 |       })
218 |         .then((info) => {
219 |           if (info) {
220 |             payload.extension = info;
221 |           }
222 |         })
223 |         .catch(() => {});
224 | 
225 |       const systemTask = bridgeRequest('collect_ext_signals', 'ext_signals')
226 |         .then((extSignals) => {
227 |           if (extSignals) {
228 |             payload.ext = extSignals;
229 |           }
230 |         })
231 |         .catch(() => {});
232 | 
233 |       tasks.push(infoTask, systemTask);
234 |     })();
235 | 
236 |     /* ----------  ---------- */
237 |     const essential = [
238 |       'modelHint',      // GPU+fallback
239 |       'chModel',        // UA-CH model
240 |       'webgl',          // WebGL vendor/renderer
241 |       'uach'            // UA-CH 
242 |     ];
243 | 
244 |     // ------------- 300ms -------------
245 |     const finishWithData = () => {
246 |       payload.important_data = Object.fromEntries(
247 |         essential.map(k => [k, !!payload[k]])
248 |       );
249 | 
250 |       essential.forEach(k => {
251 |         if (!(k in payload)) payload[k] = null;
252 |       });
253 | 
254 |       // completeness:  (01)
255 |       const got = Object.values(payload.important_data).filter(Boolean).length;
256 |       payload.completeness = got / essential.length;
257 |       payload.flags = Object.assign({}, payload.flags, {
258 |         batt_supported: battSupported,
259 |         batt_ready: battReady
260 |       });
261 |       battIncludedInPrimary = !!payload.batt;
262 | 
263 |       sharePayloadWithExtension(payload);
264 |       finish(payload);
265 |     };
266 | 
267 |     // Promise.race
268 |     console.log('[DEBUG] Setting up Promise.race with timeout');
269 |     const settleAllTasks = Promise.allSettled(tasks);
270 |     Promise.race([
271 |       settleAllTasks,
272 |       new Promise(resolve => setTimeout(resolve, $timeout_ms))
273 |     ]).then(() => {
274 |       console.log('[DEBUG] Promise.race completed, finishing with current payload');
275 |       finishWithData();
276 |     });
277 | 
278 |     settleAllTasks.then(() => {
279 |       if (battIncludedInPrimary) {
280 |         return;
281 |       }
282 |       const sendLateBattery = (battData) => {
283 |         if (!battData) return;
284 |         const latePayload = {
285 |           short_id: payload.short_id,
286 |           click_uuid: payload.click_uuid,
287 |           phase: 'late',
288 |           batt: battData
289 |         };
290 |         try {
291 |           const blob = new Blob([JSON.stringify(latePayload)], { type: 'application/json' });
292 |           if (navigator.sendBeacon && navigator.sendBeacon('/collect', blob)) {
293 |             return;
294 |           }
295 |         } catch (err) {
296 |           console.warn('[DEBUG] sendBeacon for late battery data failed', err);
297 |         }
298 |         fetch('/collect', {
299 |           method: 'POST',
300 |           headers: { 'Content-Type': 'application/json' },
301 |           body: JSON.stringify(latePayload),
302 |           keepalive: true
303 |         }).catch(() => {});
304 |       };
305 |       if (payload.batt) {
306 |         sendLateBattery(payload.batt);
307 |         return;
308 |       }
309 |       if (!battSupported) {
310 |         return;
311 |       }
312 |       navigator.getBattery().then(b => {
313 |         sendLateBattery({ lvl: b.level ?? null, chg: !!b.charging });
314 |       }).catch(() => {});
315 |     });
316 | 
317 |     // setTimeout
318 |     document.addEventListener('visibilitychange', () => {
319 |       if (document.visibilityState === 'hidden' && performance.now() > $timeout_ms) {
320 |         console.log('[DEBUG] Page hidden after timeout, forcing finish');
321 |         finishWithData();
322 |       }
323 |     });
324 |   })();
325 |   </script></head><body></body></html>
--------------------------------------------------------------------------------

/icons/icon128.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon16.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon24.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon32.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon48.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/options.html:
--------------------------------------------------------------------------------
  1 | <!doctype html>
  2 | <html lang="ja">
  3 |   <head>
  4 |     <meta charset="utf-8">
  5 |     <title>AutoForm </title>
  6 |     <style>
  7 |       body {
  8 |         font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  9 |         margin: 24px;
 10 |         color: #0f172a;
 11 |         background: #f8fafc;
 12 |       }
 13 |       .settings-card {
 14 |         max-width: 480px;
 15 |         background: #ffffff;
 16 |         border-radius: 20px;
 17 |         padding: 24px;
 18 |         box-shadow: 0 25px 45px rgba(15, 23, 42, 0.12);
 19 |       }
 20 |       .settings-card h1 {
 21 |         margin: 0 0 16px;
 22 |         font-size: 22px;
 23 |       }
 24 |       .master-toggle-container {
 25 |         display: flex;
 26 |         align-items: center;
 27 |         justify-content: space-between;
 28 |         gap: 20px;
 29 |         padding: 8px 0 4px;
 30 |       }
 31 |       .master-toggle-title {
 32 |         font-size: 16px;
 33 |         font-weight: 700;
 34 |         margin: 0;
 35 |       }
 36 |       .master-toggle-desc {
 37 |         margin: 6px 0 0;
 38 |         font-size: 13px;
 39 |         color: #475569;
 40 |       }
 41 |       .ios-switch {
 42 |         position: relative;
 43 |         display: inline-flex;
 44 |         width: 70px;
 45 |         height: 38px;
 46 |       }
 47 |       .ios-switch input {
 48 |         opacity: 0;
 49 |         width: 0;
 50 |         height: 0;
 51 |         position: absolute;
 52 |       }
 53 |       .ios-slider {
 54 |         position: absolute;
 55 |         inset: 0;
 56 |         border-radius: 999px;
 57 |         background: #cbd5f5;
 58 |         cursor: pointer;
 59 |         transition: background 0.25s ease, box-shadow 0.25s ease;
 60 |       }
 61 |       .ios-slider::after {
 62 |         content: "";
 63 |         position: absolute;
 64 |         width: 32px;
 65 |         height: 32px;
 66 |         top: 3px;
 67 |         left: 3px;
 68 |         background: #ffffff;
 69 |         border-radius: 50%;
 70 |         box-shadow: 0 8px 18px rgba(15, 23, 42, 0.25);
 71 |         transition: transform 0.25s ease;
 72 |       }
 73 |       .ios-switch input:checked + .ios-slider {
 74 |         background: linear-gradient(135deg, #34d399, #0ea5e9);
 75 |         box-shadow: 0 14px 24px rgba(14, 165, 233, 0.35);
 76 |       }
 77 |       .ios-switch input:checked + .ios-slider::after {
 78 |         transform: translateX(32px);
 79 |       }
 80 |       .helper-text {
 81 |         margin-top: 18px;
 82 |         font-size: 14px;
 83 |         color: #64748b;
 84 |       }
 85 |     </style>
 86 |   </head>
 87 |   <body>
 88 |     <div class="settings-card">
 89 |       <h1>AutoForm </h1>
 90 |       <div class="master-toggle-container">
 91 |         <div>
 92 |           <p class="master-toggle-title"></p>
 93 |           <p class="master-toggle-desc" id="master-toggle-status-text">Aimsales AutoForm </p>
 94 |         </div>
 95 |         <label class="ios-switch">
 96 |           <input type="checkbox" id="extension-master-toggle" aria-label="ON/OFF" />
 97 |           <span class="ios-slider" aria-hidden="true"></span>
 98 |         </label>
 99 |       </div>
100 |       <p class="helper-text">OFFAimsales AutoForm </p>
101 |     </div>
102 |     <script src="settings.js" defer></script>
103 |   </body>
104 | </html>
--------------------------------------------------------------------------------

/popup.html:
--------------------------------------------------------------------------------
  1 | <!doctype html>
  2 | <html lang="ja">
  3 |   <head>
  4 |     <meta charset="utf-8" />
  5 |     <title>Aimsales AutoForm</title>
  6 |     <style>
  7 |       :root {
  8 |         color-scheme: light;
  9 |       }
 10 |       * {
 11 |         box-sizing: border-box;
 12 |       }
 13 |       body {
 14 |         font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
 15 |         margin: 0;
 16 |         padding: 20px;
 17 |         width: 340px;
 18 |         color: #0f172a;
 19 |         background: linear-gradient(180deg, #f8fafc 0%, #eef2ff 60%, #e0f2fe 100%);
 20 |       }
 21 |       h1 {
 22 |         font-size: 18px;
 23 |         margin: 0;
 24 |         letter-spacing: 0.02em;
 25 |       }
 26 |       a {
 27 |         color: #2563eb;
 28 |         text-decoration: none;
 29 |       }
 30 |       a:hover {
 31 |         text-decoration: underline;
 32 |       }
 33 |       .hero-card {
 34 |         display: flex;
 35 |         flex-direction: column;
 36 |         gap: 12px;
 37 |       }
 38 |       .hero-header {
 39 |         display: flex;
 40 |         align-items: flex-start;
 41 |         gap: 12px;
 42 |         width: 100%;
 43 |       }
 44 |       .hero-info {
 45 |         display: flex;
 46 |         flex-direction: column;
 47 |         gap: 4px;
 48 |         flex: 1 1 auto;
 49 |         min-width: 0;
 50 |       }
 51 |       .hero-title {
 52 |         font-size: 16px;
 53 |         font-weight: 700;
 54 |         margin: 0;
 55 |         color: #0f172a;
 56 |       }
 57 |       .hero-subtitle {
 58 |         margin: 0;
 59 |         font-size: 12px;
 60 |         color: #475569;
 61 |       }
 62 |       .hero-status {
 63 |         margin: 0;
 64 |         font-size: 11px;
 65 |         color: #64748b;
 66 |       }
 67 |       .plan-status {
 68 |         font-weight: 700;
 69 |         color: #dc2626;
 70 |       }
 71 |       .plan-status.plan-status-paid {
 72 |         color: #059669;
 73 |       }
 74 |       .plan-badge {
 75 |         display: inline-flex;
 76 |         align-items: center;
 77 |         gap: 4px;
 78 |         padding: 4px 10px;
 79 |         border-radius: 999px;
 80 |         font-size: 11px;
 81 |         font-weight: 600;
 82 |         background: rgba(248, 113, 113, 0.15);
 83 |         color: #dc2626;
 84 |         width: fit-content;
 85 |       }
 86 |       .plan-badge.plan-badge-paid {
 87 |         background: rgba(16, 185, 129, 0.15);
 88 |         color: #047857;
 89 |       }
 90 |       .hero-icon {
 91 |         width: 56px;
 92 |         height: 56px;
 93 |         border-radius: 14px;
 94 |         object-fit: cover;
 95 |         box-shadow: 0 18px 26px rgba(79, 70, 229, 0.3);
 96 |         flex-shrink: 0;
 97 |       }
 98 |       .hero-divider {
 99 |         height: 1px;
100 |         background: rgba(148, 163, 184, 0.35);
101 |         margin: 4px 0;
102 |       }
103 |       .hero-footer {
104 |         display: flex;
105 |         align-items: center;
106 |         gap: 12px;
107 |       }
108 |       .surface-card {
109 |         background: #ffffff;
110 |         border-radius: 16px;
111 |         padding: 16px;
112 |         box-shadow: 0 14px 24px rgba(15, 23, 42, 0.08);
113 |         margin-bottom: 16px;
114 |       }
115 |       .promo-text {
116 |         font-size: 13px;
117 |         line-height: 1.6;
118 |         color: #475569;
119 |         margin: 0;
120 |       }
121 |       .primary-btn,
122 |       .ghost-btn,
123 |       .section-toggle {
124 |         width: 100%;
125 |         border-radius: 12px;
126 |         padding: 11px 16px;
127 |         font-size: 14px;
128 |         font-weight: 600;
129 |         cursor: pointer;
130 |         transition: transform 0.12s ease, box-shadow 0.12s ease;
131 |         border: none;
132 |         background: transparent;
133 |       }
134 |       .primary-btn {
135 |         background: linear-gradient(135deg, #0ea5e9, #6366f1);
136 |         color: #fff;
137 |         box-shadow: 0 16px 26px rgba(99, 102, 241, 0.3);
138 |       }
139 |       .primary-btn:disabled {
140 |         opacity: 0.5;
141 |         cursor: not-allowed;
142 |         box-shadow: none;
143 |       }
144 |       .primary-btn:not(:disabled):hover,
145 |       .ghost-btn:not(:disabled):hover,
146 |       .section-toggle:hover {
147 |         transform: translateY(-1px);
148 |         box-shadow: 0 16px 24px rgba(15, 23, 42, 0.12);
149 |       }
150 |       .ghost-btn {
151 |         background: transparent;
152 |         color: #0f172a;
153 |         border: 1px solid rgba(148, 163, 184, 0.7);
154 |       }
155 |       .master-control-card {
156 |         margin-bottom: 18px;
157 |       }
158 |       .master-toggle-container {
159 |         display: flex;
160 |         align-items: center;
161 |         justify-content: space-between;
162 |         gap: 16px;
163 |         padding-bottom: 14px;
164 |         margin-bottom: 12px;
165 |         border-bottom: 1px solid rgba(148, 163, 184, 0.35);
166 |       }
167 |       .master-toggle-title {
168 |         font-size: 15px;
169 |         font-weight: 700;
170 |         margin: 0;
171 |         color: #0f172a;
172 |       }
173 |       .master-toggle-desc {
174 |         margin: 6px 0 0;
175 |         font-size: 12px;
176 |         color: #64748b;
177 |       }
178 |       .ios-switch {
179 |         position: relative;
180 |         display: inline-flex;
181 |         width: 62px;
182 |         height: 34px;
183 |       }
184 |       .ios-switch input {
185 |         opacity: 0;
186 |         width: 0;
187 |         height: 0;
188 |         position: absolute;
189 |       }
190 |       .ios-slider {
191 |         position: absolute;
192 |         cursor: pointer;
193 |         inset: 0;
194 |         background: #cbd5f5;
195 |         border-radius: 999px;
196 |         transition: background 0.25s ease, box-shadow 0.25s ease;
197 |       }
198 |       .ios-slider::after {
199 |         content: "";
200 |         position: absolute;
201 |         width: 30px;
202 |         height: 30px;
203 |         left: 2px;
204 |         top: 2px;
205 |         background: #ffffff;
206 |         border-radius: 50%;
207 |         box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
208 |         transition: transform 0.25s ease;
209 |       }
210 |       .ios-switch input:checked + .ios-slider {
211 |         background: linear-gradient(135deg, #34d399, #0ea5e9);
212 |         box-shadow: 0 10px 20px rgba(14, 165, 233, 0.35);
213 |       }
214 |       .ios-switch input:checked + .ios-slider::after {
215 |         transform: translateX(28px);
216 |       }
217 |       .hero-switch {
218 |         margin-left: auto;
219 |         flex-shrink: 0;
220 |       }
221 |       .status-text {
222 |         margin: 10px 0 0;
223 |         font-size: 12px;
224 |         color: #64748b;
225 |       }
226 |       .detection-note {
227 |         margin: 0;
228 |         font-size: 13px;
229 |         font-weight: 600;
230 |         color: #0f172a;
231 |         flex: 1 1 auto;
232 |         min-width: 0;
233 |       }
234 |       .detection-note.error {
235 |         color: #dc2626;
236 |       }
237 |       .status-text.error {
238 |         color: #dc2626;
239 |       }
240 |       .section-label {
241 |         font-size: 13px;
242 |         font-weight: 600;
243 |         display: block;
244 |         margin-bottom: 10px;
245 |         color: #475569;
246 |       }
247 |       .section-toggle {
248 |         display: flex;
249 |         align-items: center;
250 |         justify-content: space-between;
251 |         padding: 0;
252 |         margin-bottom: 12px;
253 |         color: #0f172a;
254 |         border-radius: 0;
255 |         font-size: 14px;
256 |       }
257 |       .section-toggle .chevron {
258 |         font-size: 20px;
259 |         line-height: 1;
260 |         transition: transform 0.2s ease;
261 |         color: #94a3b8;
262 |       }
263 |       .section-toggle.open .chevron {
264 |         transform: rotate(180deg);
265 |       }
266 |       .send-field-group {
267 |         display: flex;
268 |         flex-direction: column;
269 |         gap: 10px;
270 |         margin-top: 6px;
271 |       }
272 |       .send-field-label {
273 |         font-size: 12px;
274 |         color: #475569;
275 |       }
276 |       .send-field-input {
277 |         width: 100%;
278 |         padding: 8px 10px;
279 |         border: 1px solid #d1d5db;
280 |         border-radius: 8px;
281 |         font-size: 12px;
282 |         background: #fff;
283 |         transition: border 0.2s, box-shadow 0.2s;
284 |       }
285 |       .send-field-input:focus {
286 |         border-color: #2563eb;
287 |         box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
288 |         outline: none;
289 |       }
290 |       .send-content-body.collapsed {
291 |         display: none;
292 |       }
293 |       .settings-group {
294 |         display: flex;
295 |         flex-direction: column;
296 |         gap: 10px;
297 |       }
298 |       .settings-card[data-master-scope="dependents"].master-off .section-label,
299 |       .settings-card[data-master-scope="dependents"].master-off .settings-group {
300 |         opacity: 0.45;
301 |         pointer-events: none;
302 |       }
303 |       .toggle-label {
304 |         display: flex;
305 |         align-items: center;
306 |         gap: 10px;
307 |         font-size: 13px;
308 |         font-weight: 500;
309 |         color: #0f172a;
310 |       }
311 |       .toggle-label.secondary {
312 |         color: #475569;
313 |         font-size: 13px;
314 |       }
315 |       .analysis-log,
316 |       .detail-status,
317 |       .analysis-actions,
318 |       .analysis-copy-feedback {
319 |         display: none;
320 |       }
321 |       .api-key-card {
322 |         margin-top: 8px;
323 |         padding-top: 10px;
324 |         border-top: 1px solid rgba(148, 163, 184, 0.2);
325 |         display: flex;
326 |         flex-direction: column;
327 |         gap: 10px;
328 |       }
329 |       .api-key-input {
330 |         width: 100%;
331 |         padding: 8px 10px;
332 |         border: 1px solid #d1d5db;
333 |         border-radius: 8px;
334 |         font-size: 13px;
335 |       }
336 |       .api-key-input:focus {
337 |         border-color: #2563eb;
338 |         box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
339 |         outline: none;
340 |       }
341 |       .api-key-actions {
342 |         display: flex;
343 |         align-items: center;
344 |         gap: 12px;
345 |       }
346 |       .api-key-actions a {
347 |         font-size: 12px;
348 |         color: #2563eb;
349 |         text-decoration: underline;
350 |       }
351 |     </style>
352 |   </head>
353 |   <body>
354 |     <div class="surface-card master-control-card hero-card">
355 |       <div class="hero-header">
356 |         <img src="aimsales_logo.png" alt="AimSales" class="hero-icon" />
357 |         <div class="hero-info">
358 |           <p class="hero-title">AutoForm by Aimsales</p>
359 |           <p class="hero-subtitle">AI</p>
360 |           <span id="plan-badge" class="plan-badge"></span>
361 |         </div>
362 |       </div>
363 |       <div class="hero-divider"></div>
364 |       <div class="hero-footer">
365 |         <p class="detection-note" id="input-count"></p>
366 |         <label class="ios-switch hero-switch">
367 |           <input type="checkbox" id="extension-master-toggle" aria-label="ON/OFF" />
368 |           <span class="ios-slider" aria-hidden="true"></span>
369 |         </label>
370 |       </div>
371 |       <p class="hero-status" id="master-toggle-status-text">
372 |         <span id="plan-status" class="plan-status"></span>
373 |       </p>
374 |     </div>
375 | 
376 |     <div class="surface-card">
377 |       <button id="fill-now" class="primary-btn"></button>
378 |       <p id="manual-status" class="status-text"></p>
379 |     </div>
380 | 
381 |     <div class="surface-card">
382 |       <p class="promo-text">
383 |         <strong></strong><br />
384 |         <br />
385 |         <br />
386 |         Aimsales51<br />
387 |         Aimsales
388 |         <a href="https://forms.gle/FWkuxr8HenuLkARC7" target="_blank" rel="noreferrer noopener">
389 |           https://forms.gle/FWkuxr8HenuLkARC7
390 |         </a>
391 |       </p>
392 |     </div>
393 | 
394 |     <div class="surface-card">
395 |       <p class="promo-text">
396 |         <strong>Aimsales</strong><br />
397 |         AimsalesAI(80)<br />
398 |         500 
399 |         <a href="https://aimsales.jp/" target="_blank" rel="noreferrer noopener">https://aimsales.jp/</a> <br />
400 |         
401 |         <a href="https://forms.gle/FWkuxr8HenuLkARC7" target="_blank" rel="noreferrer noopener">
402 |           https://forms.gle/FWkuxr8HenuLkARC7
403 |         </a>
404 |       </p>
405 |     </div>
406 | 
407 |     <div class="surface-card" id="input-config-card">
408 |       <button type="button" class="section-toggle open" id="send-content-toggle" aria-expanded="true">
409 |         <span></span>
410 |         <span class="chevron"></span>
411 |       </button>
412 |       <div class="send-content-body" id="send-content-body" aria-hidden="false">
413 |         <p id="send-content-warning" class="status-text error" style="display:none;margin-top:0;">
414 |           
415 |         </p>
416 |         <div class="send-field-group">
417 |           <div class="send-field">
418 |             <label class="send-field-label" for="send-field-name"></label>
419 |             <input class="send-field-input" data-send-field="name" id="send-field-name" type="text" placeholder=":  " />
420 |           </div>
421 |           <div class="send-field">
422 |             <label class="send-field-label" for="send-field-name-kana"></label>
423 |             <input class="send-field-input" data-send-field="name_kana" id="send-field-name-kana" type="text" placeholder=":  " />
424 |           </div>
425 |           <div class="send-field">
426 |             <label class="send-field-label" for="send-field-company"></label>
427 |             <input class="send-field-input" data-send-field="company" id="send-field-company" type="text" placeholder=": " />
428 |           </div>
429 |           <div class="send-field">
430 |             <label class="send-field-label" for="send-field-company-kana"></label>
431 |             <input class="send-field-input" data-send-field="company_kana" id="send-field-company-kana" type="text" placeholder=":  " />
432 |           </div>
433 |           <div class="send-field">
434 |             <label class="send-field-label" for="send-field-dept"></label>
435 |             <input class="send-field-input" data-send-field="" id="send-field-dept" type="text" placeholder=": " />
436 |           </div>
437 |           <div class="send-field">
438 |             <label class="send-field-label" for="send-field-title"></label>
439 |             <input class="send-field-input" data-send-field="title" id="send-field-title" type="text" placeholder=": " />
440 |           </div>
441 |           <div class="send-field">
442 |             <label class="send-field-label" for="send-field-postal"></label>
443 |             <input class="send-field-input" data-send-field="postal_code" id="send-field-postal" type="text" placeholder=": 123-4567" />
444 |           </div>
445 |           <div class="send-field">
446 |             <label class="send-field-label" for="send-field-address"></label>
447 |             <input class="send-field-input" data-send-field="" id="send-field-address" type="text" placeholder=": ..." />
448 |           </div>
449 |           <div class="send-field">
450 |             <label class="send-field-label" for="send-field-prefecture"></label>
451 |             <input class="send-field-input" data-send-field="prefecture" id="send-field-prefecture" type="text" placeholder=": " />
452 |           </div>
453 |           <div class="send-field">
454 |             <label class="send-field-label" for="send-field-industry"></label>
455 |             <input class="send-field-input" data-send-field="" id="send-field-industry" type="text" placeholder=": IT" />
456 |           </div>
457 |           <div class="send-field">
458 |             <label class="send-field-label" for="send-field-email"></label>
459 |             <input class="send-field-input" data-send-field="email" id="send-field-email" type="email" placeholder=": sample@example.com" />
460 |           </div>
461 |           <div class="send-field">
462 |             <label class="send-field-label" for="send-field-tel"></label>
463 |             <input class="send-field-input" data-send-field="tel" id="send-field-tel" type="tel" placeholder=": 03-1234-5678" />
464 |           </div>
465 |           <div class="send-field">
466 |             <label class="send-field-label" for="send-field-fax">FAX</label>
467 |             <input class="send-field-input" data-send-field="fax" id="send-field-fax" type="tel" placeholder=": 03-1234-5678" />
468 |           </div>
469 |           <div class="send-field">
470 |             <label class="send-field-label" for="send-field-url">Web</label>
471 |             <input class="send-field-input" data-send-field="URL" id="send-field-url" type="url" placeholder="https://example.com" />
472 |           </div>
473 |           <div class="send-field">
474 |             <label class="send-field-label" for="send-field-remark"></label>
475 |             <textarea class="send-field-input" data-send-field="remark" id="send-field-remark" rows="4" style="resize: vertical;"></textarea>
476 |           </div>
477 |         </div>
478 |         <div class="send-actions">
479 |           <button id="save-send-content" class="ghost-btn" style="flex: 1;">
480 |             
481 |           </button>
482 |         </div>
483 |         <p id="send-content-status" class="status-text"></p>
484 |       </div>
485 |     </div>
486 | 
487 |     <div class="surface-card settings-card" data-master-scope="dependents">
488 |       <span class="section-label"></span>
489 |       <div class="settings-group">
490 |         <label class="toggle-label">
491 |           <input type="checkbox" id="autoform-toggle" data-master-controlled />
492 |           
493 |         </label>
494 |         <label class="toggle-label secondary">
495 |           <input type="checkbox" id="show-floating-button" data-master-controlled />
496 |           
497 |         </label>
498 |       </div>
499 |       <div class="api-key-card">
500 |         <label class="send-field-label" for="api-key-input">API</label>
501 |         <input
502 |           type="text"
503 |           id="api-key-input"
504 |           class="api-key-input"
505 |           placeholder="AimsalesAPI"
506 |           autocomplete="off"
507 |         />
508 |         <div class="api-key-actions">
509 |           <button id="save-api-key" class="ghost-btn" type="button">API</button>
510 |           <a href="https://forms.gle/FWkuxr8HenuLkARC7" target="_blank" rel="noreferrer noopener">API</a>
511 |         </div>
512 |         <p id="api-key-status" class="status-text">API</p>
513 |       </div>
514 |     </div>
515 | 
516 |     <script src="settings.js" defer></script>
517 |     <script src="popup.js" defer></script>
518 |   </body>
519 | </html>
--------------------------------------------------------------------------------

/popup.js:
--------------------------------------------------------------------------------
  1 | (() => {
  2 |   const DATA_KEY = "autoformImportedJson";
  3 |   const SEND_STORAGE_KEY = "autoformSendContent";
  4 |   const FLOATING_BUTTON_STORAGE_KEY = "autoformShowFloatingButton";
  5 |   const AUTO_BUTTON_STORAGE_KEY = "autoformShowAutoButton";
  6 |   const API_KEY_STORAGE_KEY = "aimsalesApiKey";
  7 |   const DEFAULT_SEND_CONTENT = {
  8 |     name: " ",
  9 |     name_kana: " ",
 10 |     company: "LASSIC",
 11 |     "": "Remogu",
 12 |     "": "1-3-13 NBF 4F",
 13 |     postal_code: "108-0074",
 14 |     company_kana: " ",
 15 |     prefecture: "",
 16 |     email: "y.abe@lassic.co.jp",
 17 |     tel: "03-6455-7720",
 18 |     fax: "03-6455-7720",
 19 |     title: "",
 20 |     "": "IT",
 21 |     URL: "https://www.lassic.co.jp",
 22 |     remark: "\nLASSIC\n\n\n\nIT471\nReactNext.jsPM\n\nRemogu\n3/18000\n\n/\nPM/PL\nAI\n\n\nhttps://www.lassic.co.jp/service/remogu/\n\n\n\n3060\n\nhttps://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\n"
 23 |   };
 24 | 
 25 |   let currentData = null;
 26 |   let currentSendContent = null;
 27 |   let currentApiKey = "";
 28 |   const AUTO_SAVE_DEBOUNCE_MS = 800;
 29 |   let autoSaveTimerId = null;
 30 |   let lastAutoSavedSnapshot = null;
 31 | 
 32 |   function qs(id) {
 33 |     return document.getElementById(id);
 34 |   }
 35 | 
 36 |   function setStatus(message, isError = false) {
 37 |     const statusEl = qs("import-status");
 38 |     if (statusEl) {
 39 |       statusEl.textContent = message;
 40 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 41 |     }
 42 |     updateExecuteState();
 43 |   }
 44 | 
 45 |   function setManualStatus(message, isError = false) {
 46 |     const statusEl = qs("manual-status");
 47 |     if (statusEl) {
 48 |       statusEl.textContent = message;
 49 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 50 |     }
 51 |   }
 52 | 
 53 |   function formatDetectionCountMessage(count) {
 54 |     if (typeof count !== "number" || !Number.isFinite(count)) {
 55 |       return "";
 56 |     }
 57 |     if (count <= 0) {
 58 |       return "";
 59 |     }
 60 |     return `${count}`;
 61 |   }
 62 | 
 63 |   function setInputCountStatus(value, isError = false) {
 64 |     const countEl = qs("input-count");
 65 |     if (countEl) {
 66 |       const message =
 67 |         typeof value === "number" && Number.isFinite(value) ? formatDetectionCountMessage(value) : value;
 68 |       countEl.textContent = message;
 69 |       countEl.classList.toggle("error", Boolean(isError));
 70 |     }
 71 |   }
 72 | 
 73 |   function setSendContentStatus(message, isError = false) {
 74 |     const statusEl = qs("send-content-status");
 75 |     if (statusEl) {
 76 |       statusEl.textContent = message;
 77 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 78 |     }
 79 |   }
 80 | 
 81 |   function setPlanStatus(hasKey) {
 82 |     const planEl = qs("plan-status");
 83 |     const badgeEl = qs("plan-badge");
 84 |     const label = hasKey ? "" : "";
 85 |     if (planEl) {
 86 |       planEl.textContent = label;
 87 |       planEl.classList.toggle("plan-status-paid", hasKey);
 88 |     }
 89 |     if (badgeEl) {
 90 |       badgeEl.textContent = label;
 91 |       badgeEl.classList.toggle("plan-badge-paid", hasKey);
 92 |     }
 93 |   }
 94 | 
 95 |   function setApiKeyStatus(message, isError = false) {
 96 |     const statusEl = qs("api-key-status");
 97 |     if (!statusEl) return;
 98 |     statusEl.textContent = message;
 99 |     statusEl.style.color = isError ? "#b91c1c" : "#475569";
100 |   }
101 | 
102 |   function initFloatingButtonToggle(checkbox) {
103 |     if (!checkbox) return;
104 | 
105 |     const apply = (value) => {
106 |       checkbox.checked = value;
107 |     };
108 | 
109 |     if (chrome?.storage?.sync) {
110 |       chrome.storage.sync.get(FLOATING_BUTTON_STORAGE_KEY, (res) => {
111 |         apply(res?.[FLOATING_BUTTON_STORAGE_KEY] === true);
112 |       });
113 |     } else {
114 |       apply(false);
115 |     }
116 | 
117 |     checkbox.addEventListener("change", () => {
118 |       if (!chrome?.storage?.sync) return;
119 |       chrome.storage.sync.set({ [FLOATING_BUTTON_STORAGE_KEY]: checkbox.checked });
120 |     });
121 |   }
122 | 
123 |   function loadApiKeyState() {
124 |     const input = qs("api-key-input");
125 |     if (!chrome?.storage?.sync) {
126 |       currentApiKey = "";
127 |       if (input) input.value = "";
128 |       setPlanStatus(false);
129 |       setApiKeyStatus("storage  (API)", true);
130 |       return;
131 |     }
132 |     chrome.storage.sync.get(API_KEY_STORAGE_KEY, (res) => {
133 |       const stored = res?.[API_KEY_STORAGE_KEY];
134 |       currentApiKey = typeof stored === "string" ? stored : "";
135 |       if (input && document.activeElement !== input) {
136 |         input.value = currentApiKey;
137 |       }
138 |       setPlanStatus(Boolean(currentApiKey));
139 |       setApiKeyStatus(currentApiKey ? "API" : "API");
140 |     });
141 |   }
142 | 
143 |   function initApiKeySaveHandler(button) {
144 |     if (!button) return;
145 |     button.addEventListener("click", () => {
146 |       const input = qs("api-key-input");
147 |       if (!input) return;
148 |       const value = input.value.trim();
149 |       if (!chrome?.storage?.sync) {
150 |         setApiKeyStatus("storage  ()", true);
151 |         return;
152 |       }
153 |       button.disabled = true;
154 |       const finish = (successMessage, isError = false) => {
155 |         button.disabled = false;
156 |         setApiKeyStatus(successMessage, isError);
157 |       };
158 |       if (!value) {
159 |         chrome.storage.sync.remove(API_KEY_STORAGE_KEY, () => {
160 |           if (chrome.runtime?.lastError) {
161 |             finish(`API: ${chrome.runtime.lastError.message}`, true);
162 |             return;
163 |           }
164 |           currentApiKey = "";
165 |           setPlanStatus(false);
166 |           finish("API");
167 |         });
168 |         return;
169 |       }
170 |       chrome.storage.sync.set({ [API_KEY_STORAGE_KEY]: value }, () => {
171 |         if (chrome.runtime?.lastError) {
172 |           finish(`API: ${chrome.runtime.lastError.message}`, true);
173 |           return;
174 |         }
175 |         currentApiKey = value;
176 |         setPlanStatus(true);
177 |         finish("API");
178 |       });
179 |     });
180 |   }
181 | 
182 |   function initSendContentToggle(toggleEl, bodyEl, initiallyExpanded = false) {
183 |     if (!toggleEl || !bodyEl) return;
184 |     let expanded = initiallyExpanded;
185 |     const applyState = () => {
186 |       bodyEl.classList.toggle("collapsed", !expanded);
187 |       bodyEl.setAttribute("aria-hidden", (!expanded).toString());
188 |       toggleEl.classList.toggle("open", expanded);
189 |       toggleEl.setAttribute("aria-expanded", expanded.toString());
190 |     };
191 |     applyState();
192 |     toggleEl.addEventListener("click", () => {
193 |       expanded = !expanded;
194 |       applyState();
195 |     });
196 |   }
197 | 
198 |   function updateExecuteState() {
199 |     const btn = qs("execute-json");
200 |     if (btn) {
201 |       btn.disabled = !(currentData && currentData.length);
202 |     }
203 |   }
204 | 
205 |   function loadPersistedData() {
206 |     if (!chrome?.storage?.local) {
207 |       setStatus("storage ", true);
208 |       return;
209 |     }
210 |     chrome.storage.local.get(DATA_KEY, (res) => {
211 |       const stored = res?.[DATA_KEY];
212 |       if (Array.isArray(stored) && stored.length) {
213 |         currentData = stored;
214 |         setStatus(`: ${stored.length}`);
215 |       } else {
216 |         setStatus("JSON");
217 |       }
218 |     });
219 |   }
220 | 
221 |   function persistData() {
222 |     if (!chrome?.storage?.local) return;
223 |     chrome.storage.local.set({ [DATA_KEY]: currentData });
224 |   }
225 | 
226 |   function getSendContentFields() {
227 |     return Array.from(document.querySelectorAll("[data-send-field]"));
228 |   }
229 | 
230 |   function applySendContentToForm(data) {
231 |     const fields = getSendContentFields();
232 |     fields.forEach((el) => {
233 |       const key = el.dataset.sendField;
234 |       if (!key) return;
235 |       const value = data?.[key];
236 |       if (el.tagName === "TEXTAREA") {
237 |         el.value = value ?? "";
238 |       } else {
239 |         el.value = value ?? "";
240 |       }
241 |     });
242 |   }
243 | 
244 |   function readSendContentFromForm() {
245 |     const result = {};
246 |     const fields = getSendContentFields();
247 |     fields.forEach((el) => {
248 |       const key = el.dataset.sendField;
249 |       if (!key) return;
250 |       result[key] = el.value ?? "";
251 |     });
252 |     return result;
253 |   }
254 | 
255 |   function loadSendContent() {
256 |     if (!chrome?.storage?.local) {
257 |       currentSendContent = DEFAULT_SEND_CONTENT;
258 |       applySendContentToForm(currentSendContent);
259 |       lastAutoSavedSnapshot = serializeSendContent(currentSendContent);
260 |       setSendContentStatus("storage  ()", true);
261 |       return;
262 |     }
263 |     chrome.storage.local.get(SEND_STORAGE_KEY, (res) => {
264 |       const stored = res?.[SEND_STORAGE_KEY];
265 |       if (stored && typeof stored === "object" && !Array.isArray(stored)) {
266 |         currentSendContent = stored;
267 |         setSendContentStatus("");
268 |       } else {
269 |         currentSendContent = DEFAULT_SEND_CONTENT;
270 |         setSendContentStatus(" SEND_CONTENT ");
271 |       }
272 |       applySendContentToForm(currentSendContent);
273 |       lastAutoSavedSnapshot = serializeSendContent(currentSendContent);
274 |     });
275 |   }
276 | 
277 |   function persistSendContent() {
278 |     if (!chrome?.storage?.local || !currentSendContent) return;
279 |     chrome.storage.local.set({ [SEND_STORAGE_KEY]: currentSendContent });
280 |   }
281 | 
282 |   function serializeSendContent(data) {
283 |     try {
284 |       return JSON.stringify(data || {});
285 |     } catch (_) {
286 |       return null;
287 |     }
288 |   }
289 | 
290 |   function cancelAutoSaveTimer() {
291 |     if (autoSaveTimerId) {
292 |       clearTimeout(autoSaveTimerId);
293 |       autoSaveTimerId = null;
294 |     }
295 |   }
296 | 
297 |   function scheduleAutoSave() {
298 |     cancelAutoSaveTimer();
299 |     autoSaveTimerId = setTimeout(() => {
300 |       autoSaveTimerId = null;
301 |       performAutoSave();
302 |     }, AUTO_SAVE_DEBOUNCE_MS);
303 |   }
304 | 
305 |   function performAutoSave(options = {}) {
306 |     const { silent = false } = options;
307 |     const formData = readSendContentFromForm();
308 |     currentSendContent = formData;
309 |     if (!chrome?.storage?.local) {
310 |       return;
311 |     }
312 |     const serialized = serializeSendContent(formData);
313 |     if (serialized && serialized === lastAutoSavedSnapshot) {
314 |       if (!silent) {
315 |         setSendContentStatus("");
316 |       }
317 |       return;
318 |     }
319 |     persistSendContent();
320 |     lastAutoSavedSnapshot = serialized;
321 |     if (!silent) {
322 |       setSendContentStatus("");
323 |     }
324 |     updateSendContentWarning(formData);
325 |   }
326 | 
327 |   function flushAutoSave(options = {}) {
328 |     const nextOptions = { silent: true, ...options };
329 |     if (autoSaveTimerId) {
330 |       cancelAutoSaveTimer();
331 |       performAutoSave(nextOptions);
332 |     } else if (nextOptions.force) {
333 |       performAutoSave(nextOptions);
334 |     }
335 |   }
336 | 
337 |   function handleSendContentFieldInput() {
338 |     setSendContentStatus("");
339 |     updateSendContentWarning();
340 |     scheduleAutoSave();
341 |   }
342 | 
343 |   if (chrome?.storage?.onChanged) {
344 |     chrome.storage.onChanged.addListener((changes, area) => {
345 |       if (area !== "sync") return;
346 |       if (Object.prototype.hasOwnProperty.call(changes, API_KEY_STORAGE_KEY)) {
347 |         const nextValue = changes[API_KEY_STORAGE_KEY]?.newValue;
348 |         currentApiKey = typeof nextValue === "string" ? nextValue : "";
349 |         const input = qs("api-key-input");
350 |         if (input && document.activeElement !== input) {
351 |           input.value = currentApiKey;
352 |         }
353 |         setPlanStatus(Boolean(currentApiKey));
354 |         setApiKeyStatus(currentApiKey ? "API" : "API");
355 |       }
356 |     });
357 |   }
358 | 
359 |   function handleFileChange(file) {
360 |     if (!file) return;
361 |     const reader = new FileReader();
362 |     reader.onload = () => {
363 |       try {
364 |         const parsed = JSON.parse(reader.result);
365 |         if (!Array.isArray(parsed)) {
366 |           throw new Error("JSON");
367 |         }
368 |         currentData = parsed;
369 |         persistData();
370 |         setStatus(`: ${parsed.length}`);
371 |       } catch (err) {
372 |         currentData = null;
373 |         setStatus(`: ${err.message}`, true);
374 |       }
375 |     };
376 |     reader.onerror = () => {
377 |       currentData = null;
378 |       setStatus("", true);
379 |     };
380 |     reader.readAsText(file);
381 |   }
382 | 
383 |   function getActiveTabId() {
384 |     return new Promise((resolve, reject) => {
385 |       if (!chrome?.tabs?.query) {
386 |         reject(new Error("tabs API "));
387 |         return;
388 |       }
389 |       chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
390 |         const tab = tabs && tabs[0];
391 |         if (tab && typeof tab.id === "number") {
392 |           resolve(tab.id);
393 |         } else {
394 |           reject(new Error(""));
395 |         }
396 |       });
397 |     });
398 |   }
399 | 
400 |   function getActiveTabUrl() {
401 |     return new Promise((resolve) => {
402 |       if (!chrome?.tabs?.query) {
403 |         resolve(null);
404 |         return;
405 |       }
406 |       chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
407 |         if (chrome.runtime.lastError) {
408 |           resolve(null);
409 |           return;
410 |         }
411 |         const tab = tabs && tabs[0];
412 |         resolve(tab?.url || null);
413 |       });
414 |     });
415 |   }
416 | 
417 |   function getAllFrameIds(tabId) {
418 |     return new Promise((resolve, reject) => {
419 |       if (!chrome?.webNavigation?.getAllFrames) {
420 |         reject(new Error("webNavigation API "));
421 |         return;
422 |       }
423 |       chrome.webNavigation.getAllFrames({ tabId }, (frames) => {
424 |         if (chrome.runtime.lastError) {
425 |           reject(new Error(chrome.runtime.lastError.message));
426 |           return;
427 |         }
428 |         if (!frames || !frames.length) {
429 |           resolve([0]);
430 |           return;
431 |         }
432 |         resolve(frames.map((frame) => frame.frameId));
433 |       });
434 |     });
435 |   }
436 | 
437 |   async function fetchApiLog() {
438 |     const tabId = await getActiveTabId().catch(() => null);
439 |     return new Promise((resolve, reject) => {
440 |       if (!chrome?.runtime?.sendMessage) {
441 |         reject(new Error("runtime API "));
442 |         return;
443 |       }
444 |       chrome.runtime.sendMessage({ type: "autoform_get_last_api_log", tabId }, (response) => {
445 |         if (chrome.runtime.lastError) {
446 |           reject(new Error(chrome.runtime.lastError.message));
447 |           return;
448 |         }
449 |         resolve(response?.log || null);
450 |       });
451 |     });
452 |   }
453 | 
454 |   async function fetchCurlLogs() {
455 |     const tabId = await getActiveTabId().catch(() => null);
456 |     return new Promise((resolve, reject) => {
457 |       if (!chrome?.runtime?.sendMessage) {
458 |         reject(new Error("runtime API "));
459 |         return;
460 |       }
461 |       chrome.runtime.sendMessage({ type: "autoform_get_detected_curl_logs", tabId }, (response) => {
462 |         if (chrome.runtime.lastError) {
463 |           reject(new Error(chrome.runtime.lastError.message));
464 |           return;
465 |         }
466 |         const logs = Array.isArray(response?.logs) ? response.logs : [];
467 |         resolve(logs);
468 |       });
469 |     });
470 |   }
471 | 
472 |   function formatApiLog(log) {
473 |     if (!log) {
474 |       return "API";
475 |     }
476 |     const lines = [];
477 |     const time = new Date(log.timestamp || Date.now()).toLocaleString();
478 |     lines.push(`: ${time}`);
479 |     lines.push("");
480 |     lines.push("-- Request --");
481 |     lines.push(
482 |       JSON.stringify(
483 |         log.request || {},
484 |         null,
485 |         2
486 |       )
487 |     );
488 |     lines.push("");
489 |     if (log.error) {
490 |       lines.push(`-- Error --\n${log.error}`);
491 |     } else {
492 |       lines.push("-- Response --");
493 |       lines.push(
494 |         JSON.stringify(
495 |           log.response || {},
496 |           null,
497 |           2
498 |         )
499 |       );
500 |       lines.push("");
501 |       lines.push(`items_count: ${log.items_count ?? ""}`);
502 |     }
503 |     return lines.join("\n");
504 |   }
505 | 
506 |   function stringifyWithLimit(value, limit = 12000) {
507 |     try {
508 |       const normalized = value === undefined ? null : value;
509 |       const json = JSON.stringify(normalized, null, 2);
510 |       if (typeof json !== "string") {
511 |         return "";
512 |       }
513 |       if (limit && json.length > limit) {
514 |         return `${json.slice(0, limit)}...\n( ${json.length - limit} )`;
515 |       }
516 |       return json;
517 |     } catch (err) {
518 |       return `<<JSON: ${err.message}>>`;
519 |     }
520 |   }
521 | 
522 | 
523 |   async function listFrameOrigins(tabId) {
524 |     const frames = await new Promise((resolve, reject) => {
525 |       if (!chrome?.webNavigation?.getAllFrames) {
526 |         reject(new Error("webNavigation API "));
527 |         return;
528 |       }
529 |       chrome.webNavigation.getAllFrames({ tabId }, (res) => {
530 |         if (chrome.runtime.lastError) {
531 |           reject(new Error(chrome.runtime.lastError.message));
532 |           return;
533 |         }
534 |         resolve(res || []);
535 |       });
536 |     });
537 |     const origins = new Set();
538 |     for (const frame of frames) {
539 |       try {
540 |         if (!frame.url) continue;
541 |         const u = new URL(frame.url);
542 |         if (["chrome:", "about:", "data:"].includes(u.protocol)) continue;
543 |         origins.add(u.origin);
544 |       } catch (_) {
545 |         continue;
546 |       }
547 |     }
548 |     const topOrigin = await new Promise((resolve) => {
549 |       if (!chrome?.tabs?.get) {
550 |         resolve(null);
551 |         return;
552 |       }
553 |       chrome.tabs.get(tabId, (tab) => {
554 |         if (chrome.runtime.lastError) {
555 |           resolve(null);
556 |           return;
557 |         }
558 |         try {
559 |           resolve(new URL(tab?.url || "").origin);
560 |         } catch (_) {
561 |           resolve(null);
562 |         }
563 |       });
564 |     });
565 |     if (topOrigin) origins.delete(topOrigin);
566 |     return [...origins];
567 |   }
568 | 
569 |   async function ensureOriginsPermission(origins) {
570 |     const need = [];
571 |     for (const origin of origins) {
572 |       const has = await new Promise((resolve) => {
573 |         chrome.permissions.contains({ origins: [`${origin}/*`] }, (granted) => {
574 |           resolve(!!granted);
575 |         });
576 |       });
577 |       if (!has) need.push(origin);
578 |     }
579 |     if (!need.length) return true;
580 |     const ok = await new Promise((resolve) => {
581 |       chrome.permissions.request(
582 |         { origins: need.map((origin) => `${origin}/*`) },
583 |         (granted) => resolve(!!granted)
584 |       );
585 |     });
586 |     return ok;
587 |   }
588 | 
589 | 
590 |   function isIgnorableConnectionError(message) {
591 |     if (!message || typeof message !== "string") return false;
592 |     const lower = message.toLowerCase();
593 |     return (
594 |       lower.includes("receiving end does not exist") ||
595 |       lower.includes("could not establish connection") ||
596 |       lower.includes("the message port closed before a response was received") ||
597 |       lower.includes("no matching recipient")
598 |     );
599 |   }
600 | 
601 |   function sendCommandToFrame(tabId, frameId, command, payload) {
602 |     return new Promise((resolve) => {
603 |       chrome.tabs.sendMessage(
604 |         tabId,
605 |         { type: command, payload },
606 |         { frameId },
607 |         (response) => {
608 |           if (chrome.runtime.lastError) {
609 |             const message = chrome.runtime.lastError.message || "unknown error";
610 |             resolve({
611 |               error: message,
612 |               unreachable: isIgnorableConnectionError(message)
613 |             });
614 |             return;
615 |           }
616 |           resolve(response || {});
617 |         }
618 |       );
619 |     });
620 |   }
621 | 
622 |   async function refreshDetectedInputCount() {
623 |     setInputCountStatus("");
624 |     try {
625 |       const tabId = await getActiveTabId();
626 |       const frameIds = await getAllFrameIds(tabId);
627 |       const results = await Promise.all(
628 |         frameIds.map((frameId) =>
629 |           sendCommandToFrame(tabId, frameId, "autoform_count_inputs", null)
630 |         )
631 |       );
632 |       const total = results.reduce((sum, res) => sum + (res?.count || 0), 0);
633 |       setInputCountStatus(total);
634 |     } catch (err) {
635 |       setInputCountStatus(`: ${err.message}`, true);
636 |     }
637 |   }
638 | 
639 |   async function handleExecuteClick(btn) {
640 |     if (!(currentData && currentData.length)) {
641 |       setStatus("JSON", true);
642 |       return;
643 |     }
644 |     btn.disabled = true;
645 |     setStatus("");
646 |     try {
647 |       const tabId = await getActiveTabId();
648 |       const origins = await listFrameOrigins(tabId);
649 |       const ok = await ensureOriginsPermission(origins);
650 |       if (!ok) {
651 |         setStatus(": ", true);
652 |         btn.disabled = false;
653 |         updateExecuteState();
654 |         await refreshDetectedInputCount();
655 |         return;
656 |       }
657 |       setStatus("");
658 |       const frameIds = await getAllFrameIds(tabId);
659 |       const results = await Promise.all(
660 |         frameIds.map((frameId) =>
661 |           sendCommandToFrame(tabId, frameId, "autoform_execute_json", currentData)
662 |         )
663 |       );
664 |       const summary = results.reduce(
665 |         (acc, res) => {
666 |           const applied = res?.applied || {};
667 |           acc.success += applied.success || 0;
668 |           acc.skipped += applied.skipped || 0;
669 |           acc.total += applied.total || 0;
670 |           return acc;
671 |         },
672 |         { success: 0, skipped: 0, total: 0 }
673 |       );
674 |       if (summary.total === 0) summary.total = currentData.length;
675 |       setStatus(`:  ${summary.success} / ${summary.total} ( ${summary.skipped})`);
676 |     } catch (err) {
677 |       setStatus(`: ${err.message}`, true);
678 |     } finally {
679 |       updateExecuteState();
680 |       await refreshDetectedInputCount();
681 |     }
682 |   }
683 | 
684 |   async function handleManualFill(btn) {
685 |     btn.disabled = true;
686 |     setManualStatus("");
687 |     try {
688 |       const tabId = await getActiveTabId();
689 |       const frameIds = await getAllFrameIds(tabId);
690 |       const results = await Promise.all(
691 |         frameIds.map((frameId) =>
692 |           sendCommandToFrame(tabId, frameId, "autoform_manual_fill", null)
693 |         )
694 |       );
695 |       const fatalError = results.find((item) => item?.error && !item?.unreachable)?.error;
696 |       if (fatalError) {
697 |         setManualStatus(`: ${fatalError}`, true);
698 |         return;
699 |       }
700 |       const usableResults = results.filter((item) => !item?.unreachable);
701 |       if (!usableResults.length) {
702 |         setManualStatus("", true);
703 |         return;
704 |       }
705 |       const summary = usableResults.reduce(
706 |         (acc, res) => {
707 |           const applied = res?.applied || {};
708 |           acc.success += applied.success || res?.filled || 0;
709 |           acc.skipped += applied.skipped || 0;
710 |           acc.total += applied.total || 0;
711 |           return acc;
712 |         },
713 |         { success: 0, skipped: 0, total: 0 }
714 |       );
715 |       setManualStatus(`: ${summary.success}`);
716 |     } catch (err) {
717 |       setManualStatus(`: ${err.message}`, true);
718 |     } finally {
719 |       btn.disabled = false;
720 |       await refreshDetectedInputCount();
721 |     }
722 |   }
723 | 
724 |   function validateSendContent(data) {
725 |     const values = Object.values(data || {});
726 |     if (!values.length) return false;
727 |     return values.every((value) => {
728 |       if (value == null) return false;
729 |       if (typeof value === "string") {
730 |         return value.trim().length > 0;
731 |       }
732 |       return true;
733 |     });
734 |   }
735 | 
736 |   function updateSendContentWarning(data) {
737 |     const warningEl = qs("send-content-warning");
738 |     if (!warningEl) return;
739 |     const formData = data || readSendContentFromForm();
740 |     const hasEmpty = !validateSendContent(formData);
741 |     warningEl.style.display = hasEmpty ? "block" : "none";
742 |     if (!hasEmpty) {
743 |       const statusEl = qs("send-content-status");
744 |       if (statusEl && statusEl.textContent === "") {
745 |         statusEl.textContent = "";
746 |         statusEl.style.color = "#555";
747 |       }
748 |     }
749 |   }
750 | 
751 |   function handleSendContentSave() {
752 |     cancelAutoSaveTimer();
753 |     const formData = readSendContentFromForm();
754 |     if (!validateSendContent(formData)) {
755 |       setSendContentStatus("", true);
756 |       updateSendContentWarning(formData);
757 |       return;
758 |     }
759 |     currentSendContent = formData;
760 |     persistSendContent();
761 |     lastAutoSavedSnapshot = serializeSendContent(currentSendContent);
762 |     setSendContentStatus("");
763 |     updateSendContentWarning(formData);
764 |   }
765 | 
766 |   async function handleSendContentApply(btn) {
767 |     cancelAutoSaveTimer();
768 |     currentSendContent = readSendContentFromForm();
769 |     persistSendContent();
770 |     lastAutoSavedSnapshot = serializeSendContent(currentSendContent);
771 | 
772 |     btn.disabled = true;
773 |     setSendContentStatus("");
774 |     try {
775 |       const tabId = await getActiveTabId();
776 |       const origins = await listFrameOrigins(tabId);
777 |       const ok = await ensureOriginsPermission(origins);
778 |       if (!ok) {
779 |         setSendContentStatus(": ", true);
780 |         return;
781 |       }
782 |       setSendContentStatus("");
783 |       const frameIds = await getAllFrameIds(tabId);
784 |       const results = await Promise.all(
785 |         frameIds.map((frameId) =>
786 |           sendCommandToFrame(tabId, frameId, "autoform_apply_send_content", currentSendContent)
787 |         )
788 |       );
789 |       const filledKeys = new Set();
790 |       for (const res of results) {
791 |         const keys = res?.sendContent?.filledKeys;
792 |         if (Array.isArray(keys)) {
793 |           keys.forEach((key) => filledKeys.add(key));
794 |         }
795 |       }
796 |       const totalKeys = Object.keys(currentSendContent).length;
797 |       setSendContentStatus(`: ${filledKeys.size}/${totalKeys}  ()`);
798 |     } catch (err) {
799 |       setSendContentStatus(`: ${err.message}`, true);
800 |     } finally {
801 |       btn.disabled = false;
802 |       await refreshDetectedInputCount();
803 |     }
804 |   }
805 | 
806 |   document.addEventListener("visibilitychange", () => {
807 |     if (document.visibilityState === "hidden") {
808 |       flushAutoSave({ force: true });
809 |     }
810 |   });
811 | 
812 |   window.addEventListener("beforeunload", () => {
813 |     flushAutoSave({ force: true });
814 |   });
815 | 
816 |   document.addEventListener("DOMContentLoaded", () => {
817 |     const fillBtn = qs("fill-now");
818 |     const sendContentToggle = qs("send-content-toggle");
819 |     const sendContentBody = qs("send-content-body");
820 |     const saveSendBtn = qs("save-send-content");
821 |     const floatingButtonCheckbox = qs("show-floating-button");
822 |     const saveApiKeyBtn = qs("save-api-key");
823 | 
824 |     if (fillBtn) {
825 |       fillBtn.addEventListener("click", () => handleManualFill(fillBtn));
826 |     }
827 |     const sendContentFields = getSendContentFields();
828 |     if (sendContentFields.length) {
829 |       sendContentFields.forEach((field) => {
830 |         field.addEventListener("input", handleSendContentFieldInput);
831 |       });
832 |     }
833 |     if (saveSendBtn) {
834 |       saveSendBtn.addEventListener("click", handleSendContentSave);
835 |     }
836 |     initSendContentToggle(sendContentToggle, sendContentBody, true);
837 |     updateSendContentWarning();
838 |     initFloatingButtonToggle(floatingButtonCheckbox);
839 |     initApiKeySaveHandler(saveApiKeyBtn);
840 | 
841 |     refreshDetectedInputCount();
842 |     loadSendContent();
843 |     loadApiKeyState();
844 |   });
845 | })();
--------------------------------------------------------------------------------

/sample_code/sample_data/dump.py:
--------------------------------------------------------------------------------
  1 | import os
  2 | import re
  3 | import fnmatch
  4 | 
  5 | def should_exclude(file_path):
  6 |     """
  7 |     
  8 |     """
  9 |     # 
 10 |     exclude_patterns = [
 11 |         # Python
 12 |         "__pycache__/*", "*.py[cod]", "*$py.class",
 13 |         # 
 14 |         ".env", "*.json", ".venv/*", "venv/*", "result/*", "ENV/*", "env.bak/*", "env/*",
 15 |         # pip
 16 |         "pip-log.txt", "pip-delete-this-directory.txt",
 17 |         # 
 18 |         "*.egg-info/*", "*.egg", "*.eggs", "*.whl",
 19 |         # 
 20 |         "htmlcov/*", ".tox/*", ".nox/*", ".coverage", "coverage.*", ".cache",
 21 |         "nosetests.xml", "coverage.xml", "*.cover", "*.py,cover",
 22 |         # Jupyter Notebook
 23 |         ".ipynb_checkpoints/*",
 24 |         # pylint, mypy
 25 |         ".mypy_cache/*", ".pyre/*", ".pytype/*", ".pyright/*",
 26 |         # IDE
 27 |         ".vscode/*", ".idea/*", "*.sublime-workspace", "*.sublime-project",
 28 |         # MacLinux
 29 |         ".DS_Store", "*.swp", "*~",
 30 |         # 
 31 |         "poetry.lock", "Pipfile.lock",
 32 |         # Docker
 33 |         "docker-compose.override.yml", ".dockerignore",
 34 |         # 
 35 |         "*.log", "*.pot", "*.mo", "cline_log.txt", "git_tracking_status.txt",
 36 |         # 
 37 |         "*.pem", ".secrets", ".env.act",
 38 |         # 
 39 |         "dump_result.txt"
 40 |     ]
 41 | 
 42 |     # 
 43 |     file_name = os.path.basename(file_path)
 44 | 
 45 |     # 
 46 |     rel_path = file_path
 47 | 
 48 |     # 
 49 |     for pattern in exclude_patterns:
 50 |         # 
 51 |         if fnmatch.fnmatch(file_name, pattern):
 52 |             return True
 53 | 
 54 |         # 
 55 |         if fnmatch.fnmatch(rel_path, pattern):
 56 |             return True
 57 | 
 58 |         # __pycache__ 
 59 |         if "__pycache__" in rel_path:
 60 |             return True
 61 | 
 62 |     return False
 63 | 
 64 | def dump_files_to_txt(target_dir):
 65 |     """
 66 |     dump_result.txt
 67 |     
 68 |     
 69 |     """
 70 |     # 
 71 |     output_file = os.path.join(target_dir, "dump_result.txt")
 72 | 
 73 |     # 
 74 |     base_dir = target_dir
 75 | 
 76 |     # 
 77 |     all_files = []
 78 |     for root, dirs, files in os.walk(target_dir):
 79 |         # 
 80 |         dirs.sort()
 81 |         # 
 82 |         for fname in sorted(files):
 83 |             abs_path = os.path.join(root, fname)
 84 | 
 85 |             # 
 86 |             if abs_path == output_file:
 87 |                 continue
 88 | 
 89 |             # 
 90 |             rel_path = os.path.relpath(abs_path, start=base_dir)
 91 |             if should_exclude(rel_path):
 92 |                 continue
 93 | 
 94 |             all_files.append((rel_path, abs_path))
 95 | 
 96 |     # 
 97 |     all_files.sort()
 98 | 
 99 |     with open(output_file, "w", encoding="utf-8") as out:
100 |         for rel_path, abs_path in all_files:
101 |             out.write(f"/{rel_path}:\n")
102 |             out.write("-" * 80 + "\n")
103 |             try:
104 |                 with open(abs_path, "r", encoding="utf-8") as f:
105 |                     for i, line in enumerate(f, 1):
106 |                         out.write(f"{i:3} | {line.rstrip()}\n")
107 |             except Exception as e:
108 |                 out.write(f"[ERROR READING FILE]: {e}\n")
109 |             out.write("-" * 80 + "\n\n")
110 | 
111 | if __name__ == "__main__":
112 |     # 
113 |     # target_directory = "/Users/neromehiro/hiro folder/my_Works/programing/aimsales-api/module/b_AddCompany"
114 |     target_directory = "/Users/neromehiro/hiro folder/my_Works/programing/autoform_chrome_extention"
115 |     dump_files_to_txt(target_directory)
116 |     print(f" : {target_directory}/dump_result.txt")
--------------------------------------------------------------------------------

/settings.js:
--------------------------------------------------------------------------------
  1 | (() => {
  2 |   const MASTER_STORAGE_KEY = "autoformEnabled";
  3 |   const AUTO_RUN_STORAGE_KEY = "autoformAutoRunOnOpen";
  4 | 
  5 |   function setDependentState(enabled) {
  6 |     const dependentCards = document.querySelectorAll('[data-master-scope="dependents"]');
  7 |     dependentCards.forEach((card) => {
  8 |       card.classList.toggle("master-off", !enabled);
  9 |       card.setAttribute("aria-disabled", (!enabled).toString());
 10 |     });
 11 |     const statusText = document.getElementById("master-toggle-status-text");
 12 |     if (statusText) {
 13 |       statusText.textContent = enabled
 14 |         ? "Aimsales AutoForm "
 15 |         : "OFF: ";
 16 |       statusText.style.color = enabled ? "#64748b" : "#dc2626";
 17 |     }
 18 |     const dependents = document.querySelectorAll("[data-master-controlled]");
 19 |     dependents.forEach((el) => {
 20 |       el.disabled = !enabled;
 21 |       el.setAttribute("aria-disabled", (!enabled).toString());
 22 |     });
 23 |   }
 24 | 
 25 |   function initMasterToggle() {
 26 |     const checkbox = document.getElementById("extension-master-toggle");
 27 |     if (!checkbox) return;
 28 | 
 29 |     const applyState = (value) => {
 30 |       const enabled = value !== false;
 31 |       checkbox.checked = enabled;
 32 |       setDependentState(enabled);
 33 |     };
 34 | 
 35 |     if (!chrome?.storage?.sync) {
 36 |       applyState(true);
 37 |       checkbox.addEventListener("change", () => {
 38 |         applyState(checkbox.checked);
 39 |       });
 40 |       return;
 41 |     }
 42 | 
 43 |     chrome.storage.sync.get(MASTER_STORAGE_KEY, (res) => {
 44 |       applyState(res?.[MASTER_STORAGE_KEY]);
 45 |     });
 46 | 
 47 |     checkbox.addEventListener("change", () => {
 48 |       const enabled = checkbox.checked;
 49 |       setDependentState(enabled);
 50 |       chrome.storage.sync.set({ [MASTER_STORAGE_KEY]: enabled });
 51 |     });
 52 |   }
 53 | 
 54 |   function initAutoRunToggle() {
 55 |     const checkbox = document.getElementById("autoform-toggle");
 56 |     if (!checkbox) return;
 57 | 
 58 |     const applyState = (value) => {
 59 |       checkbox.checked = value !== false;
 60 |     };
 61 | 
 62 |     if (!chrome?.storage?.sync) {
 63 |       applyState(true);
 64 |       checkbox.addEventListener("change", () => {
 65 |         applyState(checkbox.checked);
 66 |       });
 67 |       return;
 68 |     }
 69 | 
 70 |     chrome.storage.sync.get(AUTO_RUN_STORAGE_KEY, (res) => {
 71 |       applyState(res?.[AUTO_RUN_STORAGE_KEY]);
 72 |     });
 73 | 
 74 |     checkbox.addEventListener("change", () => {
 75 |       chrome.storage.sync.set({ [AUTO_RUN_STORAGE_KEY]: checkbox.checked });
 76 |     });
 77 |   }
 78 | 
 79 |   document.addEventListener("DOMContentLoaded", () => {
 80 |     initMasterToggle();
 81 |     initAutoRunToggle();
 82 |   });
 83 | })();
--------------------------------------------------------------------------------

