/.git/FETCH_HEAD:
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

/.git/HEAD:
--------------------------------------------------------------------------------
  1 | ref: refs/heads/main
--------------------------------------------------------------------------------

/.git/config:
--------------------------------------------------------------------------------
  1 | [core]
  2 | 	repositoryformatversion = 0
  3 | 	filemode = true
  4 | 	bare = false
  5 | 	logallrefupdates = true
  6 | 	ignorecase = true
  7 | 	precomposeunicode = true
  8 | [remote "origin"]
  9 | 	url = https://github.com/neromehiro/autoform_chrome_extention
 10 | 	fetch = +refs/heads/*:refs/remotes/origin/*
 11 | [branch "main"]
 12 | 	remote = origin
 13 | 	merge = refs/heads/main
--------------------------------------------------------------------------------

/.git/description:
--------------------------------------------------------------------------------
  1 | Unnamed repository; edit this file 'description' to name the repository.
--------------------------------------------------------------------------------

/.git/hooks/applypatch-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to check the commit log message taken by
  4 | # applypatch from an e-mail message.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an
  7 | # appropriate message if it wants to stop the commit.  The hook is
  8 | # allowed to edit the commit message file.
  9 | #
 10 | # To enable this hook, rename this file to "applypatch-msg".
 11 | 
 12 | . git-sh-setup
 13 | commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
 14 | test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
 15 | :
--------------------------------------------------------------------------------

/.git/hooks/commit-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to check the commit log message.
  4 | # Called by "git commit" with one argument, the name of the file
  5 | # that has the commit message.  The hook should exit with non-zero
  6 | # status after issuing an appropriate message if it wants to stop the
  7 | # commit.  The hook is allowed to edit the commit message file.
  8 | #
  9 | # To enable this hook, rename this file to "commit-msg".
 10 | 
 11 | # Uncomment the below to add a Signed-off-by line to the message.
 12 | # Doing this in a hook is a bad idea in general, but the prepare-commit-msg
 13 | # hook is more suited to it.
 14 | #
 15 | # SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
 16 | # grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
 17 | 
 18 | # This example catches duplicate Signed-off-by lines.
 19 | 
 20 | test "" = "$(grep '^Signed-off-by: ' "$1" |
 21 | 	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
 22 | 	echo >&2 Duplicate Signed-off-by lines.
 23 | 	exit 1
 24 | }
--------------------------------------------------------------------------------

/.git/hooks/fsmonitor-watchman.sample:
--------------------------------------------------------------------------------
  1 | #!/usr/bin/perl
  2 | 
  3 | use strict;
  4 | use warnings;
  5 | use IPC::Open2;
  6 | 
  7 | # An example hook script to integrate Watchman
  8 | # (https://facebook.github.io/watchman/) with git to speed up detecting
  9 | # new and modified files.
 10 | #
 11 | # The hook is passed a version (currently 2) and last update token
 12 | # formatted as a string and outputs to stdout a new update token and
 13 | # all files that have been modified since the update token. Paths must
 14 | # be relative to the root of the working tree and separated by a single NUL.
 15 | #
 16 | # To enable this hook, rename this file to "query-watchman" and set
 17 | # 'git config core.fsmonitor .git/hooks/query-watchman'
 18 | #
 19 | my ($version, $last_update_token) = @ARGV;
 20 | 
 21 | # Uncomment for debugging
 22 | # print STDERR "$0 $version $last_update_token\n";
 23 | 
 24 | # Check the hook interface version
 25 | if ($version ne 2) {
 26 | 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 27 | 	    "Falling back to scanning...\n";
 28 | }
 29 | 
 30 | my $git_work_tree = get_working_dir();
 31 | 
 32 | my $retry = 1;
 33 | 
 34 | my $json_pkg;
 35 | eval {
 36 | 	require JSON::XS;
 37 | 	$json_pkg = "JSON::XS";
 38 | 	1;
 39 | } or do {
 40 | 	require JSON::PP;
 41 | 	$json_pkg = "JSON::PP";
 42 | };
 43 | 
 44 | launch_watchman();
 45 | 
 46 | sub launch_watchman {
 47 | 	my $o = watchman_query();
 48 | 	if (is_work_tree_watched($o)) {
 49 | 		output_result($o->{clock}, @{$o->{files}});
 50 | 	}
 51 | }
 52 | 
 53 | sub output_result {
 54 | 	my ($clockid, @files) = @_;
 55 | 
 56 | 	# Uncomment for debugging watchman output
 57 | 	# open (my $fh, ">", ".git/watchman-output.out");
 58 | 	# binmode $fh, ":utf8";
 59 | 	# print $fh "$clockid\n@files\n";
 60 | 	# close $fh;
 61 | 
 62 | 	binmode STDOUT, ":utf8";
 63 | 	print $clockid;
 64 | 	print "\0";
 65 | 	local $, = "\0";
 66 | 	print @files;
 67 | }
 68 | 
 69 | sub watchman_clock {
 70 | 	my $response = qx/watchman clock "$git_work_tree"/;
 71 | 	die "Failed to get clock id on '$git_work_tree'.\n" .
 72 | 		"Falling back to scanning...\n" if $? != 0;
 73 | 
 74 | 	return $json_pkg->new->utf8->decode($response);
 75 | }
 76 | 
 77 | sub watchman_query {
 78 | 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
 79 | 	or die "open2() failed: $!\n" .
 80 | 	"Falling back to scanning...\n";
 81 | 
 82 | 	# In the query expression below we're asking for names of files that
 83 | 	# changed since $last_update_token but not from the .git folder.
 84 | 	#
 85 | 	# To accomplish this, we're using the "since" generator to use the
 86 | 	# recency index to select candidate nodes and "fields" to limit the
 87 | 	# output to file names only. Then we're using the "expression" term to
 88 | 	# further constrain the results.
 89 | 	my $last_update_line = "";
 90 | 	if (substr($last_update_token, 0, 1) eq "c") {
 91 | 		$last_update_token = "\"$last_update_token\"";
 92 | 		$last_update_line = qq[\n"since": $last_update_token,];
 93 | 	}
 94 | 	my $query = <<"	END";
 95 | 		["query", "$git_work_tree", {$last_update_line
 96 | 			"fields": ["name"],
 97 | 			"expression": ["not", ["dirname", ".git"]]
 98 | 		}]
 99 | 	END
100 | 
101 | 	# Uncomment for debugging the watchman query
102 | 	# open (my $fh, ">", ".git/watchman-query.json");
103 | 	# print $fh $query;
104 | 	# close $fh;
105 | 
106 | 	print CHLD_IN $query;
107 | 	close CHLD_IN;
108 | 	my $response = do {local $/; <CHLD_OUT>};
109 | 
110 | 	# Uncomment for debugging the watch response
111 | 	# open ($fh, ">", ".git/watchman-response.json");
112 | 	# print $fh $response;
113 | 	# close $fh;
114 | 
115 | 	die "Watchman: command returned no output.\n" .
116 | 	"Falling back to scanning...\n" if $response eq "";
117 | 	die "Watchman: command returned invalid output: $response\n" .
118 | 	"Falling back to scanning...\n" unless $response =~ /^\{/;
119 | 
120 | 	return $json_pkg->new->utf8->decode($response);
121 | }
122 | 
123 | sub is_work_tree_watched {
124 | 	my ($output) = @_;
125 | 	my $error = $output->{error};
126 | 	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
127 | 		$retry--;
128 | 		my $response = qx/watchman watch "$git_work_tree"/;
129 | 		die "Failed to make watchman watch '$git_work_tree'.\n" .
130 | 		    "Falling back to scanning...\n" if $? != 0;
131 | 		$output = $json_pkg->new->utf8->decode($response);
132 | 		$error = $output->{error};
133 | 		die "Watchman: $error.\n" .
134 | 		"Falling back to scanning...\n" if $error;
135 | 
136 | 		# Uncomment for debugging watchman output
137 | 		# open (my $fh, ">", ".git/watchman-output.out");
138 | 		# close $fh;
139 | 
140 | 		# Watchman will always return all files on the first query so
141 | 		# return the fast "everything is dirty" flag to git and do the
142 | 		# Watchman query just to get it over with now so we won't pay
143 | 		# the cost in git to look up each individual file.
144 | 		my $o = watchman_clock();
145 | 		$error = $output->{error};
146 | 
147 | 		die "Watchman: $error.\n" .
148 | 		"Falling back to scanning...\n" if $error;
149 | 
150 | 		output_result($o->{clock}, ("/"));
151 | 		$last_update_token = $o->{clock};
152 | 
153 | 		eval { launch_watchman() };
154 | 		return 0;
155 | 	}
156 | 
157 | 	die "Watchman: $error.\n" .
158 | 	"Falling back to scanning...\n" if $error;
159 | 
160 | 	return 1;
161 | }
162 | 
163 | sub get_working_dir {
164 | 	my $working_dir;
165 | 	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
166 | 		$working_dir = Win32::GetCwd();
167 | 		$working_dir =~ tr/\\/\//;
168 | 	} else {
169 | 		require Cwd;
170 | 		$working_dir = Cwd::cwd();
171 | 	}
172 | 
173 | 	return $working_dir;
174 | }
--------------------------------------------------------------------------------

/.git/hooks/post-update.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to prepare a packed repository for use over
  4 | # dumb transports.
  5 | #
  6 | # To enable this hook, rename this file to "post-update".
  7 | 
  8 | exec git update-server-info
--------------------------------------------------------------------------------

/.git/hooks/pre-applypatch.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed
  4 | # by applypatch from an e-mail message.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an
  7 | # appropriate message if it wants to stop the commit.
  8 | #
  9 | # To enable this hook, rename this file to "pre-applypatch".
 10 | 
 11 | . git-sh-setup
 12 | precommit="$(git rev-parse --git-path hooks/pre-commit)"
 13 | test -x "$precommit" && exec "$precommit" ${1+"$@"}
 14 | :
--------------------------------------------------------------------------------

/.git/hooks/pre-commit.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed.
  4 | # Called by "git commit" with no arguments.  The hook should
  5 | # exit with non-zero status after issuing an appropriate message if
  6 | # it wants to stop the commit.
  7 | #
  8 | # To enable this hook, rename this file to "pre-commit".
  9 | 
 10 | if git rev-parse --verify HEAD >/dev/null 2>&1
 11 | then
 12 | 	against=HEAD
 13 | else
 14 | 	# Initial commit: diff against an empty tree object
 15 | 	against=$(git hash-object -t tree /dev/null)
 16 | fi
 17 | 
 18 | # If you want to allow non-ASCII filenames set this variable to true.
 19 | allownonascii=$(git config --type=bool hooks.allownonascii)
 20 | 
 21 | # Redirect output to stderr.
 22 | exec 1>&2
 23 | 
 24 | # Cross platform projects tend to avoid non-ASCII filenames; prevent
 25 | # them from being added to the repository. We exploit the fact that the
 26 | # printable range starts at the space character and ends with tilde.
 27 | if [ "$allownonascii" != "true" ] &&
 28 | 	# Note that the use of brackets around a tr range is ok here, (it's
 29 | 	# even required, for portability to Solaris 10's /usr/bin/tr), since
 30 | 	# the square bracket bytes happen to fall in the designated range.
 31 | 	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
 32 | 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
 33 | then
 34 | 	cat <<\EOF
 35 | Error: Attempt to add a non-ASCII file name.
 36 | 
 37 | This can cause problems if you want to work with people on other platforms.
 38 | 
 39 | To be portable it is advisable to rename the file.
 40 | 
 41 | If you know what you are doing you can disable this check using:
 42 | 
 43 |   git config hooks.allownonascii true
 44 | EOF
 45 | 	exit 1
 46 | fi
 47 | 
 48 | # If there are whitespace errors, print the offending file names and fail.
 49 | exec git diff-index --check --cached $against --
--------------------------------------------------------------------------------

/.git/hooks/pre-merge-commit.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to verify what is about to be committed.
  4 | # Called by "git merge" with no arguments.  The hook should
  5 | # exit with non-zero status after issuing an appropriate message to
  6 | # stderr if it wants to stop the merge commit.
  7 | #
  8 | # To enable this hook, rename this file to "pre-merge-commit".
  9 | 
 10 | . git-sh-setup
 11 | test -x "$GIT_DIR/hooks/pre-commit" &&
 12 |         exec "$GIT_DIR/hooks/pre-commit"
 13 | :
--------------------------------------------------------------------------------

/.git/hooks/pre-push.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to verify what is about to be pushed.  Called by "git
  4 | # push" after it has checked the remote status, but before anything has been
  5 | # pushed.  If this script exits with a non-zero status nothing will be pushed.
  6 | #
  7 | # This hook is called with the following parameters:
  8 | #
  9 | # $1 -- Name of the remote to which the push is being done
 10 | # $2 -- URL to which the push is being done
 11 | #
 12 | # If pushing without using a named remote those arguments will be equal.
 13 | #
 14 | # Information about the commits which are being pushed is supplied as lines to
 15 | # the standard input in the form:
 16 | #
 17 | #   <local ref> <local oid> <remote ref> <remote oid>
 18 | #
 19 | # This sample shows how to prevent push of commits where the log message starts
 20 | # with "WIP" (work in progress).
 21 | 
 22 | remote="$1"
 23 | url="$2"
 24 | 
 25 | zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 26 | 
 27 | while read local_ref local_oid remote_ref remote_oid
 28 | do
 29 | 	if test "$local_oid" = "$zero"
 30 | 	then
 31 | 		# Handle delete
 32 | 		:
 33 | 	else
 34 | 		if test "$remote_oid" = "$zero"
 35 | 		then
 36 | 			# New branch, examine all commits
 37 | 			range="$local_oid"
 38 | 		else
 39 | 			# Update to existing branch, examine new commits
 40 | 			range="$remote_oid..$local_oid"
 41 | 		fi
 42 | 
 43 | 		# Check for WIP commit
 44 | 		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
 45 | 		if test -n "$commit"
 46 | 		then
 47 | 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 48 | 			exit 1
 49 | 		fi
 50 | 	fi
 51 | done
 52 | 
 53 | exit 0
--------------------------------------------------------------------------------

/.git/hooks/pre-rebase.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # Copyright (c) 2006, 2008 Junio C Hamano
  4 | #
  5 | # The "pre-rebase" hook is run just before "git rebase" starts doing
  6 | # its job, and can prevent the command from running by exiting with
  7 | # non-zero status.
  8 | #
  9 | # The hook is called with the following parameters:
 10 | #
 11 | # $1 -- the upstream the series was forked from.
 12 | # $2 -- the branch being rebased (or empty when rebasing the current branch).
 13 | #
 14 | # This sample shows how to prevent topic branches that are already
 15 | # merged to 'next' branch from getting rebased, because allowing it
 16 | # would result in rebasing already published history.
 17 | 
 18 | publish=next
 19 | basebranch="$1"
 20 | if test "$#" = 2
 21 | then
 22 | 	topic="refs/heads/$2"
 23 | else
 24 | 	topic=`git symbolic-ref HEAD` ||
 25 | 	exit 0 ;# we do not interrupt rebasing detached HEAD
 26 | fi
 27 | 
 28 | case "$topic" in
 29 | refs/heads/??/*)
 30 | 	;;
 31 | *)
 32 | 	exit 0 ;# we do not interrupt others.
 33 | 	;;
 34 | esac
 35 | 
 36 | # Now we are dealing with a topic branch being rebased
 37 | # on top of master.  Is it OK to rebase it?
 38 | 
 39 | # Does the topic really exist?
 40 | git show-ref -q "$topic" || {
 41 | 	echo >&2 "No such branch $topic"
 42 | 	exit 1
 43 | }
 44 | 
 45 | # Is topic fully merged to master?
 46 | not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
 47 | if test -z "$not_in_master"
 48 | then
 49 | 	echo >&2 "$topic is fully merged to master; better remove it."
 50 | 	exit 1 ;# we could allow it, but there is no point.
 51 | fi
 52 | 
 53 | # Is topic ever merged to next?  If so you should not be rebasing it.
 54 | only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
 55 | only_next_2=`git rev-list ^master           ${publish} | sort`
 56 | if test "$only_next_1" = "$only_next_2"
 57 | then
 58 | 	not_in_topic=`git rev-list "^$topic" master`
 59 | 	if test -z "$not_in_topic"
 60 | 	then
 61 | 		echo >&2 "$topic is already up to date with master"
 62 | 		exit 1 ;# we could allow it, but there is no point.
 63 | 	else
 64 | 		exit 0
 65 | 	fi
 66 | else
 67 | 	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
 68 | 	/usr/bin/perl -e '
 69 | 		my $topic = $ARGV[0];
 70 | 		my $msg = "* $topic has commits already merged to public branch:\n";
 71 | 		my (%not_in_next) = map {
 72 | 			/^([0-9a-f]+) /;
 73 | 			($1 => 1);
 74 | 		} split(/\n/, $ARGV[1]);
 75 | 		for my $elem (map {
 76 | 				/^([0-9a-f]+) (.*)$/;
 77 | 				[$1 => $2];
 78 | 			} split(/\n/, $ARGV[2])) {
 79 | 			if (!exists $not_in_next{$elem->[0]}) {
 80 | 				if ($msg) {
 81 | 					print STDERR $msg;
 82 | 					undef $msg;
 83 | 				}
 84 | 				print STDERR " $elem->[1]\n";
 85 | 			}
 86 | 		}
 87 | 	' "$topic" "$not_in_next" "$not_in_master"
 88 | 	exit 1
 89 | fi
 90 | 
 91 | <<\DOC_END
 92 | 
 93 | This sample hook safeguards topic branches that have been
 94 | published from being rewound.
 95 | 
 96 | The workflow assumed here is:
 97 | 
 98 |  * Once a topic branch forks from "master", "master" is never
 99 |    merged into it again (either directly or indirectly).
100 | 
101 |  * Once a topic branch is fully cooked and merged into "master",
102 |    it is deleted.  If you need to build on top of it to correct
103 |    earlier mistakes, a new topic branch is created by forking at
104 |    the tip of the "master".  This is not strictly necessary, but
105 |    it makes it easier to keep your history simple.
106 | 
107 |  * Whenever you need to test or publish your changes to topic
108 |    branches, merge them into "next" branch.
109 | 
110 | The script, being an example, hardcodes the publish branch name
111 | to be "next", but it is trivial to make it configurable via
112 | $GIT_DIR/config mechanism.
113 | 
114 | With this workflow, you would want to know:
115 | 
116 | (1) ... if a topic branch has ever been merged to "next".  Young
117 |     topic branches can have stupid mistakes you would rather
118 |     clean up before publishing, and things that have not been
119 |     merged into other branches can be easily rebased without
120 |     affecting other people.  But once it is published, you would
121 |     not want to rewind it.
122 | 
123 | (2) ... if a topic branch has been fully merged to "master".
124 |     Then you can delete it.  More importantly, you should not
125 |     build on top of it -- other people may already want to
126 |     change things related to the topic as patches against your
127 |     "master", so if you need further changes, it is better to
128 |     fork the topic (perhaps with the same name) afresh from the
129 |     tip of "master".
130 | 
131 | Let's look at this example:
132 | 
133 | 		   o---o---o---o---o---o---o---o---o---o "next"
134 | 		  /       /           /           /
135 | 		 /   a---a---b A     /           /
136 | 		/   /               /           /
137 | 	       /   /   c---c---c---c B         /
138 | 	      /   /   /             \         /
139 | 	     /   /   /   b---b C     \       /
140 | 	    /   /   /   /             \     /
141 |     ---o---o---o---o---o---o---o---o---o---o---o "master"
142 | 
143 | 
144 | A, B and C are topic branches.
145 | 
146 |  * A has one fix since it was merged up to "next".
147 | 
148 |  * B has finished.  It has been fully merged up to "master" and "next",
149 |    and is ready to be deleted.
150 | 
151 |  * C has not merged to "next" at all.
152 | 
153 | We would want to allow C to be rebased, refuse A, and encourage
154 | B to be deleted.
155 | 
156 | To compute (1):
157 | 
158 | 	git rev-list ^master ^topic next
159 | 	git rev-list ^master        next
160 | 
161 | 	if these match, topic has not merged in next at all.
162 | 
163 | To compute (2):
164 | 
165 | 	git rev-list master..topic
166 | 
167 | 	if this is empty, it is fully merged to "master".
168 | 
169 | DOC_END
--------------------------------------------------------------------------------

/.git/hooks/pre-receive.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to make use of push options.
  4 | # The example simply echoes all push options that start with 'echoback='
  5 | # and rejects all pushes when the "reject" push option is used.
  6 | #
  7 | # To enable this hook, rename this file to "pre-receive".
  8 | 
  9 | if test -n "$GIT_PUSH_OPTION_COUNT"
 10 | then
 11 | 	i=0
 12 | 	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
 13 | 	do
 14 | 		eval "value=\$GIT_PUSH_OPTION_$i"
 15 | 		case "$value" in
 16 | 		echoback=*)
 17 | 			echo "echo from the pre-receive-hook: ${value#*=}" >&2
 18 | 			;;
 19 | 		reject)
 20 | 			exit 1
 21 | 		esac
 22 | 		i=$((i + 1))
 23 | 	done
 24 | fi
--------------------------------------------------------------------------------

/.git/hooks/prepare-commit-msg.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to prepare the commit log message.
  4 | # Called by "git commit" with the name of the file that has the
  5 | # commit message, followed by the description of the commit
  6 | # message's source.  The hook's purpose is to edit the commit
  7 | # message file.  If the hook fails with a non-zero status,
  8 | # the commit is aborted.
  9 | #
 10 | # To enable this hook, rename this file to "prepare-commit-msg".
 11 | 
 12 | # This hook includes three examples. The first one removes the
 13 | # "# Please enter the commit message..." help message.
 14 | #
 15 | # The second includes the output of "git diff --name-status -r"
 16 | # into the message, just before the "git status" output.  It is
 17 | # commented because it doesn't cope with --amend or with squashed
 18 | # commits.
 19 | #
 20 | # The third example adds a Signed-off-by line to the message, that can
 21 | # still be edited.  This is rarely a good idea.
 22 | 
 23 | COMMIT_MSG_FILE=$1
 24 | COMMIT_SOURCE=$2
 25 | SHA1=$3
 26 | 
 27 | /usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
 28 | 
 29 | # case "$COMMIT_SOURCE,$SHA1" in
 30 | #  ,|template,)
 31 | #    /usr/bin/perl -i.bak -pe '
 32 | #       print "\n" . `git diff --cached --name-status -r`
 33 | # 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
 34 | #  *) ;;
 35 | # esac
 36 | 
 37 | # SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
 38 | # git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
 39 | # if test -z "$COMMIT_SOURCE"
 40 | # then
 41 | #   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
 42 | # fi
--------------------------------------------------------------------------------

/.git/hooks/push-to-checkout.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to update a checked-out tree on a git push.
  4 | #
  5 | # This hook is invoked by git-receive-pack(1) when it reacts to git
  6 | # push and updates reference(s) in its repository, and when the push
  7 | # tries to update the branch that is currently checked out and the
  8 | # receive.denyCurrentBranch configuration variable is set to
  9 | # updateInstead.
 10 | #
 11 | # By default, such a push is refused if the working tree and the index
 12 | # of the remote repository has any difference from the currently
 13 | # checked out commit; when both the working tree and the index match
 14 | # the current commit, they are updated to match the newly pushed tip
 15 | # of the branch. This hook is to be used to override the default
 16 | # behaviour; however the code below reimplements the default behaviour
 17 | # as a starting point for convenient modification.
 18 | #
 19 | # The hook receives the commit with which the tip of the current
 20 | # branch is going to be updated:
 21 | commit=$1
 22 | 
 23 | # It can exit with a non-zero status to refuse the push (when it does
 24 | # so, it must not modify the index or the working tree).
 25 | die () {
 26 | 	echo >&2 "$*"
 27 | 	exit 1
 28 | }
 29 | 
 30 | # Or it can make any necessary changes to the working tree and to the
 31 | # index to bring them to the desired state when the tip of the current
 32 | # branch is updated to the new commit, and exit with a zero status.
 33 | #
 34 | # For example, the hook can simply run git read-tree -u -m HEAD "$1"
 35 | # in order to emulate git fetch that is run in the reverse direction
 36 | # with git push, as the two-tree form of git read-tree -u -m is
 37 | # essentially the same as git switch or git checkout that switches
 38 | # branches while keeping the local changes in the working tree that do
 39 | # not interfere with the difference between the branches.
 40 | 
 41 | # The below is a more-or-less exact translation to shell of the C code
 42 | # for the default behaviour for git's push-to-checkout hook defined in
 43 | # the push_to_deploy() function in builtin/receive-pack.c.
 44 | #
 45 | # Note that the hook will be executed from the repository directory,
 46 | # not from the working tree, so if you want to perform operations on
 47 | # the working tree, you will have to adapt your code accordingly, e.g.
 48 | # by adding "cd .." or using relative paths.
 49 | 
 50 | if ! git update-index -q --ignore-submodules --refresh
 51 | then
 52 | 	die "Up-to-date check failed"
 53 | fi
 54 | 
 55 | if ! git diff-files --quiet --ignore-submodules --
 56 | then
 57 | 	die "Working directory has unstaged changes"
 58 | fi
 59 | 
 60 | # This is a rough translation of:
 61 | #
 62 | #   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
 63 | if git cat-file -e HEAD 2>/dev/null
 64 | then
 65 | 	head=HEAD
 66 | else
 67 | 	head=$(git hash-object -t tree --stdin </dev/null)
 68 | fi
 69 | 
 70 | if ! git diff-index --quiet --cached --ignore-submodules $head --
 71 | then
 72 | 	die "Working directory has staged changes"
 73 | fi
 74 | 
 75 | if ! git read-tree -u -m "$commit"
 76 | then
 77 | 	die "Could not update working tree to new HEAD"
 78 | fi
--------------------------------------------------------------------------------

/.git/hooks/sendemail-validate.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | 
  3 | # An example hook script to validate a patch (and/or patch series) before
  4 | # sending it via email.
  5 | #
  6 | # The hook should exit with non-zero status after issuing an appropriate
  7 | # message if it wants to prevent the email(s) from being sent.
  8 | #
  9 | # To enable this hook, rename this file to "sendemail-validate".
 10 | #
 11 | # By default, it will only check that the patch(es) can be applied on top of
 12 | # the default upstream branch without conflicts in a secondary worktree. After
 13 | # validation (successful or not) of the last patch of a series, the worktree
 14 | # will be deleted.
 15 | #
 16 | # The following config variables can be set to change the default remote and
 17 | # remote ref that are used to apply the patches against:
 18 | #
 19 | #   sendemail.validateRemote (default: origin)
 20 | #   sendemail.validateRemoteRef (default: HEAD)
 21 | #
 22 | # Replace the TODO placeholders with appropriate checks according to your
 23 | # needs.
 24 | 
 25 | validate_cover_letter () {
 26 | 	file="$1"
 27 | 	# TODO: Replace with appropriate checks (e.g. spell checking).
 28 | 	true
 29 | }
 30 | 
 31 | validate_patch () {
 32 | 	file="$1"
 33 | 	# Ensure that the patch applies without conflicts.
 34 | 	git am -3 "$file" || return
 35 | 	# TODO: Replace with appropriate checks for this patch
 36 | 	# (e.g. checkpatch.pl).
 37 | 	true
 38 | }
 39 | 
 40 | validate_series () {
 41 | 	# TODO: Replace with appropriate checks for the whole series
 42 | 	# (e.g. quick build, coding style checks, etc.).
 43 | 	true
 44 | }
 45 | 
 46 | # main -------------------------------------------------------------------------
 47 | 
 48 | if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
 49 | then
 50 | 	remote=$(git config --default origin --get sendemail.validateRemote) &&
 51 | 	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
 52 | 	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
 53 | 	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
 54 | 	git config --replace-all sendemail.validateWorktree "$worktree"
 55 | else
 56 | 	worktree=$(git config --get sendemail.validateWorktree)
 57 | fi || {
 58 | 	echo "sendemail-validate: error: failed to prepare worktree" >&2
 59 | 	exit 1
 60 | }
 61 | 
 62 | unset GIT_DIR GIT_WORK_TREE
 63 | cd "$worktree" &&
 64 | 
 65 | if grep -q "^diff --git " "$1"
 66 | then
 67 | 	validate_patch "$1"
 68 | else
 69 | 	validate_cover_letter "$1"
 70 | fi &&
 71 | 
 72 | if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
 73 | then
 74 | 	git config --unset-all sendemail.validateWorktree &&
 75 | 	trap 'git worktree remove -ff "$worktree"' EXIT &&
 76 | 	validate_series
 77 | fi
--------------------------------------------------------------------------------

/.git/hooks/update.sample:
--------------------------------------------------------------------------------
  1 | #!/bin/sh
  2 | #
  3 | # An example hook script to block unannotated tags from entering.
  4 | # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
  5 | #
  6 | # To enable this hook, rename this file to "update".
  7 | #
  8 | # Config
  9 | # ------
 10 | # hooks.allowunannotated
 11 | #   This boolean sets whether unannotated tags will be allowed into the
 12 | #   repository.  By default they won't be.
 13 | # hooks.allowdeletetag
 14 | #   This boolean sets whether deleting tags will be allowed in the
 15 | #   repository.  By default they won't be.
 16 | # hooks.allowmodifytag
 17 | #   This boolean sets whether a tag may be modified after creation. By default
 18 | #   it won't be.
 19 | # hooks.allowdeletebranch
 20 | #   This boolean sets whether deleting branches will be allowed in the
 21 | #   repository.  By default they won't be.
 22 | # hooks.denycreatebranch
 23 | #   This boolean sets whether remotely creating branches will be denied
 24 | #   in the repository.  By default this is allowed.
 25 | #
 26 | 
 27 | # --- Command line
 28 | refname="$1"
 29 | oldrev="$2"
 30 | newrev="$3"
 31 | 
 32 | # --- Safety check
 33 | if [ -z "$GIT_DIR" ]; then
 34 | 	echo "Don't run this script from the command line." >&2
 35 | 	echo " (if you want, you could supply GIT_DIR then run" >&2
 36 | 	echo "  $0 <ref> <oldrev> <newrev>)" >&2
 37 | 	exit 1
 38 | fi
 39 | 
 40 | if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
 41 | 	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
 42 | 	exit 1
 43 | fi
 44 | 
 45 | # --- Config
 46 | allowunannotated=$(git config --type=bool hooks.allowunannotated)
 47 | allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
 48 | denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
 49 | allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
 50 | allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
 51 | 
 52 | # check for no description
 53 | projectdesc=$(sed -e '1q' "$GIT_DIR/description")
 54 | case "$projectdesc" in
 55 | "Unnamed repository"* | "")
 56 | 	echo "*** Project description file hasn't been set" >&2
 57 | 	exit 1
 58 | 	;;
 59 | esac
 60 | 
 61 | # --- Check types
 62 | # if $newrev is 0000...0000, it's a commit to delete a ref.
 63 | zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 64 | if [ "$newrev" = "$zero" ]; then
 65 | 	newrev_type=delete
 66 | else
 67 | 	newrev_type=$(git cat-file -t $newrev)
 68 | fi
 69 | 
 70 | case "$refname","$newrev_type" in
 71 | 	refs/tags/*,commit)
 72 | 		# un-annotated tag
 73 | 		short_refname=${refname##refs/tags/}
 74 | 		if [ "$allowunannotated" != "true" ]; then
 75 | 			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
 76 | 			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
 77 | 			exit 1
 78 | 		fi
 79 | 		;;
 80 | 	refs/tags/*,delete)
 81 | 		# delete tag
 82 | 		if [ "$allowdeletetag" != "true" ]; then
 83 | 			echo "*** Deleting a tag is not allowed in this repository" >&2
 84 | 			exit 1
 85 | 		fi
 86 | 		;;
 87 | 	refs/tags/*,tag)
 88 | 		# annotated tag
 89 | 		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
 90 | 		then
 91 | 			echo "*** Tag '$refname' already exists." >&2
 92 | 			echo "*** Modifying a tag is not allowed in this repository." >&2
 93 | 			exit 1
 94 | 		fi
 95 | 		;;
 96 | 	refs/heads/*,commit)
 97 | 		# branch
 98 | 		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
 99 | 			echo "*** Creating a branch is not allowed in this repository" >&2
100 | 			exit 1
101 | 		fi
102 | 		;;
103 | 	refs/heads/*,delete)
104 | 		# delete branch
105 | 		if [ "$allowdeletebranch" != "true" ]; then
106 | 			echo "*** Deleting a branch is not allowed in this repository" >&2
107 | 			exit 1
108 | 		fi
109 | 		;;
110 | 	refs/remotes/*,commit)
111 | 		# tracking branch
112 | 		;;
113 | 	refs/remotes/*,delete)
114 | 		# delete tracking branch
115 | 		if [ "$allowdeletebranch" != "true" ]; then
116 | 			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
117 | 			exit 1
118 | 		fi
119 | 		;;
120 | 	*)
121 | 		# Anything else (is there anything else?)
122 | 		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
123 | 		exit 1
124 | 		;;
125 | esac
126 | 
127 | # --- Finished
128 | exit 0
--------------------------------------------------------------------------------

/.git/info/exclude:
--------------------------------------------------------------------------------
  1 | # git ls-files --others --exclude-from=.git/info/exclude
  2 | # Lines that start with '#' are comments.
  3 | # For a project mostly in C, the following would be a good set of
  4 | # exclude patterns (uncomment them if you want to use them):
  5 | # *.[oa]
  6 | # *~
--------------------------------------------------------------------------------

/README.md:
--------------------------------------------------------------------------------
  1 | # AutoForm (test autofill)
  2 | 
  3 | フォームの入力欄に自動で `test`（または型に応じた定型値）を入れるだけの最小Chrome拡張（テスト用）。
  4 | 
  5 | ## 使い方
  6 | 1. このフォルダをローカルに用意（`manifest.json` と `content.js` があること）
  7 | 2. Chrome で `chrome://extensions` を開く
  8 | 3. 右上「デベロッパーモード」を ON
  9 | 4. 「パッケージ化されていない拡張機能を読み込む」→ このフォルダを選択
 10 | 5. 何かフォームのあるページを開く（例：会社サイトの問い合わせフォームなど）
 11 | 6. 入力欄（text/textarea/email/tel/url）が自動で埋まるのを確認
 12 | 
 13 | ### 注意
 14 | - パスワード欄があるページでは **何もしません**（誤入力回避のため）
 15 | - 送信はしません／cURL 取得もしません（テスト段階）
 16 | - 反映されない場合は、ページをリロードしてみてください
 17 | - SPA などでフォームが遅れて表示されるケースでも、対象の入力欄が3つ以上そろったタイミングで自動入力が走ります
 18 | - ポップアップ内の「フォーム入力を実行」ボタンを押すと、いつでも強制的に再入力できます（自動入力が済んだ後でも可）
 19 | - デバッグ用に、入力欄を検知した件数がページ右上にトースト表示されます
 20 | 
 21 | ## デバッグ用 JSON インポート
 22 | `sample_code/sample_data/apodori_ai.json` のような出力を使って、拡張機能から任意の XPath へ値を投入できます。
 23 | 
 24 | 1. ブラウザ右上の AutoForm アイコンをクリック
 25 | 2. 「JSON をインポート」から `.json` ファイルを選択（配列形式であること）
 26 | 3. 「入力を実行」を押すと、現在アクティブなタブ上で JSON に含まれる XPath/値が順番に適用されます
 27 |    - `match_condition` または値に `click` が含まれるものはクリック処理になります
 28 |    - input/textarea/select/contentEditable には指定の値を入力し、`input/change` を発火します
 29 | 4. 状態ラベルで成功/スキップ件数を確認できます
 30 | 
 31 | JSON はローカルストレージに保持されるため、次回ポップアップを開いたときも同じ内容で即実行できます。
 32 | 
 33 | iframe 内のフォームにも同じ命令が届くよう、拡張機能ボタン経由の JSON 実行／手動入力はタブ内の全フレームへ配送されています。
--------------------------------------------------------------------------------

/aimsales_logo.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/aimsales_logo.svg:
--------------------------------------------------------------------------------
  1 | <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0" x="0" y="0" width="2400" height="2400.3529828246246" viewBox="141.23600303649903 96.23176872253418 57.52800155639648 57.53646255493164" preserveAspectRatio="xMidYMid meet" color-interpolation-filters="sRGB"><g><defs><linearGradient id="92" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#fa71cd"></stop> <stop offset="100%" stop-color="#9b59b6"></stop></linearGradient><linearGradient id="93" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#f9d423"></stop> <stop offset="100%" stop-color="#f83600"></stop></linearGradient><linearGradient id="94" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#0064d2"></stop> <stop offset="100%" stop-color="#1cb0f6"></stop></linearGradient><linearGradient id="95" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#f00978"></stop> <stop offset="100%" stop-color="#3f51b1"></stop></linearGradient><linearGradient id="96" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#7873f5"></stop> <stop offset="100%" stop-color="#ec77ab"></stop></linearGradient><linearGradient id="97" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#f9d423"></stop> <stop offset="100%" stop-color="#e14fad"></stop></linearGradient><linearGradient id="98" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#009efd"></stop> <stop offset="100%" stop-color="#2af598"></stop></linearGradient><linearGradient id="99" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#ffcc00"></stop> <stop offset="100%" stop-color="#00b140"></stop></linearGradient><linearGradient id="100" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#d51007"></stop> <stop offset="100%" stop-color="#ff8177"></stop></linearGradient><linearGradient id="102" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#a2b6df"></stop> <stop offset="100%" stop-color="#0c3483"></stop></linearGradient><linearGradient id="103" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#7ac5d8"></stop> <stop offset="100%" stop-color="#eea2a2"></stop></linearGradient><linearGradient id="104" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#00ecbc"></stop> <stop offset="100%" stop-color="#007adf"></stop></linearGradient><linearGradient id="105" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#b88746"></stop> <stop offset="100%" stop-color="#fdf5a6"></stop></linearGradient></defs><g class="imagesvg isNoFont" transform="translate(141.79999923706055,96.79576873779297)"><g><rect fill="#333333" fill-opacity="0" stroke-width="2" x="0" y="0" width="56.400000000000006" height="56.40846126919038" class="image-rect"></rect> <svg x="0" y="0" width="56.400000000000006" height="56.40846126919038" filtersec="colorsb1650030988" class="image-svg-svg primary" style="overflow: visible;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0.026254011318087578 -0.000007631408152519725 100 100.01538848876953"><defs><linearGradient id="a1de97eee-0c32-49c6-8ae4-b0f7ef52bcdd" x1="105.37" y1="105.32" x2="14.31" y2="14.27" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0800c6"></stop><stop offset="1" stop-color="#00b3ee"></stop></linearGradient><linearGradient id="b790d1b4c-bf92-4343-b9be-61c7813e5bac" x1="17.74" y1="64.76" x2="75.54" y2="64.76" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#003999"></stop><stop offset="1" stop-opacity="0"></stop></linearGradient></defs><path d="M50 0v22a28 28 0 0 0 16.87 25.7c3.47-7.7 0-20.4 0-20.4C80.15 34.29 79.69 50 79.69 50a29.69 29.69 0 1 1-48.77-22.75 10.15 10.15 0 0 0-13-15.58A50 50 0 1 0 50 0z" fill="url(#a1de97eee-0c32-49c6-8ae4-b0f7ef52bcdd)"></path><path d="M25.14 93.32A49.36 49.36 0 0 0 48.76 100 50 50 0 0 0 100 50H79.69A29.69 29.69 0 1 1 28.5 29.52C20.76 37.3-1.36 64 25.14 93.32z" fill="url(#b790d1b4c-bf92-4343-b9be-61c7813e5bac)"></path></svg></svg> </g></g><defs v-gra="od"></defs></g></svg>
--------------------------------------------------------------------------------

/background.js:
--------------------------------------------------------------------------------
  1 | const FORM_ITEMS_ENDPOINT =
  2 |   "https://aimsales-autoform-axabd8h9ajbuesgj.japaneast-01.azurewebsites.net/chrome_extension/form_items";
  3 | const SEND_STORAGE_KEY = "autoformSendContent";
  4 | const DEFAULT_EMAIL = "y.abe@lassic.co.jp";
  5 | const MAX_CURL_LOGS = 5;
  6 | 
  7 | let lastApiLog = null;
  8 | let trackedEmail = null;
  9 | let detectedCurlLogs = [];
 10 | const pendingCurlRequests = new Map();
 11 | 
 12 | function createHtmlPreview(html) {
 13 |   if (typeof html !== "string") {
 14 |     return { preview: "", length: 0, truncated: false };
 15 |   }
 16 |   const limit = 2000;
 17 |   if (html.length <= limit) {
 18 |     return { preview: html, length: html.length, truncated: false };
 19 |   }
 20 |   return {
 21 |     preview: `${html.slice(0, limit)}...`,
 22 |     length: html.length,
 23 |     truncated: true
 24 |   };
 25 | }
 26 | 
 27 | const hasPerformance = typeof performance !== "undefined" && typeof performance.now === "function";
 28 | const nowFn = hasPerformance ? () => performance.now() : () => Date.now();
 29 | 
 30 | function escapeSingleQuotes(str) {
 31 |   if (typeof str !== "string") return "";
 32 |   return str.replace(/'/g, "'\"'\"'");
 33 | }
 34 | 
 35 | function extractRequestBody(details) {
 36 |   const requestBody = details?.requestBody;
 37 |   if (!requestBody) return "";
 38 |   if (requestBody.formData) {
 39 |     const params = new URLSearchParams();
 40 |     for (const [key, value] of Object.entries(requestBody.formData)) {
 41 |       if (Array.isArray(value)) {
 42 |         value.forEach((v) => params.append(key, v));
 43 |       } else if (value != null) {
 44 |         params.append(key, value);
 45 |       }
 46 |     }
 47 |     return params.toString();
 48 |   }
 49 |   if (Array.isArray(requestBody.raw) && requestBody.raw.length) {
 50 |     try {
 51 |       const decoder = new TextDecoder("utf-8");
 52 |       const chunks = requestBody.raw
 53 |         .filter((part) => part?.bytes)
 54 |         .map((part) => decoder.decode(part.bytes));
 55 |       return chunks.join("");
 56 |     } catch (_) {
 57 |       return "";
 58 |     }
 59 |   }
 60 |   return "";
 61 | }
 62 | 
 63 | function bodyContainsTrackedEmail(body) {
 64 |   if (!body || !trackedEmail) return false;
 65 |   const email = trackedEmail.trim();
 66 |   if (!email) return false;
 67 |   const encoded = encodeURIComponent(email);
 68 |   const lowerBody = body.toLowerCase();
 69 |   return lowerBody.includes(email.toLowerCase()) || lowerBody.includes(encoded.toLowerCase());
 70 | }
 71 | 
 72 | function buildCurlCommand(entry) {
 73 |   if (!entry) return "";
 74 |   const method = (entry.method || "GET").toUpperCase();
 75 |   const headerLines = (entry.headers || [])
 76 |     .filter((h) => h && typeof h.name === "string" && typeof h.value === "string")
 77 |     .map((h) => `  -H '${h.name}: ${escapeSingleQuotes(h.value)}'`)
 78 |     .join(" \\\n");
 79 | 
 80 |   let cmd = `curl '${entry.url}'`;
 81 |   if (method !== "GET") {
 82 |     cmd += ` \\\n  -X ${method}`;
 83 |   }
 84 |   if (headerLines) {
 85 |     cmd += ` \\\n${headerLines}`;
 86 |   }
 87 |   if (entry.body) {
 88 |     cmd += ` \\\n  --data-raw '${escapeSingleQuotes(entry.body)}'`;
 89 |   }
 90 |   return cmd;
 91 | }
 92 | 
 93 | function finalizeCurlLog(requestId, extra = {}) {
 94 |   const entry = pendingCurlRequests.get(requestId);
 95 |   if (!entry) return;
 96 |   pendingCurlRequests.delete(requestId);
 97 |   const log = {
 98 |     timestamp: Date.now(),
 99 |     url: entry.url,
100 |     method: entry.method,
101 |     email: entry.email,
102 |     sourceUrl: entry.sourceUrl || null,
103 |     curl: buildCurlCommand(entry),
104 |     statusCode: typeof extra.statusCode === "number" ? extra.statusCode : null,
105 |     error: extra.error || null,
106 |     requestBodyPreview: entry.body ? entry.body.slice(0, 2000) : ""
107 |   };
108 |   detectedCurlLogs.unshift(log);
109 |   if (detectedCurlLogs.length > MAX_CURL_LOGS) {
110 |     detectedCurlLogs = detectedCurlLogs.slice(0, MAX_CURL_LOGS);
111 |   }
112 | }
113 | 
114 | function refreshTrackedEmail() {
115 |   if (!chrome?.storage?.local) {
116 |     trackedEmail = null;
117 |     return;
118 |   }
119 |   chrome.storage.local.get(SEND_STORAGE_KEY, (res) => {
120 |     const storedEmail = res?.[SEND_STORAGE_KEY]?.email;
121 |     let nextEmail = null;
122 |     if (typeof storedEmail === "string" && storedEmail.trim()) {
123 |       nextEmail = storedEmail.trim();
124 |     } else if (storedEmail == null && DEFAULT_EMAIL) {
125 |       nextEmail = DEFAULT_EMAIL;
126 |     }
127 |     trackedEmail = typeof nextEmail === "string" && nextEmail.trim() ? nextEmail.trim() : null;
128 |   });
129 | }
130 | 
131 | function handleBeforeRequest(details) {
132 |   if (
133 |     !trackedEmail ||
134 |     !details ||
135 |     !details.requestId ||
136 |     (typeof details.tabId === "number" && details.tabId < 0)
137 |   ) {
138 |     return;
139 |   }
140 |   if (pendingCurlRequests.has(details.requestId)) {
141 |     return;
142 |   }
143 |   const body = extractRequestBody(details);
144 |   if (!bodyContainsTrackedEmail(body)) {
145 |     return;
146 |   }
147 |   pendingCurlRequests.set(details.requestId, {
148 |     method: details.method || "GET",
149 |     url: details.url,
150 |     body,
151 |     email: trackedEmail,
152 |     sourceUrl: details.documentUrl || details.initiator || null
153 |   });
154 | }
155 | 
156 | function handleBeforeSendHeaders(details) {
157 |   if (!details?.requestId) return;
158 |   const entry = pendingCurlRequests.get(details.requestId);
159 |   if (!entry) return;
160 |   entry.headers = details.requestHeaders || [];
161 | }
162 | 
163 | function handleCompleted(details) {
164 |   if (!details?.requestId) return;
165 |   finalizeCurlLog(details.requestId, { statusCode: details.statusCode });
166 | }
167 | 
168 | function handleError(details) {
169 |   if (!details?.requestId) return;
170 |   finalizeCurlLog(details.requestId, { error: details.error || "request_error" });
171 | }
172 | 
173 | if (chrome?.storage?.local) {
174 |   refreshTrackedEmail();
175 | }
176 | 
177 | if (chrome?.storage?.onChanged) {
178 |   chrome.storage.onChanged.addListener((changes, area) => {
179 |     if (area !== "local" || !changes[SEND_STORAGE_KEY]) return;
180 |     const newValue = changes[SEND_STORAGE_KEY]?.newValue;
181 |     let nextEmail = null;
182 |     if (newValue && typeof newValue.email === "string" && newValue.email.trim()) {
183 |       nextEmail = newValue.email.trim();
184 |     } else if (!newValue && DEFAULT_EMAIL) {
185 |       nextEmail = DEFAULT_EMAIL;
186 |     }
187 |     trackedEmail = typeof nextEmail === "string" && nextEmail.trim() ? nextEmail.trim() : null;
188 |   });
189 | }
190 | 
191 | if (chrome?.webRequest) {
192 |   const filter = { urls: ["<all_urls>"] };
193 |   chrome.webRequest.onBeforeRequest.addListener(handleBeforeRequest, filter, ["requestBody"]);
194 |   chrome.webRequest.onBeforeSendHeaders.addListener(handleBeforeSendHeaders, filter, ["requestHeaders", "extraHeaders"]);
195 |   chrome.webRequest.onCompleted.addListener(handleCompleted, filter);
196 |   chrome.webRequest.onErrorOccurred.addListener(handleError, filter);
197 | }
198 | 
199 | async function fetchFormItems(payload) {
200 |   const { html, sendRecord } = payload || {};
201 |   if (!html || !sendRecord) {
202 |     throw new Error("html と send_record が必要です");
203 |   }
204 | 
205 |   const htmlPreview = createHtmlPreview(html);
206 |   const logEntry = {
207 |     timestamp: Date.now(),
208 |     request: {
209 |       send_record: sendRecord,
210 |       html_preview: htmlPreview.preview,
211 |       html_length: htmlPreview.length,
212 |       html_truncated: htmlPreview.truncated
213 |     },
214 |     response: null,
215 |     error: null,
216 |     duration_ms: null
217 |   };
218 | 
219 |   function finalize(result, durationMs, error) {
220 |     if (typeof durationMs === "number") {
221 |       logEntry.duration_ms = durationMs;
222 |       if (logEntry.response) {
223 |         logEntry.response.duration_ms = durationMs;
224 |       }
225 |     }
226 |     if (error) {
227 |       logEntry.error = error;
228 |     }
229 |     lastApiLog = logEntry;
230 |     if (error) {
231 |       throw new Error(error);
232 |     }
233 |     return result;
234 |   }
235 | 
236 |   const startedAt = nowFn();
237 |   let response;
238 |   try {
239 |     response = await fetch(FORM_ITEMS_ENDPOINT, {
240 |       method: "POST",
241 |       headers: {
242 |         accept: "application/json",
243 |         "Content-Type": "application/json"
244 |       },
245 |       body: JSON.stringify({ send_record: sendRecord, html })
246 |     });
247 |   } catch (err) {
248 |     const durationMs = nowFn() - startedAt;
249 |     return finalize(null, durationMs, `APIリクエストに失敗しました: ${err?.message || err}`);
250 |   }
251 | 
252 |   const text = await response.text().catch(() => "");
253 |   let data;
254 |   try {
255 |     data = text ? JSON.parse(text) : {};
256 |   } catch (_) {
257 |     const durationMs = nowFn() - startedAt;
258 |     logEntry.response = { status: response.status, body: text };
259 |     return finalize(null, durationMs, "APIレスポンスの解析に失敗しました");
260 |   }
261 | 
262 |   logEntry.response = {
263 |     status: response.status,
264 |     ok: response.ok,
265 |     body: data
266 |   };
267 | 
268 |   const durationMs = nowFn() - startedAt;
269 | 
270 |   if (!response.ok) {
271 |     const message = `APIエラー: ${response.status} ${text || response.statusText}`.trim();
272 |     return finalize(null, durationMs, message);
273 |   }
274 | 
275 |   const items = Array.isArray(data?.form_items)
276 |     ? data.form_items
277 |     : Array.isArray(data)
278 |       ? data
279 |       : [];
280 |   logEntry.items_count = items.length;
281 |   return finalize({ items, durationMs }, durationMs, null);
282 | }
283 | 
284 | chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
285 |   if (!message?.type) return;
286 | 
287 |   if (message.type === "autoform_fetch_form_items") {
288 |     fetchFormItems(message.payload)
289 |       .then((result) => sendResponse({ items: result.items, durationMs: result.durationMs }))
290 |       .catch((err) => {
291 |         console.error("[AutoForm] API fetch error", err);
292 |         sendResponse({ error: err?.message || "APIエラー" });
293 |       });
294 |     return true;
295 |   }
296 | 
297 |   if (message.type === "autoform_get_last_api_log") {
298 |     sendResponse({ log: lastApiLog });
299 |   }
300 | 
301 |   if (message.type === "autoform_get_detected_curl_logs") {
302 |     sendResponse({ logs: detectedCurlLogs });
303 |   }
304 | });
--------------------------------------------------------------------------------

/content.js:
--------------------------------------------------------------------------------
  1 | // AutoForm: 最小版（テスト）
  2 | // 目的: ページ内のフォームっぽい入力欄を見つけて 'test' 等を自動入力するだけ。
  3 | // 送信はしない。cURL 取得もしない。
  4 | 
  5 | (() => {
  6 |   // テスト用の定数
  7 |   const STORAGE_KEY = "autoformEnabled";
  8 |   const AUTO_RUN_STORAGE_KEY = "autoformAutoRunOnOpen";
  9 |   const skipTypes = new Set([
 10 |     "hidden", "file", "submit", "button", "reset", "radio", "checkbox",
 11 |     "range", "date", "time", "color", "image"
 12 |   ]);
 13 |   const MIN_INPUTS_FOR_AUTO = 3;
 14 |   const KNOWN_MESSAGE_TYPES = new Set([
 15 |     "autoform_execute_json",
 16 |     "autoform_manual_fill",
 17 |     "autoform_count_inputs",
 18 |     "autoform_apply_send_content"
 19 |   ]);
 20 |   const SEND_CONTENT_STORAGE_KEY = "autoformSendContent";
 21 |   const FLOATING_BUTTON_STORAGE_KEY = "autoformShowFloatingButton";
 22 |   const FLOATING_BUTTON_LABEL_DEFAULT = "自動入力を実行";
 23 |   const FLOATING_BUTTON_DEFAULT_BACKGROUND = "linear-gradient(135deg, #0ea5e9, #6366f1)";
 24 |   const FLOATING_BUTTON_DEFAULT_SHADOW = "0 16px 32px rgba(99, 102, 241, 0.35)";
 25 |   const FLOATING_BUTTON_SUCCESS_BACKGROUND = "linear-gradient(135deg, #10b981, #22c55e)";
 26 |   const FLOATING_BUTTON_SUCCESS_SHADOW = "0 16px 32px rgba(16, 185, 129, 0.35)";
 27 |   const COMPLETION_COUNTDOWN_SECONDS = 3;
 28 |   const DEFAULT_SEND_RECORD = {
 29 |     name: "阿部 由希子",
 30 |     name_kana: "あべ ゆきこ",
 31 |     company: "株式会社LASSIC",
 32 |     "部署": "Remogu事業部",
 33 |     "住所": "東京都港区高輪1-3-13 NBF高輪ビル 4F",
 34 |     postal_code: "108-0074",
 35 |     company_kana: "かぶしきがいしゃ らしっく",
 36 |     prefecture: "東京都",
 37 |     email: "y.abe@lassic.co.jp",
 38 |     tel: "03-6455-7720",
 39 |     fax: "03-6455-7720",
 40 |     title: "エンジニア採用・調達に関する新規お打ち合わせのご提案",
 41 |     "業種": "IT人材紹介サービス",
 42 |     URL: "https://www.lassic.co.jp",
 43 |     remark:
 44 |       "お世話になっております。\n株式会社LASSICの阿部と申します。\n\n本日はエンジニア採用・調達における新規のお打ち合わせの件でご連絡いたしました。\n\n弊社ではIT人材特化型の紹介サービスを展開しておりまして、全国47都道府県から集客した1万人超のデータベースを基に、エンジニアをご紹介させていただいております。\n直近では「React、Next.jsでのフロントエンド開発」のご経験をお持ちの方や「PM、テックリード」のご経験をお持ちの方にも多数ご登録いただいております。\n\nRemoguサービスの強み：\n★実務経験3年以上の即戦力エンジニア/デザイナーが1万8000名ご登録\n★フルリモートワークからハイブリッドワークが可能な方まで幅広い人材バラエティ\n★フリーランス人材/中途採用双方でご支援可能\n★直近上流工程の開発やPM/PL・テックリードのご経験をお持ちの方の流入あり\n★開発系の言語からAI系、ゲーム系言語まで対応可能\n\nこちらのリンクより弊サービスについてご確認いただけますので、ご判断の材料にしていただけますと幸いです。\nhttps://www.lassic.co.jp/service/remogu/\n\nご多忙の中大変恐縮ではございますが、一度オンラインでのお打ち合わせの機会をいただけないでしょうか。\n現時点でのご活用ではなく、情報交換でも構いません。\nもしお話可能でしたら、オンラインにて30～60分ほどミーティングの機会をいただけますと幸いです。\n\n日程調整：https://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\nご検討のほど、よろしくお願い申し上げます。"
 45 |   };
 46 | 
 47 |   let detectionNoticeShown = false;
 48 |   let observer = null;
 49 |   let observerTimer = null;
 50 |   let started = false;
 51 |   let autoFillTriggered = false;
 52 |   let remoteFillPromise = null;
 53 |   let floatingButton = null;
 54 |   let floatingButtonEnabled = false;
 55 |   let floatingButtonBusy = false;
 56 |   let floatingButtonInitScheduled = false;
 57 |   let floatingButtonCompletionInterval = null;
 58 |   let floatingButtonCompletionPending = false;
 59 |   let masterEnabled = true;
 60 |   let autoRunOnOpen = true;
 61 | 
 62 |   function setNativeValue(el, v) {
 63 |     const proto = Object.getPrototypeOf(el);
 64 |     const descriptor = proto ? Object.getOwnPropertyDescriptor(proto, "value") : null;
 65 |     if (descriptor && descriptor.set) {
 66 |       descriptor.set.call(el, v);
 67 |     } else {
 68 |       el.value = v;
 69 |     }
 70 |   }
 71 | 
 72 |   function setValue(el, v) {
 73 |     // React/Vue 等の制御コンポーネント対策: value のセッターを直接叩き、input/change を発火
 74 |     el.focus();
 75 |     setNativeValue(el, v);
 76 |     el.dispatchEvent(new Event("input", { bubbles: true }));
 77 |     el.dispatchEvent(new Event("change", { bubbles: true }));
 78 |   }
 79 | 
 80 |   function normalizeComparableValue(value) {
 81 |     if (value == null) return "";
 82 |     return String(value)
 83 |       .trim()
 84 |       .replace(/\s+/g, "")
 85 |       .toLowerCase();
 86 |   }
 87 | 
 88 |   function looseEquals(a, b) {
 89 |     const normA = normalizeComparableValue(a);
 90 |     const normB = normalizeComparableValue(b);
 91 |     if (!normA || !normB) return false;
 92 |     return normA === normB;
 93 |   }
 94 | 
 95 |   function toCandidateList(value) {
 96 |     if (value == null) return [];
 97 |     if (Array.isArray(value)) return value.filter((v) => v !== null && v !== undefined);
 98 |     if (typeof value === "object") {
 99 |       return Object.values(value).filter((v) => v !== null && v !== undefined);
100 |     }
101 |     if (typeof value === "string") {
102 |       const trimmed = value.trim();
103 |       if (!trimmed) return [];
104 |       try {
105 |         if ((trimmed.startsWith("[") && trimmed.endsWith("]")) || trimmed.startsWith("{")) {
106 |           const parsed = JSON.parse(trimmed);
107 |           return toCandidateList(parsed);
108 |         }
109 |       } catch (_) {
110 |         // fall through to delimiter split
111 |       }
112 |       return trimmed
113 |         .split(/[\n,、]/)
114 |         .map((item) => item.trim())
115 |         .filter(Boolean);
116 |     }
117 |     return [value];
118 |   }
119 | 
120 |   function isTruthySelectionValue(value) {
121 |     if (Array.isArray(value)) return value.length > 0;
122 |     if (typeof value === "boolean") return value;
123 |     if (typeof value === "number") return value !== 0;
124 |     if (value == null) return false;
125 |     const normalized = String(value).trim().toLowerCase();
126 |     if (!normalized) return false;
127 |     return ![
128 |       "false",
129 |       "0",
130 |       "off",
131 |       "unchecked",
132 |       "未選択",
133 |       "未入力",
134 |       "no",
135 |       "none",
136 |       "deselect"
137 |     ].includes(normalized);
138 |   }
139 | 
140 |   function resolveChoiceValue(choices, desired) {
141 |     if (!Array.isArray(choices) || !choices.length || !desired) return null;
142 |     return (
143 |       choices.find(
144 |         (choice) => looseEquals(choice?.value, desired) || looseEquals(choice?.label, desired)
145 |       )?.value || null
146 |     );
147 |   }
148 | 
149 |   function selectOptions(selectEl, desiredValue, choices) {
150 |     if (!selectEl) return false;
151 |     const candidates = toCandidateList(desiredValue);
152 |     const options = Array.from(selectEl.options || []);
153 |     if (!options.length) return false;
154 | 
155 |     const pickFirstUsableOption = () =>
156 |       options.find((opt) => normalizeComparableValue(opt.value)) || options[0] || null;
157 | 
158 |     function findOption(candidateList) {
159 |       for (const candidate of candidateList) {
160 |         for (const option of options) {
161 |           if (
162 |             looseEquals(option.value, candidate) ||
163 |             looseEquals(option.textContent || option.label, candidate)
164 |           ) {
165 |             return option;
166 |           }
167 |         }
168 |       }
169 |       return null;
170 |     }
171 | 
172 |     if (selectEl.multiple) {
173 |       const normalized = candidates.map((c) => (c == null ? "" : String(c))).filter(Boolean);
174 |       let appliedCount = 0;
175 |       options.forEach((option) => {
176 |         const shouldSelect = normalized.some(
177 |           (candidate) => looseEquals(option.value, candidate) || looseEquals(option.textContent, candidate)
178 |         );
179 |         if (shouldSelect) appliedCount += 1;
180 |         option.selected = shouldSelect;
181 |       });
182 |       if (appliedCount === 0 && options.length) {
183 |         const fallbackOption = pickFirstUsableOption();
184 |         if (fallbackOption) {
185 |           fallbackOption.selected = true;
186 |           appliedCount = 1;
187 |         }
188 |       }
189 |       selectEl.dispatchEvent(new Event("input", { bubbles: true }));
190 |       selectEl.dispatchEvent(new Event("change", { bubbles: true }));
191 |       return appliedCount > 0;
192 |     }
193 | 
194 |     let optionMatch = findOption(candidates);
195 |     if (!optionMatch && Array.isArray(choices)) {
196 |       const resolved = candidates
197 |         .map((candidate) => resolveChoiceValue(choices, candidate))
198 |         .filter(Boolean);
199 |       optionMatch = findOption(resolved);
200 |     }
201 |     if (!optionMatch && !candidates.length) {
202 |       optionMatch = pickFirstUsableOption();
203 |     }
204 |     if (!optionMatch && candidates.length) {
205 |       optionMatch = pickFirstUsableOption();
206 |     }
207 |     if (!optionMatch) return false;
208 |     selectEl.value = optionMatch.value;
209 |     selectEl.dispatchEvent(new Event("input", { bubbles: true }));
210 |     selectEl.dispatchEvent(new Event("change", { bubbles: true }));
211 |     return true;
212 |   }
213 | 
214 |   function createNoticeElement(text, background) {
215 |     const notice = document.createElement("div");
216 |     notice.textContent = text;
217 |     Object.assign(notice.style, {
218 |       position: "fixed",
219 |       right: "16px",
220 |       padding: "14px 18px",
221 |       color: "#fff",
222 |       fontSize: "15px",
223 |       fontWeight: "600",
224 |       borderRadius: "10px",
225 |       zIndex: 2147483647,
226 |       boxShadow: "0 8px 24px rgba(0, 0, 0, 0.25)",
227 |       fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
228 |     });
229 |     notice.style.background = background;
230 |     return notice;
231 |   }
232 | 
233 |   function showDetectionNotice() {
234 |     detectionNoticeShown = true;
235 |   }
236 | 
237 |   function formatDuration(seconds) {
238 |     if (!Number.isFinite(seconds) || seconds <= 0) {
239 |       return null;
240 |     }
241 |     if (seconds < 0.01) return "0.01";
242 |     return seconds.toFixed(seconds >= 10 ? 1 : 2);
243 |   }
244 | 
245 |   function showCompletionNotice(durationSeconds = null) {
246 |     if (showFloatingButtonCompletion(durationSeconds)) {
247 |       return;
248 |     }
249 |     const formatted = formatDuration(durationSeconds);
250 |     const message = formatted
251 |       ? `✅ ${formatted}秒で入力が完了しました`
252 |       : "✅ 自動入力が完了しました";
253 |     const notice = createNoticeElement(message, "rgba(34, 197, 94, 0.95)");
254 |     notice.style.bottom = "16px";
255 |     (document.body || document.documentElement).appendChild(notice);
256 |     setTimeout(() => notice.remove(), 2500);
257 |   }
258 | 
259 |   function removeFloatingButton() {
260 |     if (!floatingButton) return;
261 |     floatingButton.removeEventListener("click", handleFloatingButtonClick);
262 |     floatingButton.remove();
263 |     floatingButton = null;
264 |     clearFloatingButtonCompletionTimer();
265 |   }
266 | 
267 |   function createFloatingButtonElement() {
268 |     if (floatingButton || typeof document === "undefined") return;
269 |     if (window.top !== window.self) return;
270 |     if (!document.body) {
271 |       if (!floatingButtonInitScheduled) {
272 |         floatingButtonInitScheduled = true;
273 |         document.addEventListener(
274 |           "DOMContentLoaded",
275 |           () => {
276 |             floatingButtonInitScheduled = false;
277 |             if (floatingButtonEnabled) {
278 |               createFloatingButtonElement();
279 |             }
280 |           },
281 |           { once: true }
282 |         );
283 |       }
284 |       return;
285 |     }
286 |     const btn = document.createElement("button");
287 |     btn.type = "button";
288 |     btn.textContent = FLOATING_BUTTON_LABEL_DEFAULT;
289 |     Object.assign(btn.style, {
290 |       position: "fixed",
291 |       bottom: "24px",
292 |       right: "24px",
293 |       padding: "11px 18px",
294 |       borderRadius: "999px",
295 |       border: "none",
296 |       background: FLOATING_BUTTON_DEFAULT_BACKGROUND,
297 |       color: "#fff",
298 |       fontSize: "14px",
299 |       fontWeight: "600",
300 |       boxShadow: FLOATING_BUTTON_DEFAULT_SHADOW,
301 |       zIndex: "2147483647",
302 |       cursor: "pointer",
303 |       fontFamily: "inherit"
304 |     });
305 |     applyFloatingButtonDefaultStyle(btn);
306 |     btn.addEventListener("click", handleFloatingButtonClick);
307 |     document.body.appendChild(btn);
308 |     floatingButton = btn;
309 |   }
310 | 
311 |   function updateFloatingButtonVisibility(enabled) {
312 |     floatingButtonEnabled = !!enabled;
313 |     if (floatingButtonEnabled) {
314 |       createFloatingButtonElement();
315 |     } else {
316 |       removeFloatingButton();
317 |     }
318 |   }
319 | 
320 |   async function handleFloatingButtonClick(event) {
321 |     event.preventDefault();
322 |     if (floatingButtonBusy) return;
323 |     floatingButtonBusy = true;
324 |     autoFillTriggered = true;
325 |     const btn = floatingButton;
326 |     const originalText = btn?.textContent;
327 |     if (btn) {
328 |       clearFloatingButtonCompletionTimer();
329 |       floatingButtonCompletionPending = false;
330 |       btn.textContent = "処理中…";
331 |       btn.disabled = true;
332 |       btn.style.opacity = "0.85";
333 |       applyFloatingButtonDefaultStyle(btn);
334 |     }
335 |     try {
336 |       await performRemoteFill();
337 |     } finally {
338 |       floatingButtonBusy = false;
339 |       if (btn) {
340 |         if (!floatingButtonCompletionPending) {
341 |           btn.textContent = originalText || FLOATING_BUTTON_LABEL_DEFAULT;
342 |           btn.disabled = false;
343 |           btn.style.opacity = "1";
344 |           applyFloatingButtonDefaultStyle(btn);
345 |         }
346 |       }
347 |     }
348 |   }
349 | 
350 |   function getPageHtml() {
351 |     const root = document.documentElement;
352 |     if (!root) return "";
353 |     return root.outerHTML || "";
354 |   }
355 | 
356 |   function getSendRecordFromStorage() {
357 |     const fallback = () => ({ ...DEFAULT_SEND_RECORD });
358 |     if (!chrome?.storage?.local) {
359 |       return Promise.resolve(fallback());
360 |     }
361 |     return new Promise((resolve) => {
362 |       try {
363 |         chrome.storage.local.get(SEND_CONTENT_STORAGE_KEY, (res) => {
364 |           if (chrome.runtime?.lastError) {
365 |             resolve(fallback());
366 |             return;
367 |           }
368 |           const stored = res?.[SEND_CONTENT_STORAGE_KEY];
369 |           if (stored && typeof stored === "object" && !Array.isArray(stored)) {
370 |             resolve({ ...DEFAULT_SEND_RECORD, ...stored });
371 |             return;
372 |           }
373 |           resolve(fallback());
374 |         });
375 |       } catch (_) {
376 |         resolve(fallback());
377 |       }
378 |     });
379 |   }
380 | 
381 |   async function performRemoteFill() {
382 |     if (remoteFillPromise) return remoteFillPromise;
383 |     remoteFillPromise = (async () => {
384 |       const html = getPageHtml();
385 |       if (!html) {
386 |         return { error: "HTMLが取得できませんでした" };
387 |       }
388 |       try {
389 |         const sendRecord = await getSendRecordFromStorage();
390 |         const { items, durationMs } = await requestFormItemsViaBackground(html, sendRecord);
391 |         const applied = applyJsonInstructions(items);
392 |         if (applied.success > 0) {
393 |           const durationSeconds = typeof durationMs === "number" ? durationMs / 1000 : null;
394 |           showCompletionNotice(durationSeconds);
395 |         }
396 |         return { applied };
397 |       } catch (err) {
398 |         console.error("[AutoForm] API 実行でエラー", err);
399 |         return { error: err?.message || "APIエラー" };
400 |       }
401 |     })();
402 |     const result = await remoteFillPromise;
403 |     remoteFillPromise = null;
404 |     return result;
405 |   }
406 | 
407 |   function requestFormItemsViaBackground(html, sendRecord) {
408 |     return new Promise((resolve, reject) => {
409 |       chrome.runtime.sendMessage(
410 |         {
411 |           type: "autoform_fetch_form_items",
412 |           payload: { html, sendRecord }
413 |         },
414 |         (response) => {
415 |           if (chrome.runtime.lastError) {
416 |             reject(new Error(chrome.runtime.lastError.message));
417 |             return;
418 |           }
419 |           if (response?.error) {
420 |             reject(new Error(response.error));
421 |             return;
422 |           }
423 |           const items = response?.items;
424 |           if (!Array.isArray(items)) {
425 |             reject(new Error("APIレスポンスが配列形式ではありません"));
426 |             return;
427 |           }
428 |           resolve({ items, durationMs: response?.durationMs });
429 |         }
430 |       );
431 |     });
432 |   }
433 | 
434 |   function clearFloatingButtonCompletionTimer() {
435 |     if (floatingButtonCompletionInterval) {
436 |       clearInterval(floatingButtonCompletionInterval);
437 |       floatingButtonCompletionInterval = null;
438 |     }
439 |     floatingButtonCompletionPending = false;
440 |   }
441 | 
442 |   function showFloatingButtonCompletion(durationSeconds) {
443 |     if (!(floatingButton && floatingButtonEnabled)) return false;
444 |     const formatted = formatDuration(durationSeconds);
445 |     const baseLabel = formatted ? `${formatted}秒で入力完了しました` : "入力完了しました";
446 |     clearFloatingButtonCompletionTimer();
447 |     floatingButtonCompletionPending = true;
448 |     floatingButton.disabled = false;
449 |     floatingButton.style.opacity = "1";
450 |     applyFloatingButtonSuccessStyle(floatingButton);
451 | 
452 |     let remaining = COMPLETION_COUNTDOWN_SECONDS;
453 |     const updateLabel = () => {
454 |       if (!floatingButton) return;
455 |       floatingButton.textContent = `${baseLabel} (${remaining})`;
456 |     };
457 |     updateLabel();
458 | 
459 |     floatingButtonCompletionInterval = setInterval(() => {
460 |       remaining -= 1;
461 |       if (remaining <= 0) {
462 |         clearFloatingButtonCompletionTimer();
463 |         if (floatingButton) {
464 |           floatingButton.textContent = FLOATING_BUTTON_LABEL_DEFAULT;
465 |           applyFloatingButtonDefaultStyle(floatingButton);
466 |         }
467 |         return;
468 |       }
469 |       updateLabel();
470 |     }, 1000);
471 |     return true;
472 |   }
473 | 
474 |   function applyFloatingButtonDefaultStyle(btn = floatingButton) {
475 |     if (!btn) return;
476 |     btn.style.background = FLOATING_BUTTON_DEFAULT_BACKGROUND;
477 |     btn.style.boxShadow = FLOATING_BUTTON_DEFAULT_SHADOW;
478 |     btn.style.color = "#fff";
479 |   }
480 | 
481 |   function applyFloatingButtonSuccessStyle(btn = floatingButton) {
482 |     if (!btn) return;
483 |     btn.style.background = FLOATING_BUTTON_SUCCESS_BACKGROUND;
484 |     btn.style.boxShadow = FLOATING_BUTTON_SUCCESS_SHADOW;
485 |     btn.style.color = "#fff";
486 |   }
487 | 
488 |   function countEligibleInputs(root = document) {
489 |     const scope = root && typeof root.querySelectorAll === "function" ? root : document;
490 |     const nodes = scope.querySelectorAll("input, textarea");
491 |     let count = 0;
492 |     for (const el of nodes) {
493 |       if (el.disabled || el.readOnly) continue;
494 |       const type = (el.getAttribute("type") || "text").toLowerCase();
495 |       if (skipTypes.has(type)) continue;
496 |       count += 1;
497 |     }
498 |     return count;
499 |   }
500 | 
501 |   function tryAutoFillStart() {
502 |     if (autoFillTriggered || remoteFillPromise) return;
503 |     const count = countEligibleInputs();
504 |     if (count >= MIN_INPUTS_FOR_AUTO) {
505 |       autoFillTriggered = true;
506 |       showDetectionNotice();
507 |       performRemoteFill().then((result) => {
508 |         if (result?.error) {
509 |           autoFillTriggered = false;
510 |         }
511 |       });
512 |     }
513 |   }
514 | 
515 |   function evaluateXPath(xpath) {
516 |     try {
517 |       const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
518 |       return result.singleNodeValue || null;
519 |     } catch (err) {
520 |       console.warn("[AutoForm] XPath 評価に失敗:", xpath, err);
521 |       return null;
522 |     }
523 |   }
524 | 
525 |   function setNodeValue(node, value, meta = {}) {
526 |     if (!node) return false;
527 |     const fieldType = (meta?.fieldType || meta?.existingData?.type || "").toLowerCase();
528 |     const choices = meta?.choices || meta?.existingData?.choices;
529 | 
530 |     if (node instanceof HTMLInputElement) {
531 |       const type = node.type.toLowerCase();
532 |       if (type === "checkbox") {
533 |         const shouldCheck = isTruthySelectionValue(value);
534 |         node.checked = shouldCheck;
535 |         node.dispatchEvent(new Event("input", { bubbles: true }));
536 |         node.dispatchEvent(new Event("change", { bubbles: true }));
537 |         node.dataset.autoformFilled = "1";
538 |         return true;
539 |       }
540 |       if (type === "radio") {
541 |         const shouldSelect = isTruthySelectionValue(value);
542 |         node.checked = shouldSelect;
543 |         node.dispatchEvent(new Event("input", { bubbles: true }));
544 |         node.dispatchEvent(new Event("change", { bubbles: true }));
545 |         node.dataset.autoformFilled = "1";
546 |         return true;
547 |       }
548 |       if (type === "file") return false;
549 |       setValue(node, value ?? "");
550 |       node.dataset.autoformFilled = "1";
551 |       return true;
552 |     }
553 | 
554 |     if (node instanceof HTMLTextAreaElement) {
555 |       setValue(node, value ?? "");
556 |       node.dataset.autoformFilled = "1";
557 |       return true;
558 |     }
559 | 
560 |     if (node instanceof HTMLSelectElement) {
561 |       const applied = selectOptions(node, value, choices);
562 |       if (applied) {
563 |         node.dataset.autoformFilled = "1";
564 |       }
565 |       return applied;
566 |     }
567 | 
568 |     if (node.isContentEditable) {
569 |       node.focus();
570 |       node.textContent = value ?? "";
571 |       node.dispatchEvent(new Event("input", { bubbles: true }));
572 |       node.dispatchEvent(new Event("change", { bubbles: true }));
573 |       return true;
574 |     }
575 | 
576 |     return false;
577 |   }
578 | 
579 |   function cssEscape(value) {
580 |     const str = String(value ?? "");
581 |     if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
582 |       return CSS.escape(str);
583 |     }
584 |     return str.replace(/["\\]/g, "\\$&");
585 |   }
586 | 
587 |   function findSendContentTarget(key) {
588 |     if (!key) return null;
589 |     const escaped = cssEscape(key);
590 |     const selectors = [
591 |       `input[name="${escaped}"]`,
592 |       `textarea[name="${escaped}"]`,
593 |       `select[name="${escaped}"]`,
594 |       `input[id="${escaped}"]`,
595 |       `textarea[id="${escaped}"]`,
596 |       `select[id="${escaped}"]`
597 |     ];
598 |     for (const selector of selectors) {
599 |       try {
600 |         const el = document.querySelector(selector);
601 |         if (el) return el;
602 |       } catch (err) {
603 |         console.warn("[AutoForm] セレクタ解析に失敗:", selector, err);
604 |       }
605 |     }
606 |     const lowerKey = String(key).toLowerCase();
607 |     const fuzzyCandidates = Array.from(document.querySelectorAll("input, textarea, select"));
608 |     for (const el of fuzzyCandidates) {
609 |       const name = (el.getAttribute("name") || "").toLowerCase();
610 |       const id = (el.id || "").toLowerCase();
611 |       const placeholder = (el.getAttribute("placeholder") || "").toLowerCase();
612 |       if (name.includes(lowerKey) || id.includes(lowerKey) || placeholder.includes(lowerKey)) {
613 |         return el;
614 |       }
615 |     }
616 |     return null;
617 |   }
618 | 
619 |   function shouldClickNode(node, condition, value, fieldType = "") {
620 |     if (!node) return false;
621 |     const normalizedFieldType = (fieldType || "").toLowerCase();
622 |     if (normalizedFieldType && normalizedFieldType !== "button") {
623 |       return false;
624 |     }
625 |     const targetCondition = String(condition || "").toLowerCase();
626 |     const valueStr = typeof value === "string" ? value.toLowerCase() : "";
627 |     const wantsClick = targetCondition.includes("click") || valueStr === "click";
628 |     if (!wantsClick) return false;
629 | 
630 |     const tag = (node.tagName || "").toLowerCase();
631 |     if (tag === "button") return false;
632 |     if (node instanceof HTMLInputElement) {
633 |       const type = node.type.toLowerCase();
634 |       if (type === "button" || type === "submit" || type === "reset") {
635 |         return false;
636 |       }
637 |     }
638 |     return true;
639 |   }
640 | 
641 |   function applyJsonInstructions(items) {
642 |     if (!Array.isArray(items)) {
643 |       return { total: 0, success: 0, skipped: 0 };
644 |     }
645 |     let success = 0;
646 |     let skipped = 0;
647 | 
648 |     for (const item of items) {
649 |       const xpath = item?.existing_data?.xpath;
650 |       if (!xpath) {
651 |         skipped += 1;
652 |         continue;
653 |       }
654 |       const target = evaluateXPath(xpath);
655 |       if (!target) {
656 |         skipped += 1;
657 |         continue;
658 |       }
659 |       const existing = item?.existing_data || {};
660 |       const value = item?.input_data?.value ?? "";
661 |       const condition = (item?.input_data?.match_condition || "").toLowerCase();
662 | 
663 |       if (shouldClickNode(target, condition, value, existing.type)) {
664 |         try {
665 |           target.focus();
666 |           target.click();
667 |           success += 1;
668 |         } catch (err) {
669 |           console.warn("[AutoForm] クリックに失敗:", err);
670 |           skipped += 1;
671 |         }
672 |         continue;
673 |       }
674 | 
675 |       const applied = setNodeValue(target, value, {
676 |         existingData: existing,
677 |         fieldType: existing.type,
678 |         choices: existing.choices,
679 |         inputData: item?.input_data
680 |       });
681 |       if (applied) {
682 |         success += 1;
683 |       } else {
684 |         skipped += 1;
685 |       }
686 |     }
687 | 
688 |     return { total: items.length, success, skipped };
689 |   }
690 | 
691 |   function applySendContent(payload) {
692 |     if (!payload || Array.isArray(payload) || typeof payload !== "object") {
693 |       return { total: 0, success: 0, filledKeys: [] };
694 |     }
695 |     const entries = Object.entries(payload);
696 |     const filledKeys = [];
697 |     let success = 0;
698 | 
699 |     for (const [key, value] of entries) {
700 |       const target = findSendContentTarget(key);
701 |       if (!target) continue;
702 |       const applied = setNodeValue(target, value);
703 |       if (applied) {
704 |         success += 1;
705 |         filledKeys.push(key);
706 |       }
707 |     }
708 | 
709 |     if (success > 0) showCompletionNotice();
710 |     return { total: entries.length, success, filledKeys };
711 |   }
712 | 
713 |   function handleCommand(command, payload) {
714 |     if (command === "autoform_execute_json") {
715 |       const applied = applyJsonInstructions(payload);
716 |       if (applied.success > 0) {
717 |         showCompletionNotice();
718 |       }
719 |       return { applied };
720 |     }
721 |     if (command === "autoform_manual_fill") {
722 |       return performRemoteFill().then((result) => {
723 |         if (result?.applied) {
724 |           return {
725 |             filled: result.applied.success || 0,
726 |             applied: result.applied
727 |           };
728 |         }
729 |         return { error: result?.error || "入力に失敗しました" };
730 |       });
731 |     }
732 |     if (command === "autoform_count_inputs") {
733 |       return { count: countEligibleInputs(document) };
734 |     }
735 |     if (command === "autoform_apply_send_content") {
736 |       const sendContentResult = applySendContent(payload);
737 |       return { sendContent: sendContentResult };
738 |     }
739 |     return null;
740 |   }
741 | 
742 |   function stopObservation() {
743 |     if (observer) {
744 |       observer.disconnect();
745 |       observer = null;
746 |     }
747 |     if (observerTimer) {
748 |       clearTimeout(observerTimer);
749 |       observerTimer = null;
750 |     }
751 |   }
752 | 
753 |   function disableAutoFill() {
754 |     if (!started) return;
755 |     stopObservation();
756 |     autoFillTriggered = false;
757 |     remoteFillPromise = null;
758 |     started = false;
759 |   }
760 | 
761 |   function startAutoFill() {
762 |     if (started) return;
763 |     if (document.querySelector('input[type="password"]')) return; // ガード
764 |     started = true;
765 |     detectionNoticeShown = false;
766 |     autoFillTriggered = false;
767 |     remoteFillPromise = null;
768 | 
769 |     const run = () => tryAutoFillStart();
770 |     if (document.readyState === "loading") {
771 |       document.addEventListener("DOMContentLoaded", run, { once: true });
772 |     } else {
773 |       run();
774 |     }
775 | 
776 |     observer = new MutationObserver(() => {
777 |       if (!autoFillTriggered) {
778 |         tryAutoFillStart();
779 |       }
780 |     });
781 |     observer.observe(document.documentElement, { childList: true, subtree: true });
782 | 
783 |     observerTimer = setTimeout(() => {
784 |       stopObservation();
785 |     }, 10000);
786 |   }
787 | 
788 |   function updateAutoFillState() {
789 |     if (masterEnabled && autoRunOnOpen) {
790 |       startAutoFill();
791 |     } else {
792 |       disableAutoFill();
793 |     }
794 |   }
795 | 
796 |   function applyEnabledState(enabled) {
797 |     masterEnabled = enabled !== false;
798 |     updateAutoFillState();
799 |   }
800 | 
801 |   function applyAutoRunState(value) {
802 |     autoRunOnOpen = value !== false;
803 |     updateAutoFillState();
804 |   }
805 | 
806 |   function init() {
807 |     if (!chrome?.storage?.sync) {
808 |       startAutoFill();
809 |       updateFloatingButtonVisibility(false);
810 |       return;
811 |     }
812 | 
813 |     chrome.storage.sync.get([STORAGE_KEY, AUTO_RUN_STORAGE_KEY, FLOATING_BUTTON_STORAGE_KEY], (res) => {
814 |       applyEnabledState(res[STORAGE_KEY]);
815 |       applyAutoRunState(res[AUTO_RUN_STORAGE_KEY]);
816 |       updateFloatingButtonVisibility(res[FLOATING_BUTTON_STORAGE_KEY] === true);
817 |     });
818 | 
819 |     chrome.storage.onChanged.addListener((changes, area) => {
820 |       if (area !== "sync") return;
821 |       if (changes[STORAGE_KEY]) {
822 |         applyEnabledState(changes[STORAGE_KEY].newValue !== false);
823 |       }
824 |       if (changes[AUTO_RUN_STORAGE_KEY]) {
825 |         applyAutoRunState(changes[AUTO_RUN_STORAGE_KEY].newValue !== false);
826 |       }
827 |       if (changes[FLOATING_BUTTON_STORAGE_KEY]) {
828 |         updateFloatingButtonVisibility(changes[FLOATING_BUTTON_STORAGE_KEY].newValue === true);
829 |       }
830 |     });
831 | 
832 |     if (chrome?.runtime?.onMessage) {
833 |       chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
834 |         if (!message?.type || !KNOWN_MESSAGE_TYPES.has(message.type)) {
835 |           return;
836 |         }
837 |         try {
838 |           const response = handleCommand(message.type, message.payload);
839 |           if (response && typeof response.then === "function") {
840 |             response
841 |               .then((res) => sendResponse(res))
842 |               .catch((err) => {
843 |                 console.error("[AutoForm] メッセージ応答エラー", err);
844 |                 sendResponse({ error: err?.message || "未知のエラー" });
845 |               });
846 |             return true;
847 |           }
848 |           sendResponse(response);
849 |         } catch (err) {
850 |           console.error("[AutoForm] メッセージ処理でエラー", err);
851 |           sendResponse({ error: err?.message || "未知のエラー" });
852 |         }
853 |       });
854 |     }
855 |   }
856 | 
857 |   init();
858 | })();
--------------------------------------------------------------------------------

/icons/icon-original.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon128.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon16.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon24.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon32.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/icons/icon48.png:
--------------------------------------------------------------------------------
[ERROR READING FILE]: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
--------------------------------------------------------------------------------

/options.html:
--------------------------------------------------------------------------------
  1 | <!doctype html>
  2 | <html lang="ja">
  3 |   <head>
  4 |     <meta charset="utf-8">
  5 |     <title>AutoForm 設定</title>
  6 |     <style>
  7 |       body {
  8 |         font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  9 |         margin: 24px;
 10 |         color: #0f172a;
 11 |         background: #f8fafc;
 12 |       }
 13 |       .settings-card {
 14 |         max-width: 480px;
 15 |         background: #ffffff;
 16 |         border-radius: 20px;
 17 |         padding: 24px;
 18 |         box-shadow: 0 25px 45px rgba(15, 23, 42, 0.12);
 19 |       }
 20 |       .settings-card h1 {
 21 |         margin: 0 0 16px;
 22 |         font-size: 22px;
 23 |       }
 24 |       .master-toggle-container {
 25 |         display: flex;
 26 |         align-items: center;
 27 |         justify-content: space-between;
 28 |         gap: 20px;
 29 |         padding: 8px 0 4px;
 30 |       }
 31 |       .master-toggle-title {
 32 |         font-size: 16px;
 33 |         font-weight: 700;
 34 |         margin: 0;
 35 |       }
 36 |       .master-toggle-desc {
 37 |         margin: 6px 0 0;
 38 |         font-size: 13px;
 39 |         color: #475569;
 40 |       }
 41 |       .ios-switch {
 42 |         position: relative;
 43 |         display: inline-flex;
 44 |         width: 70px;
 45 |         height: 38px;
 46 |       }
 47 |       .ios-switch input {
 48 |         opacity: 0;
 49 |         width: 0;
 50 |         height: 0;
 51 |         position: absolute;
 52 |       }
 53 |       .ios-slider {
 54 |         position: absolute;
 55 |         inset: 0;
 56 |         border-radius: 999px;
 57 |         background: #cbd5f5;
 58 |         cursor: pointer;
 59 |         transition: background 0.25s ease, box-shadow 0.25s ease;
 60 |       }
 61 |       .ios-slider::after {
 62 |         content: "";
 63 |         position: absolute;
 64 |         width: 32px;
 65 |         height: 32px;
 66 |         top: 3px;
 67 |         left: 3px;
 68 |         background: #ffffff;
 69 |         border-radius: 50%;
 70 |         box-shadow: 0 8px 18px rgba(15, 23, 42, 0.25);
 71 |         transition: transform 0.25s ease;
 72 |       }
 73 |       .ios-switch input:checked + .ios-slider {
 74 |         background: linear-gradient(135deg, #34d399, #0ea5e9);
 75 |         box-shadow: 0 14px 24px rgba(14, 165, 233, 0.35);
 76 |       }
 77 |       .ios-switch input:checked + .ios-slider::after {
 78 |         transform: translateX(32px);
 79 |       }
 80 |       .helper-text {
 81 |         margin-top: 18px;
 82 |         font-size: 14px;
 83 |         color: #64748b;
 84 |       }
 85 |     </style>
 86 |   </head>
 87 |   <body>
 88 |     <div class="settings-card">
 89 |       <h1>AutoForm 設定</h1>
 90 |       <div class="master-toggle-container">
 91 |         <div>
 92 |           <p class="master-toggle-title">拡張機能を有効にする</p>
 93 |           <p class="master-toggle-desc" id="master-toggle-status-text">Aimsales AutoForm が有効です</p>
 94 |         </div>
 95 |         <label class="ios-switch">
 96 |           <input type="checkbox" id="extension-master-toggle" aria-label="拡張機能のON/OFF" />
 97 |           <span class="ios-slider" aria-hidden="true"></span>
 98 |         </label>
 99 |       </div>
100 |       <p class="helper-text">OFFにすると、Aimsales AutoForm はページに何も挿入しません。</p>
101 |     </div>
102 |     <script src="settings.js" defer></script>
103 |   </body>
104 | </html>
--------------------------------------------------------------------------------

/popup.html:
--------------------------------------------------------------------------------
  1 | <!doctype html>
  2 | <html lang="ja">
  3 |   <head>
  4 |     <meta charset="utf-8" />
  5 |     <title>Aimsales AutoForm</title>
  6 |     <style>
  7 |       :root {
  8 |         color-scheme: light;
  9 |       }
 10 |       * {
 11 |         box-sizing: border-box;
 12 |       }
 13 |       body {
 14 |         font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
 15 |         margin: 0;
 16 |         padding: 20px;
 17 |         width: 340px;
 18 |         color: #0f172a;
 19 |         background: linear-gradient(180deg, #f8fafc 0%, #eef2ff 60%, #e0f2fe 100%);
 20 |       }
 21 |       h1 {
 22 |         font-size: 18px;
 23 |         margin: 0;
 24 |         letter-spacing: 0.02em;
 25 |       }
 26 |       a {
 27 |         color: #2563eb;
 28 |         text-decoration: none;
 29 |       }
 30 |       a:hover {
 31 |         text-decoration: underline;
 32 |       }
 33 |       .app-header {
 34 |         display: flex;
 35 |         gap: 14px;
 36 |         align-items: center;
 37 |         padding: 16px;
 38 |         border-radius: 18px;
 39 |         background: #ffffff;
 40 |         box-shadow: 0 18px 30px rgba(15, 23, 42, 0.12);
 41 |         margin-bottom: 18px;
 42 |       }
 43 |       .app-header img {
 44 |         width: 60px;
 45 |         height: 60px;
 46 |         border-radius: 14px;
 47 |         object-fit: cover;
 48 |         box-shadow: 0 18px 26px rgba(79, 70, 229, 0.3);
 49 |       }
 50 |       .app-header .tagline {
 51 |         margin: 6px 0 0;
 52 |         font-size: 12px;
 53 |         color: #64748b;
 54 |       }
 55 |       .surface-card {
 56 |         background: #ffffff;
 57 |         border-radius: 16px;
 58 |         padding: 16px;
 59 |         box-shadow: 0 14px 24px rgba(15, 23, 42, 0.08);
 60 |         margin-bottom: 16px;
 61 |       }
 62 |       .promo-text {
 63 |         font-size: 13px;
 64 |         line-height: 1.6;
 65 |         color: #475569;
 66 |         margin: 0;
 67 |       }
 68 |       .primary-btn,
 69 |       .ghost-btn,
 70 |       .section-toggle {
 71 |         width: 100%;
 72 |         border-radius: 12px;
 73 |         padding: 11px 16px;
 74 |         font-size: 14px;
 75 |         font-weight: 600;
 76 |         cursor: pointer;
 77 |         transition: transform 0.12s ease, box-shadow 0.12s ease;
 78 |         border: none;
 79 |         background: transparent;
 80 |       }
 81 |       .primary-btn {
 82 |         background: linear-gradient(135deg, #0ea5e9, #6366f1);
 83 |         color: #fff;
 84 |         box-shadow: 0 16px 26px rgba(99, 102, 241, 0.3);
 85 |       }
 86 |       .primary-btn:disabled {
 87 |         opacity: 0.5;
 88 |         cursor: not-allowed;
 89 |         box-shadow: none;
 90 |       }
 91 |       .primary-btn:not(:disabled):hover,
 92 |       .ghost-btn:not(:disabled):hover,
 93 |       .section-toggle:hover {
 94 |         transform: translateY(-1px);
 95 |         box-shadow: 0 16px 24px rgba(15, 23, 42, 0.12);
 96 |       }
 97 |       .ghost-btn {
 98 |         background: transparent;
 99 |         color: #0f172a;
100 |         border: 1px solid rgba(148, 163, 184, 0.7);
101 |       }
102 |       .master-control-card {
103 |         margin-bottom: 18px;
104 |       }
105 |       .master-toggle-container {
106 |         display: flex;
107 |         align-items: center;
108 |         justify-content: space-between;
109 |         gap: 16px;
110 |         padding-bottom: 14px;
111 |         margin-bottom: 12px;
112 |         border-bottom: 1px solid rgba(148, 163, 184, 0.35);
113 |       }
114 |       .master-toggle-title {
115 |         font-size: 15px;
116 |         font-weight: 700;
117 |         margin: 0;
118 |         color: #0f172a;
119 |       }
120 |       .master-toggle-desc {
121 |         margin: 6px 0 0;
122 |         font-size: 12px;
123 |         color: #64748b;
124 |       }
125 |       .ios-switch {
126 |         position: relative;
127 |         display: inline-flex;
128 |         width: 62px;
129 |         height: 34px;
130 |       }
131 |       .ios-switch input {
132 |         opacity: 0;
133 |         width: 0;
134 |         height: 0;
135 |         position: absolute;
136 |       }
137 |       .ios-slider {
138 |         position: absolute;
139 |         cursor: pointer;
140 |         inset: 0;
141 |         background: #cbd5f5;
142 |         border-radius: 999px;
143 |         transition: background 0.25s ease, box-shadow 0.25s ease;
144 |       }
145 |       .ios-slider::after {
146 |         content: "";
147 |         position: absolute;
148 |         width: 30px;
149 |         height: 30px;
150 |         left: 2px;
151 |         top: 2px;
152 |         background: #ffffff;
153 |         border-radius: 50%;
154 |         box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
155 |         transition: transform 0.25s ease;
156 |       }
157 |       .ios-switch input:checked + .ios-slider {
158 |         background: linear-gradient(135deg, #34d399, #0ea5e9);
159 |         box-shadow: 0 10px 20px rgba(14, 165, 233, 0.35);
160 |       }
161 |       .ios-switch input:checked + .ios-slider::after {
162 |         transform: translateX(28px);
163 |       }
164 |       .status-text {
165 |         margin: 10px 0 0;
166 |         font-size: 12px;
167 |         color: #64748b;
168 |       }
169 |       .status-text.error {
170 |         color: #dc2626;
171 |       }
172 |       .section-label {
173 |         font-size: 13px;
174 |         font-weight: 600;
175 |         display: block;
176 |         margin-bottom: 10px;
177 |         color: #475569;
178 |       }
179 |       .section-toggle {
180 |         display: flex;
181 |         align-items: center;
182 |         justify-content: space-between;
183 |         padding: 0;
184 |         margin-bottom: 12px;
185 |         color: #0f172a;
186 |         border-radius: 0;
187 |         font-size: 14px;
188 |       }
189 |       .section-toggle .chevron {
190 |         font-size: 20px;
191 |         line-height: 1;
192 |         transition: transform 0.2s ease;
193 |         color: #94a3b8;
194 |       }
195 |       .section-toggle.open .chevron {
196 |         transform: rotate(180deg);
197 |       }
198 |       .send-field-group {
199 |         display: flex;
200 |         flex-direction: column;
201 |         gap: 10px;
202 |         margin-top: 6px;
203 |       }
204 |       .send-field-label {
205 |         font-size: 12px;
206 |         color: #475569;
207 |       }
208 |       .send-field-input {
209 |         width: 100%;
210 |         padding: 8px 10px;
211 |         border: 1px solid #d1d5db;
212 |         border-radius: 8px;
213 |         font-size: 12px;
214 |         background: #fff;
215 |         transition: border 0.2s, box-shadow 0.2s;
216 |       }
217 |       .send-field-input:focus {
218 |         border-color: #2563eb;
219 |         box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
220 |         outline: none;
221 |       }
222 |       .send-content-body.collapsed {
223 |         display: none;
224 |       }
225 |       .settings-group {
226 |         display: flex;
227 |         flex-direction: column;
228 |         gap: 10px;
229 |       }
230 |       .settings-card[data-master-scope="dependents"].master-off .section-label,
231 |       .settings-card[data-master-scope="dependents"].master-off .settings-group {
232 |         opacity: 0.45;
233 |         pointer-events: none;
234 |       }
235 |       .toggle-label {
236 |         display: flex;
237 |         align-items: center;
238 |         gap: 10px;
239 |         font-size: 13px;
240 |         font-weight: 500;
241 |         color: #0f172a;
242 |       }
243 |       .toggle-label.secondary {
244 |         color: #475569;
245 |         font-size: 13px;
246 |       }
247 |       #curl-details,
248 |       #api-details {
249 |         display: none;
250 |         margin: 10px 0 0;
251 |         padding: 12px;
252 |         background: #0f172a;
253 |         color: #e2e8f0;
254 |         border-radius: 12px;
255 |         font-size: 11px;
256 |         line-height: 1.4;
257 |         max-height: 180px;
258 |         overflow: auto;
259 |         border: 1px solid rgba(148, 163, 184, 0.25);
260 |       }
261 |       .detail-status {
262 |         display: block;
263 |         margin: -6px 0 4px;
264 |         font-size: 11px;
265 |         color: #94a3b8;
266 |       }
267 |       .detail-status.has-data {
268 |         color: #059669;
269 |         font-weight: 600;
270 |       }
271 |       .detail-status.error {
272 |         color: #dc2626;
273 |       }
274 |       .ghost-btn.data-available {
275 |         border-color: rgba(16, 185, 129, 0.5);
276 |         background: rgba(16, 185, 129, 0.1);
277 |         color: #065f46;
278 |       }
279 |     </style>
280 |   </head>
281 |   <body>
282 |     <div class="surface-card settings-card master-control-card">
283 |       <div class="master-toggle-container">
284 |         <div>
285 |           <p class="master-toggle-title">Aimsales AutoForm</p>
286 |           <p class="master-toggle-desc" id="master-toggle-status-text">拡張機能は有効です</p>
287 |         </div>
288 |         <label class="ios-switch">
289 |           <input type="checkbox" id="extension-master-toggle" aria-label="拡張機能のON/OFF" />
290 |           <span class="ios-slider" aria-hidden="true"></span>
291 |         </label>
292 |       </div>
293 |     </div>
294 | 
295 |     <div class="app-header">
296 |       <img src="aimsales_logo.png" alt="AimSales" />
297 |       <div>
298 |         <h1>Aimsales AutoForm</h1>
299 |         <p class="tagline">Smart autofill for modern sales ops</p>
300 |       </div>
301 |     </div>
302 | 
303 |     <div class="surface-card">
304 |       <p class="promo-text">
305 |         <strong>【有料プランのご案内】</strong><br />
306 |         Aimsalesでは生成AIによる高品質な文章でフォーム営業が可能(返信率80倍以上⤴️)<br />
307 |         さらに500万社以上の企業データにより、メール営業、フォーム一括営業など可能。詳しくはこちら →
308 |         <a href="https://aimsales.jp/" target="_blank" rel="noreferrer noopener">https://aimsales.jp/</a> 。
309 |       </p>
310 |     </div>
311 | 
312 |     <div class="surface-card">
313 |       <button id="fill-now" class="primary-btn">入力を実行</button>
314 |       <p id="manual-status" class="status-text">未実行</p>
315 |     </div>
316 | 
317 |     <div class="surface-card" id="input-config-card">
318 |       <button type="button" class="section-toggle open" id="send-content-toggle" aria-expanded="true">
319 |         <span>入力項目の設定</span>
320 |         <span class="chevron">▼</span>
321 |       </button>
322 |       <div class="send-content-body" id="send-content-body" aria-hidden="false">
323 |         <p id="send-content-warning" class="status-text error" style="display:none;margin-top:0;">
324 |           全ての入力項目を埋めてください
325 |         </p>
326 |         <div class="send-field-group">
327 |           <div class="send-field">
328 |             <label class="send-field-label" for="send-field-name">お名前（姓名の間に半角スペース）</label>
329 |             <input class="send-field-input" data-send-field="name" id="send-field-name" type="text" placeholder="例: 山田 太郎" />
330 |           </div>
331 |           <div class="send-field">
332 |             <label class="send-field-label" for="send-field-name-kana">お名前（かな）</label>
333 |             <input class="send-field-input" data-send-field="name_kana" id="send-field-name-kana" type="text" placeholder="例: やまだ たろう" />
334 |           </div>
335 |           <div class="send-field">
336 |             <label class="send-field-label" for="send-field-company">会社名</label>
337 |             <input class="send-field-input" data-send-field="company" id="send-field-company" type="text" placeholder="例: 株式会社〇〇" />
338 |           </div>
339 |           <div class="send-field">
340 |             <label class="send-field-label" for="send-field-company-kana">会社名（かな）</label>
341 |             <input class="send-field-input" data-send-field="company_kana" id="send-field-company-kana" type="text" placeholder="例: かぶしきがいしゃ 〇〇" />
342 |           </div>
343 |           <div class="send-field">
344 |             <label class="send-field-label" for="send-field-dept">部署</label>
345 |             <input class="send-field-input" data-send-field="部署" id="send-field-dept" type="text" placeholder="例: 営業部" />
346 |           </div>
347 |           <div class="send-field">
348 |             <label class="send-field-label" for="send-field-title">タイトル</label>
349 |             <input class="send-field-input" data-send-field="title" id="send-field-title" type="text" placeholder="例: サービスのご提案" />
350 |           </div>
351 |           <div class="send-field">
352 |             <label class="send-field-label" for="send-field-postal">郵便番号</label>
353 |             <input class="send-field-input" data-send-field="postal_code" id="send-field-postal" type="text" placeholder="例: 123-4567" />
354 |           </div>
355 |           <div class="send-field">
356 |             <label class="send-field-label" for="send-field-address">住所</label>
357 |             <input class="send-field-input" data-send-field="住所" id="send-field-address" type="text" placeholder="例: 東京都千代田区..." />
358 |           </div>
359 |           <div class="send-field">
360 |             <label class="send-field-label" for="send-field-prefecture">都道府県</label>
361 |             <input class="send-field-input" data-send-field="prefecture" id="send-field-prefecture" type="text" placeholder="例: 東京都" />
362 |           </div>
363 |           <div class="send-field">
364 |             <label class="send-field-label" for="send-field-industry">業種</label>
365 |             <input class="send-field-input" data-send-field="業種" id="send-field-industry" type="text" placeholder="例: ITサービス" />
366 |           </div>
367 |           <div class="send-field">
368 |             <label class="send-field-label" for="send-field-email">メールアドレス</label>
369 |             <input class="send-field-input" data-send-field="email" id="send-field-email" type="email" placeholder="例: sample@example.com" />
370 |           </div>
371 |           <div class="send-field">
372 |             <label class="send-field-label" for="send-field-tel">電話番号</label>
373 |             <input class="send-field-input" data-send-field="tel" id="send-field-tel" type="tel" placeholder="例: 03-1234-5678" />
374 |           </div>
375 |           <div class="send-field">
376 |             <label class="send-field-label" for="send-field-fax">FAX</label>
377 |             <input class="send-field-input" data-send-field="fax" id="send-field-fax" type="tel" placeholder="例: 03-1234-5678" />
378 |           </div>
379 |           <div class="send-field">
380 |             <label class="send-field-label" for="send-field-url">Webサイト</label>
381 |             <input class="send-field-input" data-send-field="URL" id="send-field-url" type="url" placeholder="https://example.com" />
382 |           </div>
383 |           <div class="send-field">
384 |             <label class="send-field-label" for="send-field-remark">メッセージ</label>
385 |             <textarea class="send-field-input" data-send-field="remark" id="send-field-remark" rows="4" style="resize: vertical;"></textarea>
386 |           </div>
387 |         </div>
388 |         <div class="send-actions">
389 |           <button id="save-send-content" class="ghost-btn" style="flex: 1;">
390 |             内容を保存
391 |           </button>
392 |         </div>
393 |         <p id="send-content-status" class="status-text">未保存</p>
394 |       </div>
395 |     </div>
396 | 
397 |     <div class="surface-card settings-card" data-master-scope="dependents">
398 |       <span class="section-label">設定</span>
399 |       <div class="settings-group">
400 |         <label class="toggle-label">
401 |           <input type="checkbox" id="autoform-toggle" data-master-controlled />
402 |           開いた瞬間の自動入力を有効にする
403 |         </label>
404 |         <label class="toggle-label secondary">
405 |           <input type="checkbox" id="show-floating-button" data-master-controlled />
406 |           画面右下に、常にボタンを表示する
407 |         </label>
408 |         <button id="show-curl-details" class="ghost-btn" data-master-controlled>curl詳細</button>
409 |         <span id="curl-details-status" class="detail-status">データ未検知</span>
410 |         <pre id="curl-details"></pre>
411 |         <button id="show-api-details" class="ghost-btn" data-master-controlled>レスポンス詳細</button>
412 |         <span id="api-details-status" class="detail-status">未取得</span>
413 |         <pre id="api-details"></pre>
414 |       </div>
415 |     </div>
416 | 
417 |     <script src="settings.js" defer></script>
418 |     <script src="popup.js" defer></script>
419 |   </body>
420 | </html>
--------------------------------------------------------------------------------

/popup.js:
--------------------------------------------------------------------------------
  1 | (() => {
  2 |   const DATA_KEY = "autoformImportedJson";
  3 |   const SEND_STORAGE_KEY = "autoformSendContent";
  4 |   const FLOATING_BUTTON_STORAGE_KEY = "autoformShowFloatingButton";
  5 |   const AUTO_BUTTON_STORAGE_KEY = "autoformShowAutoButton";
  6 |   const DEFAULT_SEND_CONTENT = {
  7 |     name: "阿部 由希子",
  8 |     name_kana: "あべ ゆきこ",
  9 |     company: "株式会社LASSIC",
 10 |     "部署": "Remogu事業部",
 11 |     "住所": "東京都港区高輪1-3-13 NBF高輪ビル 4F",
 12 |     postal_code: "108-0074",
 13 |     company_kana: "かぶしきがいしゃ らしっく",
 14 |     prefecture: "東京都",
 15 |     email: "y.abe@lassic.co.jp",
 16 |     tel: "03-6455-7720",
 17 |     fax: "03-6455-7720",
 18 |     title: "エンジニア採用・調達に関する新規お打ち合わせのご提案",
 19 |     "業種": "IT人材紹介サービス",
 20 |     URL: "https://www.lassic.co.jp",
 21 |     remark: "お世話になっております。\n株式会社LASSICの阿部と申します。\n\n本日はエンジニア採用・調達における新規のお打ち合わせの件でご連絡いたしました。\n\n弊社ではIT人材特化型の紹介サービスを展開しておりまして、全国47都道府県から集客した1万人超のデータベースを基に、エンジニアをご紹介させていただいております。\n直近では「React、Next.jsでのフロントエンド開発」のご経験をお持ちの方や「PM、テックリード」のご経験をお持ちの方にも多数ご登録いただいております。\n\nRemoguサービスの強み：\n★実務経験3年以上の即戦力エンジニア/デザイナーが1万8000名ご登録\n★フルリモートワークからハイブリッドワークが可能な方まで幅広い人材バラエティ\n★フリーランス人材/中途採用双方でご支援可能\n★直近上流工程の開発やPM/PL・テックリードのご経験をお持ちの方の流入あり\n★開発系の言語からAI系、ゲーム系言語まで対応可能\n\nこちらのリンクより弊サービスについてご確認いただけますので、ご判断の材料にしていただけますと幸いです。\nhttps://www.lassic.co.jp/service/remogu/\n\nご多忙の中大変恐縮ではございますが、一度オンラインでのお打ち合わせの機会をいただけないでしょうか。\n現時点でのご活用ではなく、情報交換でも構いません。\nもしお話可能でしたら、オンラインにて30～60分ほどミーティングの機会をいただけますと幸いです。\n\n日程調整：https://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\nご検討のほど、よろしくお願い申し上げます。"
 22 |   };
 23 | 
 24 |   let currentData = null;
 25 |   let currentSendContent = null;
 26 | 
 27 |   function qs(id) {
 28 |     return document.getElementById(id);
 29 |   }
 30 | 
 31 |   function setStatus(message, isError = false) {
 32 |     const statusEl = qs("import-status");
 33 |     if (statusEl) {
 34 |       statusEl.textContent = message;
 35 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 36 |     }
 37 |     updateExecuteState();
 38 |   }
 39 | 
 40 |   function setManualStatus(message, isError = false) {
 41 |     const statusEl = qs("manual-status");
 42 |     if (statusEl) {
 43 |       statusEl.textContent = message;
 44 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 45 |     }
 46 |   }
 47 | 
 48 |   function setInputCountStatus(message, isError = false) {
 49 |     const countEl = qs("input-count");
 50 |     if (countEl) {
 51 |       countEl.textContent = message;
 52 |       countEl.style.color = isError ? "#b91c1c" : "#555";
 53 |     }
 54 |   }
 55 | 
 56 |   function setSendContentStatus(message, isError = false) {
 57 |     const statusEl = qs("send-content-status");
 58 |     if (statusEl) {
 59 |       statusEl.textContent = message;
 60 |       statusEl.style.color = isError ? "#b91c1c" : "#555";
 61 |     }
 62 |   }
 63 | 
 64 |   function initFloatingButtonToggle(checkbox) {
 65 |     if (!checkbox) return;
 66 | 
 67 |     const apply = (value) => {
 68 |       checkbox.checked = value;
 69 |     };
 70 | 
 71 |     if (chrome?.storage?.sync) {
 72 |       chrome.storage.sync.get(FLOATING_BUTTON_STORAGE_KEY, (res) => {
 73 |         apply(res?.[FLOATING_BUTTON_STORAGE_KEY] === true);
 74 |       });
 75 |     } else {
 76 |       apply(false);
 77 |     }
 78 | 
 79 |     checkbox.addEventListener("change", () => {
 80 |       if (!chrome?.storage?.sync) return;
 81 |       chrome.storage.sync.set({ [FLOATING_BUTTON_STORAGE_KEY]: checkbox.checked });
 82 |     });
 83 |   }
 84 | 
 85 |   function initSendContentToggle(toggleEl, bodyEl, initiallyExpanded = false) {
 86 |     if (!toggleEl || !bodyEl) return;
 87 |     let expanded = initiallyExpanded;
 88 |     const applyState = () => {
 89 |       bodyEl.classList.toggle("collapsed", !expanded);
 90 |       bodyEl.setAttribute("aria-hidden", (!expanded).toString());
 91 |       toggleEl.classList.toggle("open", expanded);
 92 |       toggleEl.setAttribute("aria-expanded", expanded.toString());
 93 |     };
 94 |     applyState();
 95 |     toggleEl.addEventListener("click", () => {
 96 |       expanded = !expanded;
 97 |       applyState();
 98 |     });
 99 |   }
100 | 
101 |   function updateExecuteState() {
102 |     const btn = qs("execute-json");
103 |     if (btn) {
104 |       btn.disabled = !(currentData && currentData.length);
105 |     }
106 |   }
107 | 
108 |   function loadPersistedData() {
109 |     if (!chrome?.storage?.local) {
110 |       setStatus("storage が利用できません", true);
111 |       return;
112 |     }
113 |     chrome.storage.local.get(DATA_KEY, (res) => {
114 |       const stored = res?.[DATA_KEY];
115 |       if (Array.isArray(stored) && stored.length) {
116 |         currentData = stored;
117 |         setStatus(`前回読み込み: ${stored.length}件`);
118 |       } else {
119 |         setStatus("JSON未読み込み");
120 |       }
121 |     });
122 |   }
123 | 
124 |   function persistData() {
125 |     if (!chrome?.storage?.local) return;
126 |     chrome.storage.local.set({ [DATA_KEY]: currentData });
127 |   }
128 | 
129 |   function getSendContentFields() {
130 |     return Array.from(document.querySelectorAll("[data-send-field]"));
131 |   }
132 | 
133 |   function applySendContentToForm(data) {
134 |     const fields = getSendContentFields();
135 |     fields.forEach((el) => {
136 |       const key = el.dataset.sendField;
137 |       if (!key) return;
138 |       const value = data?.[key];
139 |       if (el.tagName === "TEXTAREA") {
140 |         el.value = value ?? "";
141 |       } else {
142 |         el.value = value ?? "";
143 |       }
144 |     });
145 |   }
146 | 
147 |   function readSendContentFromForm() {
148 |     const result = {};
149 |     const fields = getSendContentFields();
150 |     fields.forEach((el) => {
151 |       const key = el.dataset.sendField;
152 |       if (!key) return;
153 |       result[key] = el.value ?? "";
154 |     });
155 |     return result;
156 |   }
157 | 
158 |   function loadSendContent() {
159 |     if (!chrome?.storage?.local) {
160 |       currentSendContent = DEFAULT_SEND_CONTENT;
161 |       applySendContentToForm(currentSendContent);
162 |       setSendContentStatus("storage が利用できません (初期値のみ)", true);
163 |       return;
164 |     }
165 |     chrome.storage.local.get(SEND_STORAGE_KEY, (res) => {
166 |       const stored = res?.[SEND_STORAGE_KEY];
167 |       if (stored && typeof stored === "object" && !Array.isArray(stored)) {
168 |         currentSendContent = stored;
169 |         setSendContentStatus("保存済みの内容を読み込みました");
170 |       } else {
171 |         currentSendContent = DEFAULT_SEND_CONTENT;
172 |         setSendContentStatus("初期 SEND_CONTENT を読み込みました");
173 |       }
174 |       applySendContentToForm(currentSendContent);
175 |     });
176 |   }
177 | 
178 |   function persistSendContent() {
179 |     if (!chrome?.storage?.local || !currentSendContent) return;
180 |     chrome.storage.local.set({ [SEND_STORAGE_KEY]: currentSendContent });
181 |   }
182 | 
183 |   function handleFileChange(file) {
184 |     if (!file) return;
185 |     const reader = new FileReader();
186 |     reader.onload = () => {
187 |       try {
188 |         const parsed = JSON.parse(reader.result);
189 |         if (!Array.isArray(parsed)) {
190 |           throw new Error("JSONは配列形式である必要があります");
191 |         }
192 |         currentData = parsed;
193 |         persistData();
194 |         setStatus(`読み込み成功: ${parsed.length}件`);
195 |       } catch (err) {
196 |         currentData = null;
197 |         setStatus(`読み込み失敗: ${err.message}`, true);
198 |       }
199 |     };
200 |     reader.onerror = () => {
201 |       currentData = null;
202 |       setStatus("ファイル読み込みに失敗しました", true);
203 |     };
204 |     reader.readAsText(file);
205 |   }
206 | 
207 |   function getActiveTabId() {
208 |     return new Promise((resolve, reject) => {
209 |       if (!chrome?.tabs?.query) {
210 |         reject(new Error("tabs API が利用できません"));
211 |         return;
212 |       }
213 |       chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
214 |         const tab = tabs && tabs[0];
215 |         if (tab && typeof tab.id === "number") {
216 |           resolve(tab.id);
217 |         } else {
218 |           reject(new Error("アクティブなタブが見つかりません"));
219 |         }
220 |       });
221 |     });
222 |   }
223 | 
224 |   function getAllFrameIds(tabId) {
225 |     return new Promise((resolve, reject) => {
226 |       if (!chrome?.webNavigation?.getAllFrames) {
227 |         reject(new Error("webNavigation API が利用できません"));
228 |         return;
229 |       }
230 |       chrome.webNavigation.getAllFrames({ tabId }, (frames) => {
231 |         if (chrome.runtime.lastError) {
232 |           reject(new Error(chrome.runtime.lastError.message));
233 |           return;
234 |         }
235 |         if (!frames || !frames.length) {
236 |           resolve([0]);
237 |           return;
238 |         }
239 |         resolve(frames.map((frame) => frame.frameId));
240 |       });
241 |     });
242 |   }
243 | 
244 |   function fetchApiLog() {
245 |     return new Promise((resolve, reject) => {
246 |       if (!chrome?.runtime?.sendMessage) {
247 |         reject(new Error("runtime API が利用できません"));
248 |         return;
249 |       }
250 |       chrome.runtime.sendMessage({ type: "autoform_get_last_api_log" }, (response) => {
251 |         if (chrome.runtime.lastError) {
252 |           reject(new Error(chrome.runtime.lastError.message));
253 |           return;
254 |         }
255 |         resolve(response?.log || null);
256 |       });
257 |     });
258 |   }
259 | 
260 |   function fetchCurlLogs() {
261 |     return new Promise((resolve, reject) => {
262 |       if (!chrome?.runtime?.sendMessage) {
263 |         reject(new Error("runtime API が利用できません"));
264 |         return;
265 |       }
266 |       chrome.runtime.sendMessage({ type: "autoform_get_detected_curl_logs" }, (response) => {
267 |         if (chrome.runtime.lastError) {
268 |           reject(new Error(chrome.runtime.lastError.message));
269 |           return;
270 |         }
271 |         const logs = Array.isArray(response?.logs) ? response.logs : [];
272 |         resolve(logs);
273 |       });
274 |     });
275 |   }
276 | 
277 |   function formatApiLog(log) {
278 |     if (!log) {
279 |       return "まだAPIリクエストの履歴がありません。フォーム入力を実行してください。";
280 |     }
281 |     const lines = [];
282 |     const time = new Date(log.timestamp || Date.now()).toLocaleString();
283 |     lines.push(`取得時刻: ${time}`);
284 |     lines.push("");
285 |     lines.push("-- Request --");
286 |     lines.push(
287 |       JSON.stringify(
288 |         log.request || {},
289 |         null,
290 |         2
291 |       )
292 |     );
293 |     lines.push("");
294 |     if (log.error) {
295 |       lines.push(`-- Error --\n${log.error}`);
296 |     } else {
297 |       lines.push("-- Response --");
298 |       lines.push(
299 |         JSON.stringify(
300 |           log.response || {},
301 |           null,
302 |           2
303 |         )
304 |       );
305 |       lines.push("");
306 |       lines.push(`items_count: ${log.items_count ?? "不明"}`);
307 |     }
308 |     return lines.join("\n");
309 |   }
310 | 
311 |   async function handleShowApiDetails(btn, outputEl) {
312 |     if (!outputEl) return;
313 |     btn.disabled = true;
314 |     outputEl.style.display = "block";
315 |     outputEl.textContent = "取得中...";
316 |     try {
317 |       const log = await fetchApiLog();
318 |       outputEl.textContent = formatApiLog(log);
319 |     } catch (err) {
320 |       outputEl.textContent = `詳細取得に失敗しました: ${err.message}`;
321 |     } finally {
322 |       btn.disabled = false;
323 |     }
324 |   }
325 | 
326 |   function formatCurlLogs(logs) {
327 |     if (!Array.isArray(logs) || logs.length === 0) {
328 |       return "まだメールアドレスを含むリクエストを検知していません。フォーム送信後に再度お試しください。";
329 |     }
330 |     return logs
331 |       .map((log, index) => {
332 |         const lines = [];
333 |         const time = new Date(log.timestamp || Date.now()).toLocaleString();
334 |         lines.push(`#${index + 1} / ${time}`);
335 |         lines.push(`URL: ${log.url}`);
336 |         lines.push(`送信元URL: ${log.sourceUrl || "不明"}`);
337 |         lines.push(`Method: ${log.method || "不明"} / Status: ${log.statusCode ?? "不明"}`);
338 |         if (log.error) {
339 |           lines.push(`Error: ${log.error}`);
340 |         }
341 |         if (log.email) {
342 |           lines.push(`Email: ${log.email}`);
343 |         }
344 |         lines.push("curl:");
345 |         lines.push(log.curl || "(curl文字列なし)");
346 |         return lines.join("\n");
347 |       })
348 |       .join("\n\n");
349 |   }
350 | 
351 |   function formatDetailTimestamp(ts) {
352 |     if (!ts) return "";
353 |     try {
354 |       return new Date(ts).toLocaleString();
355 |     } catch (_) {
356 |       return "";
357 |     }
358 |   }
359 | 
360 |   function setDetailStatus(el, state, text) {
361 |     if (!el) return;
362 |     el.textContent = text;
363 |     el.dataset.state = state;
364 |     el.classList.toggle("has-data", state === "has-data");
365 |     el.classList.toggle("error", state === "error");
366 |   }
367 | 
368 |   function setDetailButtonState(btn, hasData) {
369 |     if (!btn) return;
370 |     btn.classList.toggle("data-available", !!hasData);
371 |   }
372 | 
373 |   async function refreshCurlDetailIndicator(options = {}) {
374 |     const indicator = qs("curl-details-status");
375 |     const btn = qs("show-curl-details");
376 |     if (!indicator) return;
377 |     if (!options.silent) {
378 |       setDetailStatus(indicator, "loading", "確認中…");
379 |     }
380 |     try {
381 |       const logs = await fetchCurlLogs();
382 |       if (Array.isArray(logs) && logs.length > 0) {
383 |         const latest = logs[0];
384 |         const time = formatDetailTimestamp(latest.timestamp);
385 |         setDetailStatus(indicator, "has-data", time ? `最新検知: ${time}` : "データあり");
386 |         setDetailButtonState(btn, true);
387 |       } else {
388 |         setDetailStatus(indicator, "empty", "データ未検知");
389 |         setDetailButtonState(btn, false);
390 |       }
391 |     } catch (_) {
392 |       setDetailStatus(indicator, "error", "取得エラー");
393 |       setDetailButtonState(btn, false);
394 |     }
395 |   }
396 | 
397 |   async function refreshApiDetailIndicator(options = {}) {
398 |     const indicator = qs("api-details-status");
399 |     const btn = qs("show-api-details");
400 |     if (!indicator) return;
401 |     if (!options.silent) {
402 |       setDetailStatus(indicator, "loading", "確認中…");
403 |     }
404 |     try {
405 |       const log = await fetchApiLog();
406 |       if (log) {
407 |         const time = formatDetailTimestamp(log.timestamp);
408 |         setDetailStatus(indicator, "has-data", time ? `最新取得: ${time}` : "データあり");
409 |         setDetailButtonState(btn, true);
410 |       } else {
411 |         setDetailStatus(indicator, "empty", "未取得");
412 |         setDetailButtonState(btn, false);
413 |       }
414 |     } catch (_) {
415 |       setDetailStatus(indicator, "error", "取得エラー");
416 |       setDetailButtonState(btn, false);
417 |     }
418 |   }
419 | 
420 |   async function refreshDetailIndicators(options = {}) {
421 |     await Promise.all([refreshCurlDetailIndicator(options), refreshApiDetailIndicator(options)]);
422 |   }
423 | 
424 |   async function handleShowCurlDetails(btn, outputEl) {
425 |     if (!outputEl) return;
426 |     btn.disabled = true;
427 |     outputEl.style.display = "block";
428 |     outputEl.textContent = "取得中...";
429 |     try {
430 |       const logs = await fetchCurlLogs();
431 |       outputEl.textContent = formatCurlLogs(logs);
432 |     } catch (err) {
433 |       outputEl.textContent = `curl情報の取得に失敗しました: ${err.message}`;
434 |     } finally {
435 |       btn.disabled = false;
436 |     }
437 |   }
438 | 
439 |   async function listFrameOrigins(tabId) {
440 |     const frames = await new Promise((resolve, reject) => {
441 |       if (!chrome?.webNavigation?.getAllFrames) {
442 |         reject(new Error("webNavigation API が利用できません"));
443 |         return;
444 |       }
445 |       chrome.webNavigation.getAllFrames({ tabId }, (res) => {
446 |         if (chrome.runtime.lastError) {
447 |           reject(new Error(chrome.runtime.lastError.message));
448 |           return;
449 |         }
450 |         resolve(res || []);
451 |       });
452 |     });
453 |     const origins = new Set();
454 |     for (const frame of frames) {
455 |       try {
456 |         if (!frame.url) continue;
457 |         const u = new URL(frame.url);
458 |         if (["chrome:", "about:", "data:"].includes(u.protocol)) continue;
459 |         origins.add(u.origin);
460 |       } catch (_) {
461 |         continue;
462 |       }
463 |     }
464 |     const topOrigin = await new Promise((resolve) => {
465 |       if (!chrome?.tabs?.get) {
466 |         resolve(null);
467 |         return;
468 |       }
469 |       chrome.tabs.get(tabId, (tab) => {
470 |         if (chrome.runtime.lastError) {
471 |           resolve(null);
472 |           return;
473 |         }
474 |         try {
475 |           resolve(new URL(tab?.url || "").origin);
476 |         } catch (_) {
477 |           resolve(null);
478 |         }
479 |       });
480 |     });
481 |     if (topOrigin) origins.delete(topOrigin);
482 |     return [...origins];
483 |   }
484 | 
485 |   async function ensureOriginsPermission(origins) {
486 |     const need = [];
487 |     for (const origin of origins) {
488 |       const has = await new Promise((resolve) => {
489 |         chrome.permissions.contains({ origins: [`${origin}/*`] }, (granted) => {
490 |           resolve(!!granted);
491 |         });
492 |       });
493 |       if (!has) need.push(origin);
494 |     }
495 |     if (!need.length) return true;
496 |     const ok = await new Promise((resolve) => {
497 |       chrome.permissions.request(
498 |         { origins: need.map((origin) => `${origin}/*`) },
499 |         (granted) => resolve(!!granted)
500 |       );
501 |     });
502 |     return ok;
503 |   }
504 | 
505 |   function sendCommandToFrame(tabId, frameId, command, payload) {
506 |     return new Promise((resolve) => {
507 |       chrome.tabs.sendMessage(
508 |         tabId,
509 |         { type: command, payload },
510 |         { frameId },
511 |         (response) => {
512 |           if (chrome.runtime.lastError) {
513 |             resolve({ error: chrome.runtime.lastError.message });
514 |             return;
515 |           }
516 |           resolve(response || {});
517 |         }
518 |       );
519 |     });
520 |   }
521 | 
522 |   async function refreshDetectedInputCount() {
523 |     setInputCountStatus("検知数: 取得中…");
524 |     try {
525 |       const tabId = await getActiveTabId();
526 |       const frameIds = await getAllFrameIds(tabId);
527 |       const results = await Promise.all(
528 |         frameIds.map((frameId) =>
529 |           sendCommandToFrame(tabId, frameId, "autoform_count_inputs", null)
530 |         )
531 |       );
532 |       const total = results.reduce((sum, res) => sum + (res?.count || 0), 0);
533 |       setInputCountStatus(`検知数: ${total}件`);
534 |     } catch (err) {
535 |       setInputCountStatus(`検知数取得失敗: ${err.message}`, true);
536 |     }
537 |   }
538 | 
539 |   async function handleExecuteClick(btn) {
540 |     if (!(currentData && currentData.length)) {
541 |       setStatus("JSONを読み込んでください", true);
542 |       return;
543 |     }
544 |     btn.disabled = true;
545 |     setStatus("権限チェック中…");
546 |     try {
547 |       const tabId = await getActiveTabId();
548 |       const origins = await listFrameOrigins(tabId);
549 |       const ok = await ensureOriginsPermission(origins);
550 |       if (!ok) {
551 |         setStatus("実行中止: 権限が得られませんでした", true);
552 |         btn.disabled = false;
553 |         updateExecuteState();
554 |         await refreshDetectedInputCount();
555 |         return;
556 |       }
557 |       setStatus("入力を送信中…");
558 |       const frameIds = await getAllFrameIds(tabId);
559 |       const results = await Promise.all(
560 |         frameIds.map((frameId) =>
561 |           sendCommandToFrame(tabId, frameId, "autoform_execute_json", currentData)
562 |         )
563 |       );
564 |       const summary = results.reduce(
565 |         (acc, res) => {
566 |           const applied = res?.applied || {};
567 |           acc.success += applied.success || 0;
568 |           acc.skipped += applied.skipped || 0;
569 |           acc.total += applied.total || 0;
570 |           return acc;
571 |         },
572 |         { success: 0, skipped: 0, total: 0 }
573 |       );
574 |       if (summary.total === 0) summary.total = currentData.length;
575 |       setStatus(`実行完了: 成功 ${summary.success} / ${summary.total}件 (スキップ ${summary.skipped})`);
576 |     } catch (err) {
577 |       setStatus(`実行失敗: ${err.message}`, true);
578 |     } finally {
579 |       updateExecuteState();
580 |       await refreshDetectedInputCount();
581 |       await refreshDetailIndicators({ silent: true });
582 |     }
583 |   }
584 | 
585 |   async function handleManualFill(btn) {
586 |     btn.disabled = true;
587 |     setManualStatus("フォーム入力中…");
588 |     try {
589 |       const tabId = await getActiveTabId();
590 |       const frameIds = await getAllFrameIds(tabId);
591 |       const results = await Promise.all(
592 |         frameIds.map((frameId) =>
593 |           sendCommandToFrame(tabId, frameId, "autoform_manual_fill", null)
594 |         )
595 |       );
596 |       const firstError = results.find((item) => item && item.error)?.error;
597 |       if (firstError) {
598 |         setManualStatus(`失敗: ${firstError}`, true);
599 |         return;
600 |       }
601 |       const summary = results.reduce(
602 |         (acc, res) => {
603 |           const applied = res?.applied || {};
604 |           acc.success += applied.success || res?.filled || 0;
605 |           acc.skipped += applied.skipped || 0;
606 |           acc.total += applied.total || 0;
607 |           return acc;
608 |         },
609 |         { success: 0, skipped: 0, total: 0 }
610 |       );
611 |       setManualStatus(`完了: ${summary.success}件に入力`);
612 |     } catch (err) {
613 |       setManualStatus(`失敗: ${err.message}`, true);
614 |     } finally {
615 |       btn.disabled = false;
616 |       await refreshDetectedInputCount();
617 |       await refreshDetailIndicators({ silent: true });
618 |     }
619 |   }
620 | 
621 |   function validateSendContent(data) {
622 |     const values = Object.values(data || {});
623 |     if (!values.length) return false;
624 |     return values.every((value) => {
625 |       if (value == null) return false;
626 |       if (typeof value === "string") {
627 |         return value.trim().length > 0;
628 |       }
629 |       return true;
630 |     });
631 |   }
632 | 
633 |   function updateSendContentWarning(data) {
634 |     const warningEl = qs("send-content-warning");
635 |     if (!warningEl) return;
636 |     const formData = data || readSendContentFromForm();
637 |     const hasEmpty = !validateSendContent(formData);
638 |     warningEl.style.display = hasEmpty ? "block" : "none";
639 |     if (!hasEmpty) {
640 |       const statusEl = qs("send-content-status");
641 |       if (statusEl && statusEl.textContent === "全ての入力項目を埋めてください") {
642 |         statusEl.textContent = "未保存の変更があります";
643 |         statusEl.style.color = "#555";
644 |       }
645 |     }
646 |   }
647 | 
648 |   function handleSendContentSave() {
649 |     const formData = readSendContentFromForm();
650 |     if (!validateSendContent(formData)) {
651 |       setSendContentStatus("全ての入力項目を埋めてください", true);
652 |       updateSendContentWarning(formData);
653 |       return;
654 |     }
655 |     currentSendContent = formData;
656 |     persistSendContent();
657 |     setSendContentStatus("入力項目を保存しました");
658 |     updateSendContentWarning(formData);
659 |   }
660 | 
661 |   async function handleSendContentApply(btn) {
662 |     currentSendContent = readSendContentFromForm();
663 |     persistSendContent();
664 | 
665 |     btn.disabled = true;
666 |     setSendContentStatus("権限チェック中…");
667 |     try {
668 |       const tabId = await getActiveTabId();
669 |       const origins = await listFrameOrigins(tabId);
670 |       const ok = await ensureOriginsPermission(origins);
671 |       if (!ok) {
672 |         setSendContentStatus("入力中止: 権限が得られませんでした", true);
673 |         return;
674 |       }
675 |       setSendContentStatus("入力処理中…");
676 |       const frameIds = await getAllFrameIds(tabId);
677 |       const results = await Promise.all(
678 |         frameIds.map((frameId) =>
679 |           sendCommandToFrame(tabId, frameId, "autoform_apply_send_content", currentSendContent)
680 |         )
681 |       );
682 |       const filledKeys = new Set();
683 |       for (const res of results) {
684 |         const keys = res?.sendContent?.filledKeys;
685 |         if (Array.isArray(keys)) {
686 |           keys.forEach((key) => filledKeys.add(key));
687 |         }
688 |       }
689 |       const totalKeys = Object.keys(currentSendContent).length;
690 |       setSendContentStatus(`入力完了: ${filledKeys.size}/${totalKeys} 件 (キー単位)`);
691 |     } catch (err) {
692 |       setSendContentStatus(`入力失敗: ${err.message}`, true);
693 |     } finally {
694 |       btn.disabled = false;
695 |       await refreshDetectedInputCount();
696 |     }
697 |   }
698 | 
699 |   document.addEventListener("DOMContentLoaded", () => {
700 |     const fillBtn = qs("fill-now");
701 |     const apiDetailsBtn = qs("show-api-details");
702 |     const apiDetailsBox = qs("api-details");
703 |     const curlDetailsBtn = qs("show-curl-details");
704 |     const curlDetailsBox = qs("curl-details");
705 |     const sendContentToggle = qs("send-content-toggle");
706 |     const sendContentBody = qs("send-content-body");
707 |     const saveSendBtn = qs("save-send-content");
708 |     const floatingButtonCheckbox = qs("show-floating-button");
709 | 
710 |     if (fillBtn) {
711 |       fillBtn.addEventListener("click", () => handleManualFill(fillBtn));
712 |     }
713 |     if (apiDetailsBtn && apiDetailsBox) {
714 |       apiDetailsBtn.addEventListener("click", () => handleShowApiDetails(apiDetailsBtn, apiDetailsBox));
715 |     }
716 |     if (curlDetailsBtn && curlDetailsBox) {
717 |       curlDetailsBtn.addEventListener("click", () => handleShowCurlDetails(curlDetailsBtn, curlDetailsBox));
718 |     }
719 |     const sendContentFields = getSendContentFields();
720 |     if (sendContentFields.length) {
721 |       sendContentFields.forEach((field) => {
722 |         field.addEventListener("input", () => setSendContentStatus("未保存の変更があります"));
723 |         field.addEventListener("input", () => updateSendContentWarning());
724 |       });
725 |     }
726 |     if (saveSendBtn) {
727 |       saveSendBtn.addEventListener("click", handleSendContentSave);
728 |     }
729 |     initSendContentToggle(sendContentToggle, sendContentBody, true);
730 |     updateSendContentWarning();
731 |     initFloatingButtonToggle(floatingButtonCheckbox);
732 | 
733 |     refreshDetectedInputCount();
734 |     loadSendContent();
735 |     refreshDetailIndicators();
736 |   });
737 | })();
--------------------------------------------------------------------------------

/sample_code/_b2_1_url2button.py:
--------------------------------------------------------------------------------
  1 | # module/contactform_module/b2_1_url2button.py
  2 | # b2_1_url2button.pyやb2_1_url2button.pyはb2_0_output_module.pyのための部品
  3 | # -*- coding: utf-8 -*-
  4 | import requests
  5 | import json
  6 | import re
  7 | import os
  8 | import html
  9 | import sys
 10 | import unicodedata
 11 | from bs4 import BeautifulSoup
 12 | 
 13 | try:
 14 |     from playwright.sync_api import sync_playwright
 15 | except ImportError:
 16 |     sync_playwright = None
 17 | 
 18 | 
 19 | class FormProcessor:
 20 |     """
 21 |     URLからHTMLを取得する、またはPlaywrightを用いて取得する機能などを持つクラス。
 22 |     """
 23 |     def __init__(self, url):
 24 |         self.url = url
 25 | 
 26 |     def fetch_html(self):
 27 |         """指定されたURLからHTMLコンテンツを取得してBeautifulSoupオブジェクトを返します。"""
 28 |         try:
 29 |             response = requests.get(self.url, timeout=10)
 30 |             response.raise_for_status()
 31 |             response.encoding = 'utf-8'
 32 |             html_content = html.unescape(response.text)
 33 |             # コメントアウトされた箇所は除去
 34 |             clean_html = re.sub(r'<!--.*?-->', '', html_content, flags=re.DOTALL)
 35 |             soup = BeautifulSoup(clean_html, 'html.parser')
 36 |             return soup
 37 |         except Exception as e:
 38 |             print(f"Error fetching {self.url}: {str(e)}")
 39 |             return None
 40 | 
 41 |     def fetch_with_playwright(self):
 42 |         """
 43 |         Playwrightを使用してURLのページを取得し、HTMLを返します。
 44 |         """
 45 |         if not sync_playwright:
 46 |             print("Playwright is not installed. Returning None.")
 47 |             return None
 48 | 
 49 |         print("Playwrightを使用します")
 50 |         with sync_playwright() as p:
 51 |             browser = p.chromium.launch(headless=True)
 52 |             page = browser.new_page()
 53 |             page.goto(self.url)
 54 |             # ページのロード完了を待機
 55 |             page.wait_for_load_state('domcontentloaded')
 56 |             page.wait_for_selector("body")
 57 |             content = page.content()
 58 |             browser.close()
 59 | 
 60 |         return content
 61 | 
 62 |     def save_data_to_file(self, data, output_folder='form_tag_updated'):
 63 |         """JSONファイルとして保存。"""
 64 |         os.makedirs(output_folder, exist_ok=True)
 65 |         output_filename = os.path.join(output_folder, self.sanitize_filename())
 66 |         try:
 67 |             with open(output_filename, 'w', encoding='utf-8') as f:
 68 |                 json.dump(data, f, ensure_ascii=False, indent=4)
 69 |             print(f"Results have been written to {output_filename}")
 70 |         except Exception as e:
 71 |             print(f"Error saving data to {output_filename}: {str(e)}")
 72 | 
 73 |     def sanitize_filename(self):
 74 |         """URLから安全なファイル名を生成します。"""
 75 |         filename = re.sub(r'^https?://', '', self.url)
 76 |         filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)
 77 |         return f"{filename}.json"
 78 | 
 79 | 
 80 | class ButtonDataProcessor:
 81 |     """
 82 |     ボタン要素に対して「押す/押さない/不明」などの値付けを行うクラス。
 83 |     さらに「未完了を完了させるボタン」「修正ボタン」のカウントも行う。
 84 |     """
 85 |     def __init__(self):
 86 |         self.conditions = {
 87 |             "電話番号": {"keywords": ['tel', '電話番号', 'phone', 'Phone'], "field": "tel", "type": "tel"},
 88 |             "メールアドレス": {"keywords": ['email', 'Email', 'メールアドレス', 'E-mail', 'mail'], "field": "email", "type": "email"},
 89 |             "フリガナ": {"keywords": ['フリガナ', 'kana', 'かな', 'セイ', 'メイ', 'せい', 'めい', 'ふりがな', 'たろう'], "field": "name_kana", "type": "text"},
 90 |             "会社名かな": {"keywords": ['会社名(仮名)', '会社かな', '会社名かな', 'company', 'organization', 'フリガナ', 'kana', 'company_name_kana', 'かぶしきがいしゃ'], "field": "company_kana", "type": "text"},
 91 |             "部署": {"keywords": ['部署', '部門', '役職', '所属'], "field": "部署", "type": "text"},
 92 |             "名前": {"keywords": ['名前', 'name', 'onamae', 'namae', '氏名', '名', '氏', '山田', '担当者', '太郎'], "field": "name", "type": "text"},
 93 |             "会社名": {"keywords": ['会社名', '会社', '法人名', '法人', '株', '貴社名', 'company'], "field": "company", "type": "text"},
 94 |             "内容": {"keywords": ['remark', 'Remark', 'description', '内容', '相談', 'detail', 'メッセージ', 'textarea', 'message'], "field": "remark", "type": "textarea"},
 95 |             "タイトル": {"keywords": ['タイトル', 'subject', 'title'], "field": "title", "type": "text"},
 96 |             "郵便番号": {"keywords": ['郵便番号', 'zip', 'postal', 'post', '〒'], "field": "postal_code", "type": "text"},
 97 |             "住所": {"keywords": ['住所', 'address', '番地'], "field": "住所", "type": "text"},
 98 |             "県": {"keywords": ['県', 'prefecture', '都道府県'], "field": "prefecture", "type": "text"},
 99 |             "業種": {"keywords": ['業種', '業界'], "field": "業種", "type": "text"},
100 |             "FAX": {"keywords": ['fax', 'ファックス', 'FAX'], "field": "fax", "type": "text"},
101 |             "URL": {"keywords": ['URL', 'https', 'url'], "field": "URL", "type": "text"},
102 |             "特定キーワード": {"keywords": ['見積り', '問い合わせ', 'サービス', 'その他', '提携', '協業', 'チェックを付', 'ご確認', '同意', '法人', 'agree', 'プライバシーポリシー'], "field": "selection", "type": "selection"}
103 |         }
104 |         # 「未完了を完了させるボタン」に該当するワード一覧
105 |         self.A_WORDS = ["送信", "送信する", "送信ボタン", "確認", "確定", "登録", "次へ", "進む", "すすむ", "send", "Send","お問い合わせ", "内容"]
106 |         # 「未完了の時に修正させるボタン」に該当するワード一覧
107 |         self.B_WORDS = ["修正", "書き直す", "戻る", "キャンセル", "cancel", "やり直す"]
108 | 
109 |         # 見つかった数をカウントするフィールド
110 |         self.found_in_A_count = 0  # 未完了→完了用ボタンの検出数
111 |         self.found_in_B_count = 0  # 修正用ボタンの検出数
112 | 
113 |     def add_input_data(self, existing_data_list):
114 |         """
115 |         ボタン要素リストに対して「押下するか/しないか」の value を付与し JSON を拡張する。
116 |         また A_WORDS / B_WORDS に当てはまる数をカウントする。
117 |         """
118 |         updated_data = []
119 | 
120 |         for item in existing_data_list:
121 |             existing_data = item.get("existing_data", {})
122 |             label = existing_data.get("label", "")
123 |             form_name = existing_data.get("form_name", "")
124 |             placeholder = existing_data.get("placeholder", "")
125 |             element_type = existing_data.get("type", "").lower()
126 | 
127 |             if element_type in ["button", "submit"]:
128 |                 # ラベルの正規化（NFKC正規化＋全角・半角スペースを除去して判定）
129 |                 normalized_label = unicodedata.normalize("NFKC", ''.join(label.split())).lower()
130 |                 found_in_A = any(word.lower() in normalized_label for word in self.A_WORDS)
131 |                 found_in_B = any(word.lower() in normalized_label for word in self.B_WORDS)
132 | 
133 |                 if found_in_A:
134 |                     # A_WORDS にヒット→「click」させるボタン
135 |                     self.found_in_A_count += 1
136 |                     input_data = {
137 |                         "value": "click",
138 |                         "match_condition": "click_button",
139 |                         "confidence_score": 100,
140 |                         "top_3_matches": [],
141 |                         "sequence_info": "1/1"
142 |                     }
143 |                 elif found_in_B:
144 |                     # B_WORDS にヒット→「no_click」(修正ボタンなので押さない)
145 |                     self.found_in_B_count += 1
146 |                     input_data = {
147 |                         "value": "no_click",
148 |                         "match_condition": "non_click_button",
149 |                         "confidence_score": 100,
150 |                         "top_3_matches": [],
151 |                         "sequence_info": "1/1"
152 |                     }
153 |                 else:
154 |                     # A/Bワードに該当しないボタンは通常の条件判定
155 |                     label_texts = self.get_label_texts(label)
156 |                     placeholder_texts = self.get_label_texts(placeholder)
157 |                     scores = self.evaluate_match_score(label_texts, form_name, element_type, placeholder_texts)
158 |                     best_match = self.get_best_match(scores)
159 |                     match_condition = best_match[0] if best_match else None
160 |                     default_value = ""
161 |                     confidence, _ = self.calculate_confidence_score(scores)
162 |                     top_3_matches = self.get_top_3_matches(scores)
163 | 
164 |                     input_data = {
165 |                         "value": default_value,
166 |                         "match_condition": match_condition,
167 |                         "confidence_score": confidence,
168 |                         "top_3_matches": top_3_matches,
169 |                         "sequence_info": "1/1"
170 |                     }
171 | 
172 |             else:
173 |                 # ボタン要素でなければ何も付与しない
174 |                 input_data = {
175 |                     "value": "",
176 |                     "match_condition": None,
177 |                     "confidence_score": 0,
178 |                     "top_3_matches": [],
179 |                     "sequence_info": "1/1"
180 |                 }
181 | 
182 |             updated_data.append({
183 |                 "existing_data": existing_data,
184 |                 "input_data": input_data
185 |             })
186 | 
187 |         return updated_data
188 | 
189 |     def get_label_texts(self, text):
190 |         return re.split(r'\s+|-', text.strip())
191 | 
192 |     def evaluate_match_score(self, label_texts, form_name, element_type, placeholder_texts):
193 |         base_weights = {
194 |             'type_match': 5,
195 |             'label_match': 3,
196 |             'placeholder_match': 3,
197 |             'form_name_match': 2,
198 |             'surrounding_match': -1,
199 |             'last_keyword_bonus': 2,
200 |             'textarea_bonus': 5
201 |         }
202 |         scores = {}
203 | 
204 |         for condition, details in self.conditions.items():
205 |             condition_type = details.get("type", "")
206 |             if condition_type == "selection" and element_type not in ["checkbox", "radio"]:
207 |                 continue
208 | 
209 |             score = 0
210 |             reasons = []
211 | 
212 |             expected_type = details.get("type", "")
213 |             if expected_type and element_type == expected_type and expected_type != "text":
214 |                 score += base_weights['type_match']
215 |                 reasons.append(f"type_match '{expected_type}' (+{base_weights['type_match']})")
216 | 
217 |             if element_type == "textarea" and condition_type == "textarea":
218 |                 score += base_weights['textarea_bonus']
219 |                 reasons.append(f"textarea bonus (+{base_weights['textarea_bonus']})")
220 | 
221 |             for txt in label_texts:
222 |                 for keyword in details["keywords"]:
223 |                     if keyword.lower() in txt.lower():
224 |                         score += base_weights['label_match']
225 |                         reasons.append(f"label_match '{keyword}' (+{base_weights['label_match']})")
226 | 
227 |             for txt in placeholder_texts:
228 |                 for keyword in details["keywords"]:
229 |                     if keyword.lower() in txt.lower():
230 |                         score += base_weights['placeholder_match']
231 |                         reasons.append(f"placeholder_match '{keyword}' (+{base_weights['placeholder_match']})")
232 | 
233 |             if label_texts:
234 |                 last_word = label_texts[-1]
235 |                 if any(keyword.lower() == last_word.lower() for keyword in details["keywords"]):
236 |                     score += base_weights['last_keyword_bonus']
237 |                     reasons.append(f"bonus for last keyword in label (+{base_weights['last_keyword_bonus']})")
238 | 
239 |             for keyword in details["keywords"]:
240 |                 if keyword.lower() in form_name.lower():
241 |                     score += base_weights['form_name_match']
242 |                     reasons.append(f"form_name_match '{keyword}' (+{base_weights['form_name_match']})")
243 | 
244 |             if score > 0:
245 |                 scores[condition] = {
246 |                     'score': score,
247 |                     'reasons': reasons
248 |                 }
249 | 
250 |         return scores
251 | 
252 |     def get_best_match(self, confidence_scores):
253 |         if not confidence_scores:
254 |             return None
255 |         return max(confidence_scores.items(), key=lambda item: item[1]['score'])
256 | 
257 |     def calculate_confidence_score(self, confidence_scores):
258 |         total_score = sum(details['score'] for details in confidence_scores.values())
259 |         max_score = sum(self.get_max_score(condition) for condition in confidence_scores.keys())
260 |         confidence = (total_score / max_score * 100) if max_score else 0
261 |         return round(confidence, 2), confidence_scores
262 | 
263 |     def get_max_score(self, condition):
264 |         base_weights = {
265 |             'type_match': 5,
266 |             'label_match': 3,
267 |             'placeholder_match': 3,
268 |             'form_name_match': 2,
269 |             'surrounding_match': -1,
270 |             'last_keyword_bonus': 2,
271 |             'textarea_bonus': 5
272 |         }
273 |         condition_type = self.conditions[condition].get("type", "")
274 |         if condition_type == "textarea":
275 |             return (base_weights['type_match'] + base_weights['textarea_bonus'] +
276 |                     base_weights['label_match'] + base_weights['placeholder_match'] +
277 |                     base_weights['form_name_match'] + base_weights['last_keyword_bonus'])
278 |         elif condition_type == "selection":
279 |             return base_weights['label_match'] + base_weights['form_name_match']
280 |         else:
281 |             return (base_weights['type_match'] + base_weights['label_match'] +
282 |                     base_weights['placeholder_match'] + base_weights['form_name_match'] +
283 |                     base_weights['last_keyword_bonus'])
284 | 
285 |     def get_top_3_matches(self, confidence_scores):
286 |         sorted_matches = sorted(
287 |             confidence_scores.items(), key=lambda x: x[1]['score'], reverse=True
288 |         )[:3]
289 |         return [
290 |             {
291 |                 "condition": condition,
292 |                 "score": details['score'],
293 |                 "formula": "; ".join(details['reasons'])
294 |             }
295 |             for condition, details in sorted_matches
296 |         ]
297 | 
298 | 
299 | def parse_html_for_buttons(html_content):
300 |     """
301 |     HTML文字列から <button> または <input type="button" / type="submit"> を抽出して
302 |     解析用のリスト（existing_data）を返す関数。
303 |     """
304 |     clean_html = re.sub(r'<!--.*?-->', '', html_content, flags=re.DOTALL)
305 |     soup = BeautifulSoup(clean_html, 'html.parser')
306 |     items = []
307 | 
308 |     def generate_xpath(element):
309 |         path = []
310 |         current = element
311 |         while current and current.name != '[document]':
312 |             siblings = current.find_previous_siblings(current.name)
313 |             index = len(siblings) + 1
314 |             tag_name = current.name
315 |             if index > 1:
316 |                 path.insert(0, f"{tag_name}[{index}]")
317 |             else:
318 |                 path.insert(0, tag_name)
319 |             current = current.parent
320 |         return '/' + '/'.join(path)
321 | 
322 |     def get_form_class_id(element):
323 |         form_class_id = element.get('class', None)
324 |         parent = element.find_parent()
325 |         while parent and not form_class_id:
326 |             form_class_id = parent.get('class', None)
327 |             parent = parent.find_parent()
328 |         return form_class_id if form_class_id else []
329 | 
330 |     def categorize_element(element):
331 |         form_name = element.get('name', '')
332 |         form_class_id = get_form_class_id(element)
333 |         xpath = generate_xpath(element)
334 | 
335 |         if element.name == 'button':
336 |             element_type = element.get('type', '').lower() or 'button'
337 |             button_text = element.get_text(strip=True)
338 |             return {
339 |                 "existing_data": {
340 |                     "label": button_text,
341 |                     "form_name": form_name,
342 |                     "type": element_type,
343 |                     "placeholder": element.get('placeholder', ''),
344 |                     "form_class_id": form_class_id,
345 |                     "xpath": xpath,
346 |                     "choices": None
347 |                 }
348 |             }
349 |         elif element.name == 'input' and element.get('type', '').lower() in ['button', 'submit']:
350 |             element_type = element.get('type', '').lower()
351 |             button_text = element.get('value', '')
352 |             return {
353 |                 "existing_data": {
354 |                     "label": button_text,
355 |                     "form_name": form_name,
356 |                     "type": element_type,
357 |                     "placeholder": element.get('placeholder', ''),
358 |                     "form_class_id": form_class_id,
359 |                     "xpath": xpath,
360 |                     "choices": None
361 |                 }
362 |             }
363 |         return None
364 | 
365 |     def traverse(element):
366 |         for child in element.contents:
367 |             if isinstance(child, str):
368 |                 continue
369 |             else:
370 |                 if child.name == 'button' or (child.name == 'input' and child.get('type', '').lower() in ['button', 'submit']):
371 |                     categorized_item = categorize_element(child)
372 |                     if categorized_item:
373 |                         items.append(categorized_item)
374 |                 else:
375 |                     traverse(child)
376 | 
377 |     target_root = soup.body if soup.body else soup
378 |     traverse(target_root)
379 |     return items
380 | 
381 | 
382 | def main(html):
383 |     """
384 |     すでに取得済みのHTML文字列を解析して、
385 |     ボタン要素に関する情報をリスト形式＋αで返す関数。
386 |     """
387 |     # ボタン要素を抽出
388 |     button_only_data = parse_html_for_buttons(html)
389 |     # ボタン要素へ input_data などを付与
390 |     data_processor = ButtonDataProcessor()
391 |     updated_data = data_processor.add_input_data(button_only_data)
392 | 
393 |     # A/Bワードに該当するボタンの数をカウント
394 |     a_count = data_processor.found_in_A_count
395 |     b_count = data_processor.found_in_B_count
396 |     extra_points = 10 * (a_count + b_count)
397 | 
398 |     # ボタン一覧とカウント情報・ポイントをまとめた構造を返す
399 |     return {
400 |         "button_data": updated_data,
401 |         "complete_button_count": a_count,
402 |         "fix_button_count": b_count,
403 |         "extra_points": extra_points
404 |     }
405 | 
406 | 
407 | if __name__ == "__main__":
408 |     # コマンドライン引数からURLを取得（なければデフォルトURLを使用）
409 |     if len(sys.argv) > 1:
410 |         URL = sys.argv[1]
411 |     else:
412 |         URL = "https://apodori.ai/#contact"
413 | 
414 |     # URLからHTMLを取得
415 |     processor = FormProcessor(URL)
416 |     soup = processor.fetch_html()
417 |     if not soup:
418 |         print(f"Failed to fetch HTML from {URL}")
419 |         sys.exit(1)
420 | 
421 |     # HTML（Soupオブジェクト）を文字列化してmain関数に渡す
422 |     html_content = str(soup)
423 |     final_data = main(html_content)
424 | 
425 |     # JSON結果の保存 & 出力
426 |     processor.save_data_to_file(final_data, output_folder='form_tag_updated')
427 |     print("JSON解析結果:")
428 |     print(json.dumps(final_data, ensure_ascii=False, indent=4))
--------------------------------------------------------------------------------

/sample_code/_b2_2_classify_status.py:
--------------------------------------------------------------------------------
  1 | # module/contactform_module/b2_2_classify_status.py
  2 | # b2_1_url2button.pyやb2_1_url2button.pyはb2_0_output_module.pyのための部品
  3 | import requests
  4 | import html2text
  5 | 
  6 | def convert_html_to_text(url):
  7 |     """
  8 |     指定URLからHTMLを取得し、html2textでテキストに変換する
  9 |     """
 10 |     try:
 11 |         response = requests.get(url)
 12 |         response.raise_for_status()  # HTTPエラーの場合は例外発生
 13 |         html = response.text
 14 | 
 15 |         h = html2text.HTML2Text()
 16 |         h.ignore_links = False  # リンクもテキストに含める
 17 |         text = h.handle(html)
 18 |         return text
 19 |     except requests.exceptions.RequestException as e:
 20 |         print(f"Error fetching URL: {e}")
 21 |         return None
 22 | 
 23 | def classify_message(text):
 24 |     """
 25 |     テキスト中に含まれるキーワードの出現数に基づいて
 26 |       ・未完了（カテゴリー①）
 27 |       ・完了（カテゴリー②）
 28 |       ・失敗（カテゴリー③）
 29 |     のカウントと、各カテゴリでどのキーワードが何回ヒットしたかを返す。
 30 | 
 31 |     戻り値:
 32 |         (count1, count2, count3, hit_keywords_1, hit_keywords_2, hit_keywords_3)
 33 |     """
 34 | 
 35 |     # カテゴリー①：作業がまだ終わっていないことを示す文言
 36 |     category1_keywords = [
 37 |         '上記内容',
 38 |         'ご確認ください',
 39 |         'よろしければ'
 40 |     ]
 41 | 
 42 |     # カテゴリー②：送信完了など完了を示す文言
 43 |     category2_keywords = [
 44 |         'ありがとう',
 45 |         'ありがとうございました。',
 46 |         '営業日以内に',
 47 |         '送信完了',
 48 |         '送信されました',
 49 |         '迷惑メールフォルダ',
 50 |         '完了',
 51 |         'ご連絡いたします',
 52 |         'ご連絡させて',
 53 |         'ご連絡させていただきます',
 54 |         'お送りいたしました',
 55 |         '送信いたしました',
 56 |         '返答',
 57 |         '完了しました',
 58 |         '承りました',
 59 |         '担当者',
 60 |         '後日'
 61 |     ]
 62 | 
 63 |     # カテゴリー③：送信失敗を示す文言
 64 |     category3_keywords = [
 65 |         '失敗しました',
 66 |         'captcha',
 67 |         'ロボットではありません',
 68 |         '私はロボットでは',
 69 |         '失敗'
 70 |     ]
 71 | 
 72 |     count1 = 0
 73 |     count2 = 0
 74 |     count3 = 0
 75 | 
 76 |     hit_keywords_1 = {}  # 未完了カテゴリのヒットしたキーワード
 77 |     hit_keywords_2 = {}  # 完了カテゴリのヒットしたキーワード
 78 |     hit_keywords_3 = {}  # 失敗カテゴリのヒットしたキーワード
 79 | 
 80 |     # カテゴリー①
 81 |     for keyword in category1_keywords:
 82 |         num = text.count(keyword)
 83 |         if num > 0:
 84 |             count1 += num
 85 |             hit_keywords_1[keyword] = num
 86 | 
 87 |     # カテゴリー②
 88 |     for keyword in category2_keywords:
 89 |         num = text.count(keyword)
 90 |         if num > 0:
 91 |             count2 += num
 92 |             hit_keywords_2[keyword] = num
 93 | 
 94 |     # カテゴリー③
 95 |     for keyword in category3_keywords:
 96 |         num = text.count(keyword)
 97 |         if num > 0:
 98 |             count3 += num
 99 |             hit_keywords_3[keyword] = num
100 | 
101 |     return count1, count2, count3, hit_keywords_1, hit_keywords_2, hit_keywords_3
102 | 
103 | 
104 | def determine_status(count1, count2, count3):
105 |     """
106 |     シンプルな判定ロジック（優先順位：failed → success → confirm → unknown）
107 | 
108 |     Args:
109 |         count1: 未完了ワードのカウント
110 |         count2: 完了ワードのカウント
111 |         count3: 失敗ワードのカウント
112 | 
113 |     Returns:
114 |         str: "success", "confirm", "failed", "unknown"
115 |     """
116 |     # 失敗ワードが1つ以上なら failed（最優先）
117 |     if count2 >= 1 and count3 == 0:
118 |         return "success"
119 |     if count2 >= count3 * 2:   # 例: 完了語が失敗語の 2 倍以上
120 |         return "success"
121 |     if count3 > 0 and count2 == 0:
122 |         return "failed"
123 |     if count3 > 0:             # 両方ヒットするが完了語が少ない
124 |         return "failed"
125 |     if count1 > 0:
126 |         return "confirm"
127 |     return "unknown"
128 | 
129 | if __name__ == '__main__':
130 |     # 簡易テスト用
131 |     sample_url = "https://www.example.com"
132 |     text_output = convert_html_to_text(sample_url)
133 | 
134 |     if text_output:
135 |         score1, score2, score3, hits1, hits2, hits3 = classify_message(text_output)
136 |         print("【分類結果】")
137 |         print(f"①（未完了）: {score1}, ヒット = {hits1}")
138 |         print(f"②（完了）  : {score2}, ヒット = {hits2}")
139 |         print(f"③（失敗）  : {score3}, ヒット = {hits3}")
140 |     else:
141 |         print("HTMLの変換に失敗しました。")
--------------------------------------------------------------------------------

/sample_code/a_main_analyes.py:
--------------------------------------------------------------------------------
  1 | # -*- coding: utf-8 -*-
  2 | ################
  3 | import sys
  4 | import os
  5 | 
  6 | if __name__ == "__main__" and __package__ is None:
  7 |     # スクリプトが直接実行された場合、プロジェクトのルートディレクトリをsys.pathに追加
  8 |     script_dir = os.path.dirname(os.path.abspath(__file__))
  9 |     project_root = os.path.abspath(os.path.join(script_dir, "../../")) # 2階層下の場合
 10 |     sys.path.insert(0, project_root)
 11 | 
 12 | ################
 13 | 
 14 | # module/main_analyes.py 実際にhtmlがどうなっているのかの分析用のコード。url2form_tag_moduleの二つのコードを繋げた。
 15 | # URLからフォームリスト&入力するべき情報をそれぞれ出力させる。
 16 | import os
 17 | import json
 18 | from urllib.parse import urlparse
 19 | # 本番
 20 | from module.contactform_module.url2form_tag_module.url2form_tag1 import FormProcessor
 21 | from module.contactform_module.url2form_tag_module.url2form_tag2 import update_json_with_input_data
 22 | 
 23 | async def process_url_to_json(url, send_content):
 24 |     """
 25 |     Takes a URL and SEND_CONTENT, fetches the form data, updates it with SEND_CONTENT,
 26 |     and returns the final JSON data.
 27 |     """
 28 |     # Step 1: Use url2form_tag(1) to generate JSON data from the URL
 29 |     processor = FormProcessor(url)
 30 |     json_data = await processor.fetch_and_parse()
 31 | 
 32 |     # Step 2: Use url2form_tag(2) to update JSON data with send_content
 33 |     updated_data = update_json_with_input_data(json_data, send_content)
 34 | 
 35 |     return updated_data
 36 | 
 37 | def save_json_to_file(data, url, output_folder="form_tag_updated"):
 38 |     """
 39 |     Saves JSON data to a file named based on the URL in the specified output folder.
 40 |     """
 41 |     from urllib.parse import urlparse
 42 |     import os
 43 |     import json
 44 | 
 45 |     # Generate a filename based on the URL
 46 |     parsed_url = urlparse(url)
 47 |     filename = f"{parsed_url.netloc.replace('.', '_')}.json"
 48 |     output_path = os.path.join(output_folder, filename)
 49 | 
 50 |     # exist_ok=True は Python 3.2未満では使えないため手動チェックに変更
 51 |     if not os.path.exists(output_folder):
 52 |         os.makedirs(output_folder)
 53 | 
 54 |     try:
 55 |         with open(output_path, 'w', encoding='utf-8') as f:
 56 |             json.dump(data, f, ensure_ascii=False, indent=4)
 57 |         print(f"Updated data has been saved to {output_path}")
 58 |     except Exception as e:
 59 |         print(f"Error saving final updated data to {output_path}: {str(e)}")
 60 | 
 61 | if __name__ == "__main__":
 62 |     import asyncio
 63 | 
 64 |     URL = "https://apodori.ai/#contact"
 65 |     SEND_CONTENT = {
 66 |         "name": "河原　克典",
 67 |         "name_kana": "カワハラ カツノリ",
 68 |         "company": "ソーシング・ブラザーズ株式会社",
 69 |         "部署": "営業部門",
 70 |         "住所": "東京都千代田区永田町１丁目１１番３０号 サウスヒル永田町 ３階",
 71 |         "postal_code": "100-0014",
 72 |         "company_kana": "そーしんぐ・ぶらざーず",
 73 |         "prefecture": "東京都",
 74 |         "email": "k.kawahara@sbro.co.jp",
 75 |         "tel": "03-6205-7938",
 76 |         "title": "ソーシング・ブラザーズ株式会社の河原と申します",
 77 |         "URL": "https://sbro.co.jp",
 78 |         "remark": "お世話になっております。\nソーシング・ブラザーズ株式会社の河原と申します。\n\n\n\n弊社は、IT領域に特化したM&A支援を中心に、企業の成長戦略やデジタル変革の実現を\n目的としたコンサルティングサポートを行っております。\n業界の進化と地域社会への貢献を重視し、企業間の戦略的な提携をお手伝いさせていただいております。\n\nこの度、弊社のクライアント様より、貴社の技術力や市場でのポジションがシナジーを\n創出する可能性が高いとのことで、非常に強い関心をお寄せいただいております。\n本件は\"指名案件\"として、貴社へご連絡させていただきました。\n\n【本件の目的】\nクライアント企業様は、デジタル領域でのさらなる事業拡大を目指しており、\n特に貴社のように高度な技術力と市場での信頼性を持つ企業との提携を積極的に検討しております。\n\n【貴社に興味を持たれたポイント】\n貴社が提供されるITソリューションおよびテクノロジーの革新性に注目しており、\nクライアント様の事業展開において、貴社との連携が双方の成長に大きく寄与する可能性があると考えられております。\n\n【当該企業様が想定している構想（一部抜粋させていただきます）】\nIT業界が直面する課題に対し、貴社と協力することで\n以下のような施策を推進し、さらなる事業成長を目指していきます。\n\n■ 最新技術を活用したデジタル変革の加速\n■ 業務プロセスの自動化・効率化による競争力強化\n■ クラウドやAIなど新たな技術を活用したソリューション展開\n\n\nぜひ一度、クライアント企業様のご紹介を含め、具体的なビジョンやシナジーの可能性についてお話させていただければと存じます。\n\nご返信いただけましたら、面談日時の調整をさせていただきます。\n\n\nぜひ一度、お話する機会を頂戴できれば幸いです。\nご検討のほど、よろしくお願い申し上げます。"
 79 |     }
 80 | 
 81 |     # 非同期関数を実行するためのイベントループを取得
 82 |     loop = asyncio.get_event_loop()
 83 | 
 84 |     # Process and save JSON to file when running as main
 85 |     final_data = loop.run_until_complete(process_url_to_json(URL, SEND_CONTENT))
 86 |     save_json_to_file(final_data, URL)
--------------------------------------------------------------------------------

/sample_code/api_test.py:
--------------------------------------------------------------------------------
  1 | """Utility for testing the AutoForm form_items API outside of Chrome."""
  2 | 
  3 | from __future__ import annotations
  4 | 
  5 | import argparse
  6 | import json
  7 | import sys
  8 | from pathlib import Path
  9 | 
 10 | import requests
 11 | 
 12 | ENDPOINT = (
 13 |     "https://aimsales-autoform-axabd8h9ajbuesgj.japaneast-01.azurewebsites.net/"
 14 |     "chrome_extension/form_items"
 15 | )
 16 | 
 17 | 
 18 | def read_html(args: argparse.Namespace) -> str:
 19 |     if args.html_file:
 20 |         return Path(args.html_file).read_text(encoding="utf-8")
 21 |     if args.html_url:
 22 |         res = requests.get(args.html_url, timeout=30)
 23 |         res.raise_for_status()
 24 |         return res.text
 25 |     return sys.stdin.read()
 26 | 
 27 | 
 28 | def main() -> None:
 29 |     parser = argparse.ArgumentParser(description="Test the AutoForm form_items API")
 30 |     parser.add_argument("--company", default="サンプル株式会社")
 31 |     parser.add_argument("--email", default="sample@example.com")
 32 |     parser.add_argument("--name", default="山田太郎")
 33 |     parser.add_argument(
 34 |         "--html-file",
 35 |         help="Path to an HTML file whose contents should be sent. If omitted, the script "
 36 |         "falls back to --html-url or STDIN.",
 37 |     )
 38 |     parser.add_argument("--html-url", help="URL to fetch HTML from if no file is given.")
 39 |     parser.add_argument(
 40 |         "--timeout",
 41 |         type=int,
 42 |         default=60,
 43 |         help="Request timeout in seconds (default: 60)",
 44 |     )
 45 |     parser.add_argument(
 46 |         "--pretty",
 47 |         action="store_true",
 48 |         help="Pretty-print the JSON response",
 49 |     )
 50 |     args = parser.parse_args()
 51 | 
 52 |     html = read_html(args)
 53 |     payload = {
 54 |         "send_record": {
 55 |             "company": args.company,
 56 |             "email": args.email,
 57 |             "name": args.name,
 58 |         },
 59 |         "html": html,
 60 |     }
 61 | 
 62 |     res = requests.post(
 63 |         ENDPOINT,
 64 |         headers={"accept": "application/json", "Content-Type": "application/json"},
 65 |         data=json.dumps(payload, ensure_ascii=False).encode("utf-8"),
 66 |         timeout=args.timeout,
 67 |     )
 68 |     res.raise_for_status()
 69 |     data = res.json()
 70 |     if args.pretty:
 71 |         print(json.dumps(data, ensure_ascii=False, indent=2))
 72 |     else:
 73 |         print(json.dumps(data, ensure_ascii=False))
 74 | 
 75 | 
 76 | if __name__ == "__main__":
 77 |     main()
--------------------------------------------------------------------------------

/sample_code/b1_input_module.py:
--------------------------------------------------------------------------------
  1 | # -*- coding: utf-8 -*-
  2 | #########
  3 | import sys
  4 | import os
  5 | 
  6 | if __name__ == "__main__" and __package__ is None:
  7 |     # スクリプトが直接実行された場合、プロジェクトのルートディレクトリをsys.pathに追加
  8 |     script_dir = os.path.dirname(os.path.abspath(__file__))
  9 |     project_root = os.path.abspath(os.path.join(script_dir, "../../")) # 2階層下の場合
 10 |     sys.path.insert(0, project_root)
 11 | #########
 12 | 
 13 | # module/contactform_module/b1_input_module.py
 14 | import asyncio
 15 | import time
 16 | import os
 17 | import re
 18 | import json
 19 | 
 20 | from playwright.async_api import async_playwright
 21 | 
 22 | from module.contactform_module.a_main_analyes import process_url_to_json
 23 | 
 24 | ########################
 25 | # サンプルの入力データ #
 26 | ########################
 27 | SEND_CONTENT = {
 28 |     "name": "阿部 由希子",
 29 |     "name_kana": "あべ ゆきこ",
 30 |     "company": "株式会社LASSIC",
 31 |     "部署": "Remogu事業部",
 32 |     "住所": "東京都港区高輪1-3-13 NBF高輪ビル 4F",
 33 |     "postal_code": "108-0074",
 34 |     "company_kana": "かぶしきがいしゃ らしっく",
 35 |     "prefecture": "東京都",
 36 |     "email": "y.abe@lassic.co.jp",
 37 |     "tel": "03-6455-7720",
 38 |     "fax": "03-6455-7720",
 39 |     "title": "エンジニア採用・調達に関する新規お打ち合わせのご提案",
 40 |     "業種": "IT人材紹介サービス",
 41 |     "URL": "https://www.lassic.co.jp",
 42 |     "remark": "お世話になっております。\n株式会社LASSICの阿部と申します。\n\n本日はエンジニア採用・調達における新規のお打ち合わせの件でご連絡いたしました。\n\n弊社ではIT人材特化型の紹介サービスを展開しておりまして、全国47都道府県から集客した1万人超のデータベースを基に、エンジニアをご紹介させていただいております。\n直近では「React、Next.jsでのフロントエンド開発」のご経験をお持ちの方や「PM、テックリード」のご経験をお持ちの方にも多数ご登録いただいております。\n\nRemoguサービスの強み：\n★実務経験3年以上の即戦力エンジニア/デザイナーが1万8000名ご登録\n★フルリモートワークからハイブリッドワークが可能な方まで幅広い人材バラエティ\n★フリーランス人材/中途採用双方でご支援可能\n★直近上流工程の開発やPM/PL・テックリードのご経験をお持ちの方の流入あり\n★開発系の言語からAI系、ゲーム系言語まで対応可能\n\nこちらのリンクより弊サービスについてご確認いただけますので、ご判断の材料にしていただけますと幸いです。\nhttps://www.lassic.co.jp/service/remogu/\n\nご多忙の中大変恐縮ではございますが、一度オンラインでのお打ち合わせの機会をいただけないでしょうか。\n現時点でのご活用ではなく、情報交換でも構いません。\nもしお話可能でしたら、オンラインにて30～60分ほどミーティングの機会をいただけますと幸いです。\n\n日程調整：https://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\nご検討のほど、よろしくお願い申し上げます。"
 43 | }
 44 | 
 45 | 
 46 | async def sanitize_filename(url):
 47 |     """
 48 |     URLからスクリーンショット保存用などのサニタイズされたファイル名を生成。
 49 |     """
 50 |     domain = re.search(r'https?://([^/]+)', url)
 51 |     if domain:
 52 |         domain = domain.group(1)  # ドメイン部分を取得
 53 |     else:
 54 |         raise ValueError("URLが不正です: {}".format(url))
 55 | 
 56 |     sanitized_filename = re.sub(r'\.', '_', domain)
 57 |     sanitized_filename = sanitized_filename + ".json"  # 拡張子は用途によって変更
 58 |     return sanitized_filename
 59 | 
 60 | 
 61 | async def sanitize_filename_for_image(url):
 62 |     """
 63 |     URLをファイル名として安全にするヘルパー関数（画像用）
 64 |     """
 65 |     from urllib.parse import urlparse
 66 |     parsed_url = urlparse(url)
 67 |     domain = parsed_url.netloc.replace(".", "_")
 68 |     path = parsed_url.path.replace("/", "_")
 69 |     if path == "_":
 70 |         path = ""
 71 |     sanitized = f"{domain}{path}.png"
 72 |     return sanitized
 73 | 
 74 | 
 75 | async def find_element(page, item):
 76 |     """
 77 |     チェックボックス/ラジオボタン以外の要素を探索する。
 78 |     """
 79 |     import re
 80 | 
 81 |     def escape_css_class(cls_name):
 82 |         """
 83 |         CSSクラス名に含まれるコロンやピリオドなど、セレクタとして特別扱いされる
 84 |         文字をバックスラッシュでエスケープする。
 85 |         """
 86 |         return re.sub(r'([^\w-])', r'\\\1', cls_name)
 87 | 
 88 |     form_name = item.get('existing_data', {}).get('form_name')
 89 |     form_classes = item.get('existing_data', {}).get('form_class_id', [])
 90 |     placeholder = item.get('existing_data', {}).get('placeholder', '')
 91 |     label_text = item.get('existing_data', {}).get('label', '')
 92 |     xpath = item.get('existing_data', {}).get('xpath', '')
 93 | 
 94 |     # 1. form_name
 95 |     if form_name:
 96 |         selector = f'[name="{form_name}"]'
 97 |         element = page.locator(selector)
 98 |         if await element.count() > 0:
 99 |             return element.first
100 | 
101 |     # 2. form_class_id  (複数ヒットする可能性があるので、複数時はplaceholderやlabelで再絞り込み)
102 |     if form_classes:
103 |         escaped_classes = [escape_css_class(cls) for cls in form_classes]
104 |         class_selector = "".join(f".{cls}" for cls in escaped_classes)
105 |         elements = page.locator(class_selector)
106 |         count = await elements.count()
107 |         if count == 1:
108 |             # ひとつだけヒットなら、そのまま返す
109 |             return elements.first
110 |         elif count > 1:
111 |             # 複数ヒットした場合、placeholder or label で絞り込みできるか試す
112 |             if placeholder:
113 |                 # placeholder が一致する要素を探す
114 |                 filtered = []
115 |                 for i in range(count):
116 |                     el = elements.nth(i)
117 |                     ph = await el.get_attribute("placeholder") or ""
118 |                     if ph.strip() == placeholder.strip():
119 |                         filtered.append(el)
120 |                 if len(filtered) == 1:
121 |                     return filtered[0]
122 |                 elif len(filtered) > 1:
123 |                     # placeholder まで同じ要素が複数あるなら最初を返す（後方互換用のfallback）
124 |                     return filtered[0]
125 | 
126 |             if label_text:
127 |                 # labelテキストが一致するかを簡易チェック（「for」属性とIDを突き合わせるか、親子関係か など）
128 |                 # ここでは「for属性→id一致」を優先し、だめなら label > input でチェックする例
129 |                 # (実際にはここは後続の label 検索ステップ(4) でやるためスキップでもOKだが、
130 |                 #  フォームクラス重複だけ先に排除しておきたい場合はここで追加する)
131 |                 pass
132 | 
133 |             # ここまでで特定できなければ、従来どおり先頭を返す（後方互換）
134 |             return elements.first
135 | 
136 |     # 3. placeholder
137 |     if placeholder:
138 |         selector = f'input[placeholder="{placeholder}"], textarea[placeholder="{placeholder}"], select[placeholder="{placeholder}"]'
139 |         element = page.locator(selector)
140 |         if await element.count() > 0:
141 |             return element.first
142 | 
143 |     # 4. label
144 |     if label_text:
145 |         label_locator = page.locator(f'label:has-text("{label_text}")')
146 |         if await label_locator.count() > 0:
147 |             # (a) label の for 属性を確認
148 |             for_attr = await label_locator.first.get_attribute("for")
149 |             if for_attr:
150 |                 target = page.locator(f'#{for_attr}')
151 |                 if await target.count() > 0:
152 |                     return target.first
153 | 
154 |             # (b) for 属性が無い/見つからない → 直接子孫の input/textarea/select を探す(従来処理)
155 |             sel = (
156 |                 f'label:has-text("{label_text}") > input, '
157 |                 f'label:has-text("{label_text}") textarea, '
158 |                 f'label:has-text("{label_text}") select'
159 |             )
160 |             element = page.locator(sel)
161 |             if await element.count() > 0:
162 |                 return element.first
163 | 
164 |     # 5. XPath
165 |     if xpath:
166 |         element = page.locator(f'xpath={xpath}')
167 |         if await element.count() > 0:
168 |             return element.first
169 | 
170 |     return None
171 | 
172 | 
173 | async def handle_checkbox(page, element, value):
174 |     """
175 |     チェックボックスの操作を行う。非表示の場合は親ラベルをクリックする。
176 |     """
177 |     try:
178 |         action = value.lower()
179 |         if action in ['selected', 'checked', 'true', 'on']:
180 |             if not await element.is_checked():
181 |                 if await element.is_visible():
182 |                     await element.check()
183 |                 else:
184 |                     label = element.locator('xpath=..')
185 |                     if await label.count() > 0 and await label.is_visible():
186 |                         await label.click()
187 |                         if not await element.is_checked():
188 |                             print("チェックボックスの選択に失敗しました")
189 |                     else:
190 |                         raise Exception("非表示のチェックボックスを操作できません。親ラベルが見つかりません")
191 |         elif action in ['unselected', 'unchecked', 'false', 'off']:
192 |             if await element.is_checked():
193 |                 if await element.is_visible():
194 |                     await element.uncheck()
195 |                 else:
196 |                     label = element.locator('xpath=..')
197 |                     if await label.count() > 0 and await label.is_visible():
198 |                         await label.click()
199 |                         if await element.is_checked():
200 |                             print("チェックボックスの解除に失敗しました")
201 |                     else:
202 |                         raise Exception("非表示のチェックボックスを操作できません。親ラベルが見つかりません")
203 |         else:
204 |             print(f"未対応の値が指定されました: {value}")
205 |     except Exception as e:
206 |         print(f"チェックボックス操作中にエラーが発生しました: {e}")
207 | 
208 | 
209 | async def find_element_with_value(page, item):
210 |     """
211 |     チェックボックスやラジオボタン向けに、指定された value を持つ要素を探索。
212 |     ※ XPath を優先的に試し、うまくいかない場合は従来のロジックにフォールバック。
213 |     """
214 |     xpath = item.get('existing_data', {}).get('xpath', '')
215 |     form_name = item.get('existing_data', {}).get('form_name')
216 |     input_value = item.get('input_data', {}).get('value', '')
217 |     if not input_value:
218 |         # input_data.value が空なら existing_data.value を使う
219 |         input_value = item.get('existing_data', {}).get('value', '')
220 |     label_text = item.get('existing_data', {}).get('label', '')
221 | 
222 |     # -------------------
223 |     # ①まず XPath を試す
224 |     # -------------------
225 |     if xpath:
226 |         possible_elements = page.locator(f'xpath={xpath}')
227 |         if await possible_elements.count() > 0:
228 |             first_elem = possible_elements.first
229 |             input_type = (await first_elem.get_attribute('type') or '').lower()
230 |             if input_type in ["checkbox", "radio"]:
231 |                 return first_elem
232 |             else:
233 |                 print(f"XPath で要素は見つかったが、checkbox/radio ではありませんでした -> type={input_type}")
234 |         else:
235 |             print("XPathで checkbox/radio が見つかりませんでした。フォールバックします。")
236 | 
237 |     # ---------------------------------------------------------------------
238 |     # ②フォールバック（従来のロジック： form_name, label, value などで検索）
239 |     # ---------------------------------------------------------------------
240 |     # unselected/unchecked系 → name や label のみチェック
241 |     if input_value.lower() in ["unselected", "unchecked", "false", "off"]:
242 |         if form_name:
243 |             selector = f'[name="{form_name}"]'
244 |             element = page.locator(selector)
245 |             if await element.count() > 0:
246 |                 return element.first
247 | 
248 |         if label_text:
249 |             # label のfor属性から
250 |             label_locator = page.locator(f'label:has-text("{label_text}")')
251 |             if await label_locator.count() > 0:
252 |                 for_attr = await label_locator.first.get_attribute("for")
253 |                 if for_attr:
254 |                     # for 属性と id が一致する要素があれば返す
255 |                     target = page.locator(f'#{for_attr}')
256 |                     if await target.count() > 0:
257 |                         return target.first
258 |                 # ダメなら label直下input
259 |                 fallback_sel = f'label:has-text("{label_text}") > input'
260 |                 element = page.locator(fallback_sel)
261 |                 if await element.count() > 0:
262 |                     return element.first
263 |         return None
264 | 
265 |     # selected系/ラジオのvalue指定など
266 |     if form_name and input_value:
267 |         selector = f'[name="{form_name}"][value="{input_value}"]'
268 |         element = page.locator(selector)
269 |         if await element.count() > 0:
270 |             return element.first
271 | 
272 |     if label_text:
273 |         label_locator = page.locator(f'label:has-text("{label_text}")')
274 |         if await label_locator.count() > 0:
275 |             for_attr = await label_locator.first.get_attribute("for")
276 |             if for_attr:
277 |                 target = page.locator(f'#{for_attr}')
278 |                 if await target.count() > 0:
279 |                     return target.first
280 |             fallback_sel = f'label:has-text("{label_text}") > input'
281 |             element = page.locator(fallback_sel)
282 |             if await element.count() > 0:
283 |                 return element.first
284 | 
285 |     return None
286 | 
287 | 
288 | # 追加する新規関数
289 | async def handle_radio(page, element):
290 |     """
291 |     ラジオボタンの操作を行う。非表示の場合は親ラベルをクリックする。
292 |     """
293 |     try:
294 |         if not await element.is_checked():
295 |             if await element.is_visible():
296 |                 await element.click()
297 |             else:
298 |                 label = element.locator('xpath=..')
299 |                 if await label.count() > 0 and await label.is_visible():
300 |                     await label.click()
301 |                 else:
302 |                     raise Exception("非表示のラジオボタンを操作できません。親ラベルが見つかりません")
303 |     except Exception as e:
304 |         print(f"ラジオボタン操作中にエラーが発生しました: {e}")
305 | 
306 | 
307 | # 既存のhandle_element_input関数を以下のように修正
308 | async def handle_element_input(page, element, element_type, value):
309 |     """
310 |     チェックボックス/セレクト/テキスト系の入力を行う。
311 |     """
312 |     actual_html_type = await element.get_attribute('type') or ''
313 |     actual_html_type = actual_html_type.lower()
314 | 
315 |     # ラジオボタンなのにコード側はテキスト系と見なしている場合 → スキップ
316 |     if actual_html_type == 'radio' and element_type in ['text', 'email', 'tel', 'password', 'search', 'url', 'textarea']:
317 |         print("【handle_element_input】実際の要素はradioのため、テキスト入力をスキップします。")
318 |         return
319 | 
320 |     if element_type in ['text', 'email', 'tel', 'password', 'search', 'url', 'textarea']:
321 |         try:
322 |             # 対象要素が表示されるまで待機（最大3000ms）
323 |             await element.wait_for(state="visible", timeout=3000)
324 |             await element.click()  # フォーカスを与える
325 |             await element.clear()  # 既存値をクリア
326 |             await element.type(value, delay=0.5)  # キーボードイベント付きで高速入力
327 |         except Exception as e:
328 |             print(f"【handle_element_input】要素が表示されなかったため、fillをスキップします: {e}")
329 | 
330 |     elif element_type in ['select', 'dropdown']:
331 |         await element.select_option(value=value)
332 | 
333 |     elif element_type == 'radio':
334 |         # ラジオボタンを押下(非表示なら親ラベルをクリック)
335 |         if not await element.is_checked():
336 |             if await element.is_visible():
337 |                 await element.click()
338 |             else:
339 |                 label = element.locator('xpath=..')
340 |                 if await label.count() > 0 and await label.is_visible():
341 |                     await label.click()
342 |                 else:
343 |                     print("【handle_element_input】非表示のラジオボタンを操作できません。")
344 | 
345 |     elif element_type == 'checkbox':
346 |         await handle_checkbox(page, element, value)
347 | 
348 |     else:
349 |         print(f"未対応の要素タイプ(入力系): {element_type}")
350 | 
351 | 
352 | async def click_confirm_button_if_exists(page):
353 |     """
354 |     確認画面で再度送信ボタンをクリックする
355 | 
356 |     Returns:
357 |         bool: ボタンをクリックできた場合True、見つからない場合False
358 |     """
359 |     confirm_selectors = [
360 |         'button:has-text("送信")',
361 |         'button:has-text("登録")',
362 |         'button:has-text("確定")',
363 |         'input[type="submit"]',
364 |         'button[type="submit"]'
365 |     ]
366 | 
367 |     for selector in confirm_selectors:
368 |         button = page.locator(selector)
369 |         if await button.count() > 0:
370 |             await button.click()
371 |             print(f"確認画面で{selector}をクリックしました")
372 |             return True
373 |     return False
374 | 
375 | 
376 | async def upload_screenshot_to_azure(page, blob_name):
377 |     """
378 |     Playwrightで撮影したスクリーンショットをAzure Blob Storageに直接アップロードするヘルパー関数。
379 |     :param page: Playwrightのpageオブジェクト
380 |     :param blob_name: アップロード先Blobのファイル名 (例: "example_before.png")
381 |     :return: アップロード後のBlobのURL
382 |     """
383 |     from azure.storage.blob import BlobClient, ContentSettings
384 | 
385 |     # コンテナのSAS URLとBlob用のSASトークン（直接記述）
386 |     container_sas_url = "https://cs110032002948a3263.blob.core.windows.net/aimsales-strage"
387 |     sas_token = "?sp=racwdli&st=2025-02-27T23:22:13Z&se=2025-12-01T07:22:13Z&spr=https&sv=2022-11-02&sr=c&sig=IkcKUDXSqpIeDVF3AAiEtpEusBw2Su1gJe3lkNT%2BOY4%3D"
388 | 
389 |     # スクリーンショットをバイナリで取得（path=Noneでbytesとして受け取る）
390 |     screenshot_bytes = await page.screenshot(full_page=True)
391 | 
392 |     # アップロード先のBlob URLを組み立て（コンテナURL + "autoform"ディレクトリ下 + blob_name + SASトークン）
393 |     blob_url = f"{container_sas_url}/autoform/{blob_name}{sas_token}"
394 | 
395 |     # BlobClient作成
396 |     blob_client = BlobClient.from_blob_url(blob_url=blob_url)
397 | 
398 |     # Content-Type を image/png に設定
399 |     content_settings = ContentSettings(content_type='image/png')
400 | 
401 |     # Blobへアップロード（同名ファイルがある場合は上書き）
402 |     blob_client.upload_blob(screenshot_bytes, overwrite=True, content_settings=content_settings)
403 | 
404 |     print(f"スクリーンショットをAzureにアップロードしました: {blob_url}")
405 |     return blob_url
406 | 
407 | 
408 | async def fill_form(page, url, form_data):
409 |     """
410 |     JSONで定義されたform_dataを使い、フォームを入力するだけ（送信ボタンは押さない）。
411 |     送信ボタンのLocatorを返す。
412 |     """
413 |     from playwright.async_api import TimeoutError as PlaywrightTimeoutError, Error as PlaywrightError
414 | 
415 |     try:
416 |         await page.goto(url)
417 |         await page.wait_for_selector("body", timeout=5000)
418 |     except PlaywrightTimeoutError:
419 |         print("body要素がロードされませんでした。")
420 | 
421 |     submit_locator = None
422 | 
423 |     for item in form_data:
424 |         existing_data = item.get('existing_data', {})
425 |         element_type = existing_data.get('type', '').lower()
426 |         input_value = item.get('input_data', {}).get('value', '').strip()
427 | 
428 |         if not element_type:
429 |             element_type = 'text'
430 | 
431 |         if element_type == 'hidden':
432 |             print("Skipping hidden field (type=hidden).")
433 |             continue
434 | 
435 |         if element_type in ['checkbox', 'radio']:
436 |             element = await find_element_with_value(page, item)
437 |         else:
438 |             element = await find_element(page, item)
439 | 
440 |         if not element:
441 |             print(f"要素が見つかりませんでした -> type={element_type}, value={input_value}")
442 |             continue
443 | 
444 |         if not input_value and element_type not in ['checkbox', 'submit', 'button']:
445 |             continue
446 | 
447 |         if element_type in ['submit', 'button']:
448 |             if input_value == 'click' and not submit_locator:
449 |                 submit_locator = element
450 |                 print(f"送信ボタンのLocatorを取得しました（まだクリックしていません）")
451 |             else:
452 |                 print(f"type={element_type} のボタンですが、value=click が指定されていないためクリック対象としてスキップします。")
453 |         else:
454 |             await handle_element_input(page, element, element_type, input_value)
455 | 
456 |     # 送信ボタンが見つからない場合のフォールバック処理
457 |     if not submit_locator:
458 |         # より包括的なフォールバックセレクタ
459 |         fallback_selectors = [
460 |             'button:has-text("送信")',
461 |             'button:has-text("確認")',
462 |             'button:has-text("確定")',
463 |             'input[type="button"][value*="送信"]',
464 |             'input[type="button"][value*="確認"]',
465 |             'input[type="submit"]',
466 |             'button[type="submit"]'
467 |         ]
468 | 
469 |         for selector in fallback_selectors:
470 |             fallback_button = page.locator(selector)
471 |             if await fallback_button.count() > 0:
472 |                 submit_locator = fallback_button.first
473 |                 print(f"【fallback】{selector} で送信ボタンを発見")
474 |                 break
475 | 
476 |         if not submit_locator:
477 |             print("送信ボタンが見つかりませんでした。")
478 | 
479 |     print("フォーム入力完了（送信ボタンは押していません）")
480 | 
481 |     return submit_locator
482 | 
483 | 
484 | async def main(url, send_content):
485 |     """
486 |     b1_main: フォーム構造を解析し、入力を行う。送信は行わない。
487 |     戻り値として (playwright, browser, page, submit_locator, None) を返す。
488 |     スクリーンショット撮影はb2_0_output_moduleに移行。
489 |     """
490 |     import json
491 |     from playwright.async_api import async_playwright
492 | 
493 |     form_data = await process_url_to_json(url, send_content)
494 |     if form_data:
495 |         json_filename = await sanitize_filename(url)
496 |         with open(json_filename, "w", encoding="utf-8") as json_file:
497 |             json.dump(form_data, json_file, ensure_ascii=False, indent=4)
498 |         print(f"JSONデータをファイルに保存しました: {json_filename}")
499 |     else:
500 |         print("フォームデータが存在しないため、送信をスキップします。")
501 |         return None, None, None, None, None
502 | 
503 |     p = await async_playwright().start()
504 |     browser = await p.chromium.launch(headless=False)
505 |     page = await browser.new_page(viewport={"width": 300, "height": 800})
506 | 
507 |     # フォーム入力のみ実行
508 |     submit_locator = await fill_form(page, url, form_data)
509 |     print("フォーム入力完了。送信ボタンLocator:", submit_locator)
510 | 
511 |     # b2で使うためにpageやsubmit_locator等を返す
512 |     # スクリーンショット撮影はb2_0_output_moduleに移行したため、blob_url_beforeはNoneを返す
513 |     return p, browser, page, submit_locator, None
514 | 
515 | 
516 | 
517 | if __name__ == "__main__":
518 |     # テスト用のURL（適宜差し替えてください）
519 |     # test_url = "https://aimsales.jp/form"
520 |     test_url = "https://wakayama-export.com/inquiry"
521 | 
522 |     # 非同期関数を実行するためのイベントループを取得
523 |     loop = asyncio.get_event_loop()
524 | 
525 |     # main() の呼び出しを 2 引数にする
526 |     p, browser, page, submit_locator, _ = loop.run_until_complete(main(test_url, SEND_CONTENT))
527 | 
528 |     print("単体テスト実行が完了しました。")
529 |     print(f"送信ボタンLocator: {submit_locator}")
530 | 
531 |     print("ブラウザを開いて確認できます。")
532 |     try:
533 |         while True:
534 |             loop.run_until_complete(asyncio.sleep(1))
535 |     except KeyboardInterrupt:
536 |         print("KeyboardInterruptを受け付けました。ブラウザを閉じて終了します。")
537 |     finally:
538 |         loop.run_until_complete(browser.close())
539 |         loop.run_until_complete(p.stop())
--------------------------------------------------------------------------------

/sample_code/b2_0_output_module.py:
--------------------------------------------------------------------------------
  1 | # -*- coding: utf-8 -*-
  2 | #########
  3 | import sys
  4 | import os
  5 | 
  6 | if __name__ == "__main__" and __package__ is None:
  7 |     # スクリプトが直接実行された場合、プロジェクトのルートディレクトリをsys.pathに追加
  8 |     script_dir = os.path.dirname(os.path.abspath(__file__))
  9 |     project_root = os.path.abspath(os.path.join(script_dir, "../../")) # 2階層下の場合
 10 |     sys.path.insert(0, project_root)
 11 | #########
 12 | 
 13 | # module/contactform_module/b2_0_output_module.py
 14 | # b2_1_url2button.pyやb2_1_url2button.pyはb2_0_output_module.pyのための部品
 15 | 
 16 | import os
 17 | import time
 18 | import json
 19 | import asyncio
 20 | import re
 21 | from datetime import datetime
 22 | 
 23 | from module.contactform_module.b1_input_module import (
 24 |     main as input_main
 25 | )
 26 | 
 27 | from module.contactform_module._b2_1_url2button import main as button_main
 28 | from module.contactform_module._b2_2_classify_status import classify_message, determine_status
 29 | 
 30 | # CLI実行時のデバッグフラグ
 31 | DEBUG_SAVE_CURL = False
 32 | 
 33 | 
 34 | def save_curl_to_file(curl_cmd, url):
 35 |     """
 36 |     curlコマンドをファイルに保存する関数
 37 |     """
 38 |     if not DEBUG_SAVE_CURL:
 39 |         return
 40 | 
 41 |     try:
 42 |         timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 43 |         with open("curl_debug.txt", "a", encoding="utf-8") as f:
 44 |             f.write(f"\n=== {timestamp} ===\n")
 45 |             f.write(f"URL: {url}\n")
 46 |             f.write(f"{curl_cmd}\n")
 47 |             f.write("=" * 50 + "\n")
 48 |         print(f"curlコマンドを curl_debug.txt に保存しました")
 49 |     except Exception as e:
 50 |         print(f"curlコマンドの保存中にエラーが発生しました: {e}")
 51 | 
 52 | 
 53 | async def click_confirm_button_if_exists(page, button_data, max_click=1):
 54 |     """
 55 |     確認画面や再度表示されたフォームでの「送信する」ボタン等をクリックする関数。
 56 | 
 57 |     1) input_data.value == 'click' のボタンを最大 max_click 回探して押す
 58 |     2) もし一切クリックできなければ、文言検索で「確認」「はい」などのボタンを探して押す
 59 |     3) それでも見つからなければ何もせず終了
 60 | 
 61 |     画面遷移 (expect_navigation) を試みるが、SPA（部分描画）の場合は
 62 |     タイムアウト後に wait_for_timeout(2000) で少し待機して次の操作に移る。
 63 |     """
 64 | 
 65 |     async def universal_click(selector_or_xpath, timeout_ms=5000):
 66 |         """
 67 |         buttonやinput[type=button]をクリックするとき、
 68 |         アニメーション等で要素が不安定な場合に備えて force=True を利用し、
 69 |         ページ遷移を期待する。遷移しなければ部分描画とみなして継続。
 70 |         """
 71 |         try:
 72 |             # 要素がvisibleになるまで待機
 73 |             await page.wait_for_selector(selector_or_xpath, state='visible', timeout=timeout_ms)
 74 |             # ナビゲーションを期待しつつ、要素の不安定(hoverアニメ等)を無視しクリック
 75 |             async with page.expect_navigation(timeout=timeout_ms):
 76 |                 await page.click(selector_or_xpath, force=True)
 77 |             print("ナビゲーション完了。")
 78 |         except Exception as e:
 79 |             print(f"[WARN] ナビゲーションが起きませんでした: {e}")
 80 |             await page.wait_for_timeout(2000)  # SPA的に画面だけ切り替わる想定で待機
 81 | 
 82 |     clicked_any = False
 83 | 
 84 |     # (A) 'click' ボタンを最大 max_click 回だけ試す
 85 |     for _ in range(max_click):
 86 |         found_click_btn = False
 87 |         for b in button_data.get("button_data", []):
 88 |             if b["input_data"]["value"] == "click":
 89 |                 xpath_selector = b["existing_data"].get("xpath")
 90 |                 if xpath_selector:
 91 |                     print(f"「input_data.value=='click' のボタン」をクリックします: {xpath_selector}")
 92 |                     await universal_click(f'xpath={xpath_selector}')
 93 |                     clicked_any = True
 94 |                     found_click_btn = True
 95 |                     # 画面切り替わりの可能性があるため break → 再ループ
 96 |                     break
 97 |         if not found_click_btn:
 98 |             break
 99 | 
100 |     # (B) 「click」ボタンを押せなかった場合、文言検索パターンで「はい」「確認」等をクリック
101 |     if not clicked_any:
102 |         possible_selectors = [
103 |             'button:has-text("はい")',
104 |             'button:has-text("確認")',
105 |             'input[type="button"][value="はい"]',
106 |             'input[type="submit"][value="確認"]'
107 |         ]
108 |         for selector in possible_selectors:
109 |             button_list = await page.query_selector_all(selector)
110 |             if button_list:
111 |                 print(f"確認ボタンをクリックします: {selector}")
112 |                 await universal_click(selector)
113 |                 clicked_any = True
114 |                 break
115 | 
116 |     return clicked_any
117 | 
118 | async def setup_network_handlers(page, send_content, url):
119 |     """
120 |     ネットワーク通信を検知するハンドラを設置する
121 |     """
122 |     email = send_content.get('email', '')
123 |     if not email:
124 |         print("警告: SEND_CONTENTにemailが含まれていません。")
125 |         return {"detected": False}
126 | 
127 |     print(f"ネットワーク通信検知ハンドラを設置します。検知対象email: {email}")
128 | 
129 |     # 条件にヒットしたリクエストのURLを記録するセット
130 |     matched_request_urls = set()
131 | 
132 |     # ★ 検出フラグ（辞書にするとミューテーブルなのでクロージャで書き換え可）
133 |     hit = {"detected": False}
134 | 
135 |     async def handle_request(request):
136 |         try:
137 |             post_data = request.post_data
138 |             if post_data:
139 |                 # URLエンコード対応
140 |                 import urllib.parse
141 |                 email_raw = send_content.get('email', '')
142 |                 email_enc = urllib.parse.quote_plus(email_raw)  # @ → %40
143 | 
144 |                 # 生のメールアドレスまたはエンコードされたメールアドレスを検知
145 |                 if email_raw in post_data or email_enc in post_data:
146 |                     hit["detected"] = True  # ★検知したら True
147 | 
148 |                     # curlコマンドを生成
149 |                     headers_str = ' \\\n'.join([f"  -H '{k}: {v}'" for k, v in request.headers.items()])
150 |                     curl_cmd = f"curl '{request.url}' \\\n{headers_str}"
151 | 
152 |                     if post_data:
153 |                         curl_cmd += f" \\\n  --data-raw '{post_data}'"
154 | 
155 |                     print("\n=== DETECTED EMAIL IN REQUEST ===")
156 |                     print(f"検知したメール: 生={email_raw}, エンコード={email_enc}")
157 |                     print(curl_cmd)
158 |                     print("================================\n")
159 | 
160 |                     # CLI実行時のみファイルに保存
161 |                     save_curl_to_file(curl_cmd, url)
162 | 
163 |                     # このリクエストのURLを記録（レスポンス記録用）
164 |                     matched_request_urls.add(request.url)
165 | 
166 |         except Exception as e:
167 |             print(f"リクエスト解析中にエラーが発生しました: {e}")
168 | 
169 |     async def handle_response(response):
170 |         try:
171 |             # 条件にヒットしたリクエストのレスポンスのみ記録
172 |             if response.url in matched_request_urls:
173 |                 headers = dict(response.headers)
174 | 
175 |                 # リダイレクトレスポンスの場合はボディを取得しない
176 |                 if 300 <= response.status < 400:
177 |                     body_preview = "[Redirect Response - Body not available]"
178 |                 else:
179 |                     try:
180 |                         body = await response.text()
181 |                         body_preview = body[:30] if body else ""
182 |                     except Exception as body_error:
183 |                         body_preview = f"[Body unavailable: {str(body_error)}]"
184 | 
185 |                 print(f"\n=== DETECTED RESPONSE FOR {response.url} ===")
186 |                 print(f"Status: {response.status}")
187 |                 print(f"Headers: {headers}")
188 |                 print(f"Body (first 30 chars): {body_preview}")
189 |                 print("=" * 50 + "\n")
190 | 
191 |                 # CLI実行時のみファイルに保存
192 |                 if DEBUG_SAVE_CURL:
193 |                     timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
194 |                     with open("curl_debug.txt", "a", encoding="utf-8") as f:
195 |                         f.write(f"\n--- RESPONSE {timestamp} ---\n")
196 |                         f.write(f"Status: {response.status}\n")
197 |                         f.write(f"Headers: {headers}\n")
198 |                         f.write(f"Body (first 30 chars): {body_preview}\n")
199 |                         f.write("=" * 50 + "\n")
200 |                     print(f"レスポンス情報を curl_debug.txt に保存しました")
201 | 
202 |         except Exception as e:
203 |             print(f"レスポンス解析中にエラーが発生しました: {e}")
204 | 
205 |     # リクエストとレスポンスイベントにハンドラを登録
206 |     page.on('request', handle_request)
207 |     page.on('response', handle_response)
208 | 
209 |     # ★戻り値を変更
210 |     return hit
211 | 
212 | async def upload_screenshot_to_azure(page, blob_name):
213 |     """
214 |     Playwrightで撮影したスクリーンショットをAzure Blob Storageに直接アップロードするヘルパー関数。
215 |     :param page: Playwrightのpageオブジェクト
216 |     :param blob_name: アップロード先Blobのファイル名 (例: "example_after.png")
217 |     :return: アップロード後のBlobのURL
218 |     """
219 |     from azure.storage.blob import BlobClient, ContentSettings
220 | 
221 |     # コンテナのSAS URLとBlob用のSASトークン（直接記述）
222 |     container_sas_url = "https://aimsales.blob.core.windows.net/aimsales-image"
223 |     sas_token = "?sp=racw&st=2025-05-23T03:04:12Z&se=2027-02-01T11:04:12Z&spr=https&sv=2024-11-04&sr=c&sig=dSJhH9o2aWpLs7MU7%2B5JVK7wF9Lv0EPgIt9oasFjwyk%3D"
224 | 
225 |     screenshot_bytes = await page.screenshot(full_page=True)
226 |     blob_url = f"{container_sas_url}/autoform/{blob_name}{sas_token}"
227 | 
228 |     blob_client = BlobClient.from_blob_url(blob_url=blob_url)
229 | 
230 |     content_settings = ContentSettings(content_type='image/png')
231 |     blob_client.upload_blob(screenshot_bytes, overwrite=True, content_settings=content_settings)
232 | 
233 |     print(f"スクリーンショットをAzureにアップロードしました: {blob_url}")
234 |     return blob_url
235 | 
236 | async def sanitize_filename_for_image(url):
237 |     """
238 |     URLをファイル名として安全にするヘルパー関数（画像用）
239 |     """
240 |     from urllib.parse import urlparse
241 |     parsed_url = urlparse(url)
242 |     domain = parsed_url.netloc.replace(".", "_")
243 |     path = parsed_url.path.replace("/", "_")
244 |     if path == "_":
245 |         path = ""
246 |     sanitized = f"{domain}{path}.png"
247 |     return sanitized
248 | 
249 | 
250 | # module/contactform_module/b2_0_output_module.py
251 | 
252 | async def main(url, send_content):
253 |     """
254 |     メイン処理：
255 |       1. フォーム入力 (b1_input_module.py の main を使用)
256 |       2. ネットワーク通信検知ハンドラの設置
257 |       3. 送信前のスクリーンショット撮影
258 |       4. 送信ボタン押下
259 |       5. 送信後の画面解析（ボタン解析、テキスト分類、再試行、送信完了後のスクリーンショット取得、等）
260 |     """
261 |     # (1) フォーム入力（送信ボタンは押さない）
262 |     p, browser, page, submit_locator, _ = await input_main(url, send_content)
263 | 
264 |     if not p or not browser or not page:
265 |         print("b1_input_moduleの実行に失敗しました。")
266 |         return "failed", None, None
267 | 
268 |     # (2) ネットワーク通信検知ハンドラの設置
269 |     net_hit = await setup_network_handlers(page, send_content, url)
270 | 
271 |     # (3) 送信前スクリーンショットの撮影
272 |     screenshot_filename_before = await sanitize_filename_for_image(url)
273 |     screenshot_filename_before = screenshot_filename_before.replace(".png", "_before.png")
274 |     blob_url_before = await upload_screenshot_to_azure(page, screenshot_filename_before)
275 |     print(f"【b2_0_output_module】送信前のスクリーンショットを撮影しました: {blob_url_before}")
276 | 
277 |     # (4) 送信ボタンが見つかったらクリックする
278 |     if submit_locator:
279 |         await submit_locator.click()
280 |         print("送信ボタンをクリックしました。")
281 |     else:
282 |         print("送信ボタンが見つからなかったため、fallbackで様々なパターンを探します。")
283 |         # 拡張fallback処理
284 |         fallback_selectors = [
285 |             'input[type="submit"]',
286 |             'button[type="submit"]',
287 |             'button:has-text("送信")',
288 |             'button:has-text("確認")',
289 |             'button:has-text("登録")',
290 |             'button:has-text("申し込み")',
291 |             'button:has-text("問い合わせ")',
292 |             'input[type="button"][value*="送信"]',
293 |             'input[type="button"][value*="確認"]',
294 |             'input[type="button"][value*="登録"]',
295 |             'input[value*="送信"]',
296 |             'input[value*="確認"]',
297 |             'input[value*="登録"]',
298 |             'button[class*="submit"]',
299 |             'button[class*="send"]',
300 |             'button[id*="submit"]',
301 |             'button[id*="send"]',
302 |             'a[href*="submit"]',
303 |             'a:has-text("送信")',
304 |             'a:has-text("確認")',
305 |             'a:has-text("登録")'
306 |         ]
307 | 
308 |         submit_found = False
309 |         for selector in fallback_selectors:
310 |             try:
311 |                 fallback_locator = page.locator(selector)
312 |                 if await fallback_locator.count() > 0:
313 |                     await fallback_locator.first.click()
314 |                     print(f"fallbackの送信ボタンをクリックしました: {selector}")
315 |                     submit_found = True
316 |                     break
317 |             except Exception as e:
318 |                 print(f"fallback selector {selector} でエラー: {e}")
319 |                 continue
320 | 
321 |         if not submit_found:
322 |             print("送信ボタンが見つからず、送信できませんでした。")
323 |             # 送信後のスクリーンショットも撮影してから終了
324 |             screenshot_filename_after = await sanitize_filename_for_image(url)
325 |             screenshot_filename_after = screenshot_filename_after.replace(".png", "_after.png")
326 |             blob_url_after = await upload_screenshot_to_azure(page, screenshot_filename_after)
327 |             print(f"【b2_0_output_module】送信ボタンが見つからなかった時のスクリーンショットを保存しました: {blob_url_after}")
328 | 
329 |             await browser.close()
330 |             await p.stop()
331 |             return "failed", blob_url_before, blob_url_after
332 | 
333 |     await page.wait_for_timeout(2000)  # 送信直後の画面遷移待ち
334 | 
335 |     # (4) ボタン解析
336 |     html_content = await page.content()
337 |     button_data = button_main(html_content)
338 |     print("\n--- 解析したボタン情報 ---")
339 |     print(json.dumps(button_data, indent=4, ensure_ascii=False))
340 |     print("\nフォーム送信処理が完了し、ボタン情報を出力しました。")
341 | 
342 |     # --- 確認ボタンを優先的にクリック ---
343 |     # 解析結果に「click」対象ボタンがあれば即クリック
344 |     if button_data["complete_button_count"] > 0:
345 |         print("確認ボタンが検出されました。即座にクリックします。")
346 |         await click_confirm_button_if_exists(page, button_data, max_click=1)
347 |         await asyncio.sleep(2)          # 画面遷移待ち
348 |         html_content = await page.content()   # 最新 HTML を取り直す
349 |         print("確認ボタンクリック後のHTMLを取得しました。")
350 | 
351 |     # (5) テキスト分類
352 |     count1, count2, count3, hits1, hits2, hits3 = classify_message(html_content)
353 |     print("【分類結果】")
354 |     print(f"①（未完了を示す文言）の個数: {count1}")
355 |     print(f"②（完了を示す文言）の個数: {count2}")
356 |     print(f"③（失敗を示す文言）の個数: {count3}")
357 |     if hits1:
358 |         print(f"  未完了カテゴリ ヒットキーワード: {hits1}")
359 |     if hits2:
360 |         print(f"  完了カテゴリ ヒットキーワード: {hits2}")
361 |     if hits3:
362 |         print(f"  失敗カテゴリ ヒットキーワード: {hits3}")
363 | 
364 |     status = determine_status(count1, count2, count3)
365 |     print(f"[初回判定] status = '{status}'")
366 | 
367 |     # (6) リトライ処理（省略せず既存ロジック通り）
368 |     max_retry = 2
369 |     attempt = 0
370 |     while status not in ("success", "failed") and attempt < max_retry:
371 |         attempt += 1
372 |         if status in ("confirm", "unknown"):
373 |             print(f"[再クリック試行 {attempt}回目] status={status} → 再度ボタン押下を試みます。")
374 |             clicked = await click_confirm_button_if_exists(page, button_data, max_click=2)
375 |             if clicked:
376 |                 await asyncio.sleep(2)
377 |                 try:
378 |                     html_content = await page.content()
379 |                 except Exception as e:
380 |                     print(f"ページのHTML内容取得中にエラーが発生しました: {e}")
381 |                     break
382 |                 count1, count2, count3, hits1, hits2, hits3 = classify_message(html_content)
383 |                 status = determine_status(count1, count2, count3)
384 |                 print(f"[再判定] status = '{status}'")
385 |             else:
386 |                 print("再クリックできるボタンが見つからなかったため、リトライを終了します。")
387 |                 break
388 |         else:
389 |             break
390 | 
391 |     # ★ ネットワーク検知による最終補正
392 |     if not net_hit["detected"]:
393 |         print("⚠️  メール入りリクエストが検出できなかったため failed 扱いにします。")
394 |         status = "failed"
395 | 
396 |     if status == "failed":
397 |         print("フォーム送信に失敗したと判断しました。")
398 |     elif status == "success":
399 |         print("フォーム送信が完了したと判断しました。")
400 |     elif status == "confirm":
401 |         print("まだ確認画面のままのようです。想定外かもしれません。")
402 |     else:
403 |         print("完了/失敗/未完了のいずれのキーワードも見当たらないため unknown 判定。")
404 |     print(f"最終ステータス: {status}")
405 |     await asyncio.sleep(3)
406 |     # (7) 送信完了後のスクリーンショットを取得
407 |     screenshot_filename_after = await sanitize_filename_for_image(url)
408 |     screenshot_filename_after = screenshot_filename_after.replace(".png", "_after.png")
409 |     blob_url_after = await upload_screenshot_to_azure(page, screenshot_filename_after)
410 |     print(f"【b2_0_output_module】送信完了後のスクリーンショットを保存しました: {blob_url_after}")
411 | 
412 |     await browser.close()
413 |     await p.stop()
414 | 
415 |     return status, blob_url_before, blob_url_after
416 | 
417 | if __name__ == "__main__":
418 |     import asyncio
419 | 
420 |     # CLI実行時のデバッグフラグを有効化
421 |     DEBUG_SAVE_CURL = True
422 |     print("CLI実行モード: curlコマンドをcurl_debug.txtに保存します")
423 | 
424 |     # テスト用のURLと送信内容（適宜修正してください）
425 |     test_url = "https://alsel.co.jp/pages/contact"
426 |     # test_url = "https://www.letara.space/contact"
427 | 
428 | 
429 |     SEND_CONTENT = {
430 |         "name": "阿部 由希子",
431 |         "name_kana": "あべ ゆきこ",
432 |         "company": "株式会社LASSIC",
433 |         "部署": "Remogu事業部",
434 |         "住所": "東京都港区高輪1-3-13 NBF高輪ビル 4F",
435 |         "postal_code": "108-0074",
436 |         "company_kana": "かぶしきがいしゃ らしっく",
437 |         "prefecture": "東京都",
438 |         "email": "y.abe@lassic.co.jp",
439 |         "tel": "03-6455-7720",
440 |         "fax": "03-6455-7720",
441 |         "title": "エンジニア採用・調達に関する新規お打ち合わせのご提案",
442 |         "業種": "IT人材紹介サービス",
443 |         "URL": "https://www.lassic.co.jp",
444 |         "remark": "お世話になっております。\n株式会社LASSICの阿部と申します。\n\n本日はエンジニア採用・調達における新規のお打ち合わせの件でご連絡いたしました。\n\n弊社ではIT人材特化型の紹介サービスを展開しておりまして、全国47都道府県から集客した1万人超のデータベースを基に、エンジニアをご紹介させていただいております。\n直近では「React、Next.jsでのフロントエンド開発」のご経験をお持ちの方や「PM、テックリード」のご経験をお持ちの方にも多数ご登録いただいております。\n\nRemoguサービスの強み：\n★実務経験3年以上の即戦力エンジニア/デザイナーが1万8000名ご登録\n★フルリモートワークからハイブリッドワークが可能な方まで幅広い人材バラエティ\n★フリーランス人材/中途採用双方でご支援可能\n★直近上流工程の開発やPM/PL・テックリードのご経験をお持ちの方の流入あり\n★開発系の言語からAI系、ゲーム系言語まで対応可能\n\nこちらのリンクより弊サービスについてご確認いただけますので、ご判断の材料にしていただけますと幸いです。\nhttps://www.lassic.co.jp/service/remogu/\n\nご多忙の中大変恐縮ではございますが、一度オンラインでのお打ち合わせの機会をいただけないでしょうか。\n現時点でのご活用ではなく、情報交換でも構いません。\nもしお話可能でしたら、オンラインにて30～60分ほどミーティングの機会をいただけますと幸いです。\n\n日程調整：https://nitte.app/QY6j3DQE60gxhQk40G8ulgiA5B63/42351ab0\n\nご検討のほど、よろしくお願い申し上げます。"
445 |     }
446 |     # 非同期関数を実行するためのイベントループを取得
447 |     loop = asyncio.get_event_loop()
448 | 
449 |     # main関数を実行
450 |     final_status, before_img_url, after_img_url = loop.run_until_complete(main(test_url, SEND_CONTENT))
451 | 
452 |     print("\n=== 結果 ===")
453 |     print(f"最終ステータス: {final_status}")
454 |     print(f"送信前の画像URL: {before_img_url}")
455 |     print(f"送信後の画像URL: {after_img_url}")
456 | 
457 | """summerize
458 | このコードで行いたいのは次の処理です。
459 | 
460 | このコードは自動でフォーム営業をしています。そこで入力を押すと3パターンがあります。
461 | 1 送信ボタンを押すと、無事に送信した
462 | 2 送信ボタンを押すと、「この内容で大丈夫ですか？」という文言があり、押したら無事に送信できた
463 | 3 送信ボタンを押すと、問題があり「送信が失敗しました」 と出た
464 | 
465 | これらを二つの指標で判定したいです。
466 | 
467 | 「解析したボタン情報」：
468 | 「【分類結果】
469 | ①（未完了を示す文言）の個数: 0
470 | ②（完了を示す文言）の個数: 0
471 | ③（失敗を示す文言）の個数: 4」など。
472 | 
473 | 
474 | それぞれの分類は以下のとおりです。
475 | 
476 | 
477 | カテゴリーについて。
478 |     # カテゴリー①：作業がまだ終わっていないことを示す文言
479 |     category1_keywords = [
480 |         '上記内容',
481 |         'ご確認ください',
482 |         'よろしければ'
483 |     ]
484 | 
485 |     # カテゴリー②：送信完了など完了を示す文言
486 |     category2_keywords = [
487 |         'ありがとう',
488 |         'ありがとうございました。',
489 |         '送信完了',
490 |         '送信されました',
491 |         '完了',
492 |         'ご連絡いたします',
493 |         'ご連絡させて',
494 |         'ご連絡させていただきます',
495 |         'お送りいたしました',
496 |         '送信いたしました',
497 |         '返答',
498 |         '完了しました',
499 |         '承りました',
500 |         '後日'
501 |     ]
502 | 
503 |     # カテゴリー③：送信失敗を示す文言（重みなし：単純な個数カウント）
504 |     category3_keywords = [
505 |         '失敗しました',
506 |         '失敗'
507 |     ]
508 | 
509 | 
510 | 
511 | 1 送信ボタンを押すと、無事に送信した → statusをsuccessにしたい
512 | 2 送信ボタンを押すと、「この内容で大丈夫ですか？」という文言がある → 送信確定ボタンを押したい
513 | 3 送信ボタンを押すと、問題があり「送信が失敗しました」 と出た → statusをfailedにしてレスポンスしたい。
514 | """
--------------------------------------------------------------------------------

/sample_code/sample_data/dump.py:
--------------------------------------------------------------------------------
  1 | import os
  2 | import re
  3 | import fnmatch
  4 | 
  5 | def should_exclude(file_path):
  6 |     """
  7 |     指定されたファイルパスが除外対象かどうかを判定する
  8 |     """
  9 |     # 除外パターンのリスト
 10 |     exclude_patterns = [
 11 |         # Pythonバイトコード
 12 |         "__pycache__/*", "*.py[cod]", "*$py.class",
 13 |         # 環境設定ファイル
 14 |         ".env", "*.json", ".venv/*", "venv/*", "result/*", "ENV/*", "env.bak/*", "env/*",
 15 |         # pip環境設定ファイル
 16 |         "pip-log.txt", "pip-delete-this-directory.txt",
 17 |         # コンパイル成果物
 18 |         "*.egg-info/*", "*.egg", "*.eggs", "*.whl",
 19 |         # テストカバレッジレポート
 20 |         "htmlcov/*", ".tox/*", ".nox/*", ".coverage", "coverage.*", ".cache",
 21 |         "nosetests.xml", "coverage.xml", "*.cover", "*.py,cover",
 22 |         # Jupyter Notebookのチェックポイント
 23 |         ".ipynb_checkpoints/*",
 24 |         # pylint, mypyなどの設定
 25 |         ".mypy_cache/*", ".pyre/*", ".pytype/*", ".pyright/*",
 26 |         # IDEやエディタの設定ファイル
 27 |         ".vscode/*", ".idea/*", "*.sublime-workspace", "*.sublime-project",
 28 |         # MacやLinuxのシステムファイル
 29 |         ".DS_Store", "*.swp", "*~",
 30 |         # パッケージ管理ツールの成果物
 31 |         "poetry.lock", "Pipfile.lock",
 32 |         # Docker関連
 33 |         "docker-compose.override.yml", ".dockerignore",
 34 |         # その他
 35 |         "*.log", "*.pot", "*.mo", "cline_log.txt", "git_tracking_status.txt",
 36 |         # 本番環境用秘密ファイル
 37 |         "*.pem", ".secrets", ".env.act",
 38 |         # 出力ファイル自体を除外
 39 |         "dump_result.txt"
 40 |     ]
 41 | 
 42 |     # ファイル名のみを取得
 43 |     file_name = os.path.basename(file_path)
 44 | 
 45 |     # ディレクトリパスを含む相対パス
 46 |     rel_path = file_path
 47 | 
 48 |     # 除外パターンとマッチするかチェック
 49 |     for pattern in exclude_patterns:
 50 |         # ファイル名だけでマッチングを試みる
 51 |         if fnmatch.fnmatch(file_name, pattern):
 52 |             return True
 53 | 
 54 |         # パスを含めたマッチングも試みる
 55 |         if fnmatch.fnmatch(rel_path, pattern):
 56 |             return True
 57 | 
 58 |         # __pycache__ ディレクトリ内のファイルを除外
 59 |         if "__pycache__" in rel_path:
 60 |             return True
 61 | 
 62 |     return False
 63 | 
 64 | def dump_files_to_txt(target_dir):
 65 |     """
 66 |     指定されたディレクトリ内のファイルを走査し、内容をdump_result.txtに出力する
 67 |     除外リストに含まれるファイルはスキップする
 68 |     フォルダとファイルはアルファベット順にソートされる
 69 |     """
 70 |     # 出力ファイルのパスを指定されたディレクトリ内に設定
 71 |     output_file = os.path.join(target_dir, "dump_result.txt")
 72 | 
 73 |     # 相対パスの基準となるディレクトリ
 74 |     base_dir = target_dir
 75 | 
 76 |     # ファイルパスを収集してソートする
 77 |     all_files = []
 78 |     for root, dirs, files in os.walk(target_dir):
 79 |         # ディレクトリをアルファベット順にソート
 80 |         dirs.sort()
 81 |         # ファイルをアルファベット順にソート
 82 |         for fname in sorted(files):
 83 |             abs_path = os.path.join(root, fname)
 84 | 
 85 |             # 出力ファイル自体はスキップ
 86 |             if abs_path == output_file:
 87 |                 continue
 88 | 
 89 |             # 除外対象のファイルはスキップ
 90 |             rel_path = os.path.relpath(abs_path, start=base_dir)
 91 |             if should_exclude(rel_path):
 92 |                 continue
 93 | 
 94 |             all_files.append((rel_path, abs_path))
 95 | 
 96 |     # ファイルをアルファベット順にソート
 97 |     all_files.sort()
 98 | 
 99 |     with open(output_file, "w", encoding="utf-8") as out:
100 |         for rel_path, abs_path in all_files:
101 |             out.write(f"/{rel_path}:\n")
102 |             out.write("-" * 80 + "\n")
103 |             try:
104 |                 with open(abs_path, "r", encoding="utf-8") as f:
105 |                     for i, line in enumerate(f, 1):
106 |                         out.write(f"{i:3} | {line.rstrip()}\n")
107 |             except Exception as e:
108 |                 out.write(f"[ERROR READING FILE]: {e}\n")
109 |             out.write("-" * 80 + "\n\n")
110 | 
111 | if __name__ == "__main__":
112 |     # コマンドライン引数を使わず、直接変数に値を設定
113 |     # target_directory = "/Users/neromehiro/hiro folder/my_Works/programing/aimsales-api/module/b_AddCompany"
114 |     target_directory = "/Users/neromehiro/hiro folder/my_Works/programing/autoform_chrome_extention"
115 |     dump_files_to_txt(target_directory)
116 |     print(f"✅ 出力完了: {target_directory}/dump_result.txt")
--------------------------------------------------------------------------------

/settings.js:
--------------------------------------------------------------------------------
  1 | (() => {
  2 |   const MASTER_STORAGE_KEY = "autoformEnabled";
  3 |   const AUTO_RUN_STORAGE_KEY = "autoformAutoRunOnOpen";
  4 | 
  5 |   function setDependentState(enabled) {
  6 |     const dependentCards = document.querySelectorAll('[data-master-scope="dependents"]');
  7 |     dependentCards.forEach((card) => {
  8 |       card.classList.toggle("master-off", !enabled);
  9 |       card.setAttribute("aria-disabled", (!enabled).toString());
 10 |     });
 11 |     const statusText = document.getElementById("master-toggle-status-text");
 12 |     if (statusText) {
 13 |       statusText.textContent = enabled
 14 |         ? "Aimsales AutoForm が有効です"
 15 |         : "OFF: 拡張機能は停止中です";
 16 |       statusText.style.color = enabled ? "#64748b" : "#dc2626";
 17 |     }
 18 |     const dependents = document.querySelectorAll("[data-master-controlled]");
 19 |     dependents.forEach((el) => {
 20 |       el.disabled = !enabled;
 21 |       el.setAttribute("aria-disabled", (!enabled).toString());
 22 |     });
 23 |   }
 24 | 
 25 |   function initMasterToggle() {
 26 |     const checkbox = document.getElementById("extension-master-toggle");
 27 |     if (!checkbox) return;
 28 | 
 29 |     const applyState = (value) => {
 30 |       const enabled = value !== false;
 31 |       checkbox.checked = enabled;
 32 |       setDependentState(enabled);
 33 |     };
 34 | 
 35 |     if (!chrome?.storage?.sync) {
 36 |       applyState(true);
 37 |       checkbox.addEventListener("change", () => {
 38 |         applyState(checkbox.checked);
 39 |       });
 40 |       return;
 41 |     }
 42 | 
 43 |     chrome.storage.sync.get(MASTER_STORAGE_KEY, (res) => {
 44 |       applyState(res?.[MASTER_STORAGE_KEY]);
 45 |     });
 46 | 
 47 |     checkbox.addEventListener("change", () => {
 48 |       const enabled = checkbox.checked;
 49 |       setDependentState(enabled);
 50 |       chrome.storage.sync.set({ [MASTER_STORAGE_KEY]: enabled });
 51 |     });
 52 |   }
 53 | 
 54 |   function initAutoRunToggle() {
 55 |     const checkbox = document.getElementById("autoform-toggle");
 56 |     if (!checkbox) return;
 57 | 
 58 |     const applyState = (value) => {
 59 |       checkbox.checked = value !== false;
 60 |     };
 61 | 
 62 |     if (!chrome?.storage?.sync) {
 63 |       applyState(true);
 64 |       checkbox.addEventListener("change", () => {
 65 |         applyState(checkbox.checked);
 66 |       });
 67 |       return;
 68 |     }
 69 | 
 70 |     chrome.storage.sync.get(AUTO_RUN_STORAGE_KEY, (res) => {
 71 |       applyState(res?.[AUTO_RUN_STORAGE_KEY]);
 72 |     });
 73 | 
 74 |     checkbox.addEventListener("change", () => {
 75 |       chrome.storage.sync.set({ [AUTO_RUN_STORAGE_KEY]: checkbox.checked });
 76 |     });
 77 |   }
 78 | 
 79 |   document.addEventListener("DOMContentLoaded", () => {
 80 |     initMasterToggle();
 81 |     initAutoRunToggle();
 82 |   });
 83 | })();
--------------------------------------------------------------------------------

